{
  
    
        "post0": {
            "title": "기말고사 시험관련 안내사항",
            "content": "&#49884;&#54744;&#50976;&#54805; . - 오픈북: 강의노트, 본인이 정리한 노트, 인터넷 검색 가능 . - 비대면: Zoom을 활용하여 응시 . &#49884;&#54744;&#49884;&#44036; . - 일시: LMS를 통해 공지한 날의 수업시간 . - 시험시간 중 처음 30분은 장비점검시간으로 활용함 (단, 모든 사람이 준비될 경우 30분을 기다리지 않고 시작) . . Note: 따라서 R입문의 경우 장비점검에 30분을 모두 사용한다면 실질적으로 문제를 풀고 답안을 제출할때 까지 쓸 수 있는 시간은 30분입니다. . &#49884;&#54744;&#49892; &#51077;&#51109; . - LMS $ to$ 강의대화 $ to$ Zoom 화상강의 바로 가기로 입장 . &#49884;&#54744;&#47928;&#51228; &#44277;&#44060;&#48169;&#49885; . - LMS 공지사항을 통하여 시험문제의 URL을 공개 . &#51228;&#52636;&#48169;&#49885; &#48143; &#54805;&#49885; . - LMS의 레포트 메뉴를 활용하여 답안지를 제출 (종료시간 이전에 미리 제출가능) . - 제출은 Rmarkdown에서 작성된 pdf파일의 형태만 인정한다. 제출파일은 RMD/PDF 파일이다. . &#51456;&#48708;&#47932; . - 컴퓨터 및 노트북: 시험지 확인 및 문제풀이 용도 . - 핸드폰: Zoom을 통하여 주변상황을 및 컴퓨터 화면을 촬영하는 용도 . . Note: 중간에 핸드폰 및 노트북이 꺼지지 않도록 배터리 충전기를 준비한다. . &#49884;&#54744;&#51204; &#51456;&#48708;&#49324;&#54637; . - 시험준비시간 동안 핸드폰을 아래와 같이 배치하여 학생의 컴퓨터 화면 및 주변상황이 보이도록 함 . . Note: 적절한 각도를 설정하기 어려운 경우 주변환경보다 컴퓨터의 화면이 잘 보이도록 설정할 것 . - 학생증을 준비하여 시험 시작 직전에 본인의 얼굴과 학생증을 함께 촬영한다. (5초간) . &#50976;&#51032;&#49324;&#54637; . - 줌의 대화명은 이름과 학번을 모두 적는다. (예시: 최규빈_202143052) . . Note: 동명이인이 있을 수 있으므로 학번을 같이 적으세요 . - 질문은 카카오톡 채널 혹은 줌의 채팅기능을 이용한다. . - Zoom에서 스피커 음소거를 하지 않는다. (전체 공지사항등이 있을때 음성으로 공지함) . - 핸드폰으로 Zoom참가 중 전화가 오면 거절하고 받지 않는다. (전화통화시 Zoom연결이 종료되므로 부정행위로 의심할 수 있음) . &#44592;&#53440; &#52280;&#44256;&#49324;&#54637; . - 핸드폰과 피씨를 이용하여 줌에 동시접속할 경우 . 최규빈_202143052_핸드폰 | 최규빈_202143052_컴퓨터 | . 와 같이 기기를 분리하여 적는다. . - 시험문제는 코랩으로 풀어도 무방하며 시험문제를 다운받아 개인 주피터노트북 등으로 풀어도 무방하다. . - 제출은 RMD와 PDF파일 형태로 제출한다. 그외의 제출형식(.txt, .R, .html, .png)등은 인정하지 않는다. .",
            "url": "https://guebin.github.io/IR2021/2021/12/20/%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC-%EC%8B%9C%ED%97%98%EA%B4%80%EB%A0%A8-%EC%95%88%EB%82%B4%EC%82%AC%ED%95%AD.html",
            "relUrl": "/2021/12/20/%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC-%EC%8B%9C%ED%97%98%EA%B4%80%EB%A0%A8-%EC%95%88%EB%82%B4%EC%82%AC%ED%95%AD.html",
            "date": " • Dec 20, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "(14주차) 12월9일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/5) 징검다리 문제 III 두번째 풀이 (1) . - (2/5) 징검다리 문제 III 두번째 풀이 (2) . - (3/5) 징검다리 문제 III 세번째 풀이 (1) . - (4/5) 징검다리 문제 III 세번째 풀이 (2) . - (5/5) 징검다리 문제 III 세번째 풀이 (3) . &#51669;&#44160;&#45796;&#47532; &#47928;&#51228; III. . 강화유리와 유리를 구분할 수 있는 유리 장인이 있다. . 이 유리장인은 80퍼센트의 확률로 강화유리를 고른다. . 총 10명의 참가자가 있고 이 참가자들은 (유리,강화유리)의 조합으로 이루어진 징검다리를 5번연속으로 건너야 한다. . 아래의 경우에 참가자들은 평균적으로 몇명이 살아남겠는가? . (1) 일반인1 - 일반인2 - .... - 일반인9 - 유리장인 || (강화유리, 유리) . (2) 유리장인 - 일반인1 - 일반인2 - ... - 일반인9 || (강화유리, 유리) . 1000번 시뮬레이션을 하여 결과를 추정하라. . (단, 일반인은 50%의 확률로 강화유리를 고를수 있다고 하자) . . [예시] (1)의 시뮬레이션 결과가 아래와 같다고 하자. . 첫번째 징검다리: 유리장인이 강화유리 선택 | 두번째 징검다리: 유리장인이 강화유리 선택 | 세번째 징검다리: 유리장인이 일반유리 선택 $ to$ 유리장인 탈락 &amp; 일반인9는 당연히 강화유리를 선택 | 네번째 징검다리: 일반인9가 일반유리 선택 $ to$ 일반인9 탈락 &amp; 일반인8은 당연히 강화유리 선택 | 다섯번째 징검다리: 일반인8이 강화유리 선택 | . 이 경우는 일반인8,일반인7, $ dots$, 일반인1이 살아남으므로 8명이 살아남는다. . [예시] (2)의 시뮬레이션 결과가 아래와 같다고 하자. . 첫번째 징검다리: 일반인9 일반유리 선택 $ to$ 일반인9 탈락 &amp; 일반인8은 강화유리 선택 | 두번째 징검다리: 일반인8 일반유리 선택 $ to$ 일반인8 탈락 &amp; 일반인7은 강화유리 선택 | 세번째 징검다리: 일반인7 일반유리 선택 $ to$ 일반인7 탈락 &amp; 일반인6은 강화유리 선택 | 네번째 징검다리: 일반인6 일반유리 선택 $ to$ 일반인6 탈락 &amp; 일반인5는 강화유리 선택 | 다섯번째 징검다리: 일반인5 일반유리 선택 $ to$ 일반인5 탈락 &amp; 일반인4는 강화유리 선택 | . 이 경우는 일반인4,일반인3,일반인2,일반인1,유리장인 이 살아남는다. (따라서 5명) . - 즉 살아남을수 있는 최대인원수는 10명이며 최소인원수는 5명이다. . - 유리장인이 100%의 확률로 강화유리를 구분한다면 (1)의 경우 항상 10명이 살아남는다. (즉 평균도 10명) . &#54400;&#51060;2 . - 아래와 같은 수식을 세울 수 있다. . 총 살아남은 사람의 수 = 5 + 장인의 성공횟수 + (5-장인의성공횟수-1)의 기회중에서 일반인의 성공횟수 . 단 (5-장인의성공횟수-1)=&lt;0 이면 마지막항은 0으로 계산한다. | . - 장인의 성공횟수를 $x$, 일반인의 성공횟수를 $y$라고 하자. 그러면 구하는것은 $5+x+y$이다. . - 장인의 성공횟수 . library(tidyverse) . x_ = rbinom(5,size=1,0.8) x_ . [1] 1 1 1 0 1 . cumprod(x_) . [1] 1 1 1 0 0 . x=sum(cumprod(x_)) print(x) . [1] 3 . - 일반인의 성공횟수 . xx_ = 5-x-1 . print(xx_) . [1] 1 . y = rbinom(1, size=xx_, 0.5) y . [1] 1 . - 살아남은 사람수는? . print(5+x+y) . [1] 9 . - 정리하면 . rslt &lt;- c() for (i in 1:10000){ x=sum(cumprod(rbinom(5,size=1,0.8))) xx_=5-x-1 if (xx_&gt;0) y = rbinom(1, size=xx_, 0.5) else y=0 rslt[i]=5+x+y } . mean(rslt) . [1] 8.4895 . &#54400;&#51060;3 . ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) ARR . [1] &#34;N1&#34; &#34;N2&#34; &#34;N3&#34; &#34;N4&#34; &#34;N5&#34; &#34;N6&#34; &#34;N7&#34; &#34;N8&#34; &#34;N9&#34; &#34;A&#34; . SURV = 10 . PLAYER = ARR[SURV] PLAYER . [1] &#34;A&#34; . STAGE = 0 . - 첫시도 . toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical . PROB = 0.8 TOSSRSLT = toss(PROB) if (TOSSRSLT==TRUE){ SURV = SURV STAGE = STAGE + 1 PLAYER = ARR[SURV] }else{ SURV = SURV - 1 STAGE = STAGE + 1 PLAYER = ARR[SURV] } . print(TOSSRSLT) print(SURV) print(STAGE) print(PLAYER) . [1] TRUE [1] 10 [1] 1 [1] &#34;A&#34; . - 코드를 간단히 수정하자. . PROB = 0.8 TOSSRSLT = toss(PROB) if (TOSSRSLT==FALSE) SURV = SURV - 1 STAGE = STAGE + 1 PLAYER = ARR[SURV] . print(TOSSRSLT) print(SURV) print(STAGE) print(PLAYER) . [1] TRUE [1] 10 [1] 2 [1] &#34;A&#34; . - 다시 처음부터 보고싶다면? . SURV = 10 STAGE = 0 PLAYER = ARR[SURV] . PROB = 0.8 TOSSRSLT = toss(PROB) if (TOSSRSLT==FALSE) SURV = SURV - 1 STAGE = STAGE + 1 PLAYER = ARR[SURV] . print(TOSSRSLT) print(SURV) print(STAGE) print(PLAYER) . [1] TRUE [1] 10 [1] 1 [1] &#34;A&#34; . - reset을 하는 함수를 만들자. . reset = function(){ SURV = 10 STAGE = 0 PLAYER = ARR[SURV] } . 제대로 동작하지 않음 $ to$ =를 &lt;&lt;-로 수정해보자. | . reset = function(){ SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } . reset() . print(TOSSRSLT) print(SURV) print(STAGE) print(PLAYER) . [1] TRUE [1] 10 [1] 0 [1] &#34;A&#34; . - 출력함수의 기능을 묶어보자. $ to$ 출력(display)와 저장기능을 통합하여 record 함수 만듬 . record = function() list(TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) . record()$SURV %&gt;% print . [1] 10 . - reset + record 를 사용하고 결과를 살펴보면 . reset() record() . $TOSSRSLT [1] TRUE $SURV [1] 10 $STAGE [1] 0 $PLAYER [1] &#34;A&#34; . TOSSRSLT의 의미가 헷갈릴수 있으니 약간 수정하자. | . record = function() list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) . reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } . reset() record() . $PRE_TOSSRSLT [1] NA $SURV [1] 10 $STAGE [1] 0 $PLAYER [1] &#34;A&#34; . - 지금까지 코드의 중간정리 . ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) SURV = 10 PLAYER = ARR[SURV] STAGE = 0 PROB = 0.8 TOSSRSLT = NA ### 변수들의 모음 . toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } record = function(){ list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) } ### 함수들의 모음 . PROB = 0.8 TOSSRSLT = toss(PROB) if (TOSSRSLT==FALSE) SURV = SURV - 1 STAGE = STAGE + 1 PLAYER = ARR[SURV] ### body . - PROB 가 항상 0.8인것은 아니며 사실 PLAYER==&#39;A&#39; 일 경우에만 0.8 이고 그외의 경우는 0.5 이다. . ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) SURV = 10 PLAYER = ARR[SURV] STAGE = 0 PROB = 0.8 TOSSRSLT = NA ### 변수들의 모음 . toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } record = function(){ list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) } ### 함수들의 모음 . PROB = 0.5+ (PLAYER==&#39;A&#39;)*0.3 #### 이부분을 수정했음 TOSSRSLT = toss(PROB) if (TOSSRSLT==FALSE) SURV = SURV - 1 STAGE = STAGE + 1 PLAYER = ARR[SURV] ### body . - Test 해보자. . reset() record() . $PRE_TOSSRSLT [1] NA $SURV [1] 10 $STAGE [1] 0 $PLAYER [1] &#34;A&#34; . PROB = 0.5+ (PLAYER==&#39;A&#39;)*0.3 #### 이부분을 수정했음 TOSSRSLT = toss(PROB) if (TOSSRSLT==FALSE) SURV = SURV - 1 STAGE = STAGE + 1 PLAYER = ARR[SURV] record() . $PRE_TOSSRSLT [1] TRUE $SURV [1] 10 $STAGE [1] 1 $PLAYER [1] &#34;A&#34; . - 스테이지를 진행하는 부분을 묶어서 함수로 처리하자. . ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) SURV = 10 PLAYER = ARR[SURV] STAGE = 0 PROB = 0.8 TOSSRSLT = NA ### 변수들의 모음 . toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } record = function(){ list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) } go = function(){ PROB &lt;&lt;- 0.5+ (PLAYER==&#39;A&#39;)*0.3 TOSSRSLT &lt;&lt;- toss(PROB) if (TOSSRSLT==FALSE) SURV &lt;&lt;- SURV - 1 STAGE &lt;&lt;- STAGE + 1 PLAYER &lt;&lt;- ARR[SURV] } ### 함수들의 모음 . ### body . - test . reset() record() . $PRE_TOSSRSLT [1] NA $SURV [1] 10 $STAGE [1] 0 $PLAYER [1] &#34;A&#34; . go() record() . $PRE_TOSSRSLT [1] FALSE $SURV [1] 9 $STAGE [1] 1 $PLAYER [1] &#34;N9&#34; . - 어차피 5번 시행을 하므로 go이외에 gogo함수를 따로 만들자. . ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) SURV = 10 PLAYER = ARR[SURV] STAGE = 0 PROB = 0.8 TOSSRSLT = NA ### 변수들의 모음 . toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } record = function(){ list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) } go = function(){ PROB &lt;&lt;- 0.5+ (PLAYER==&#39;A&#39;)*0.3 TOSSRSLT &lt;&lt;- toss(PROB) if (TOSSRSLT==FALSE) SURV &lt;&lt;- SURV - 1 STAGE &lt;&lt;- STAGE + 1 PLAYER &lt;&lt;- ARR[SURV] } gogo = function() for(i in 1:5) go() ### 함수들의 모음 . - test . reset() record() . $PRE_TOSSRSLT [1] NA $SURV [1] 10 $STAGE [1] 0 $PLAYER [1] &#34;A&#34; . gogo() record() . $PRE_TOSSRSLT [1] TRUE $SURV [1] 9 $STAGE [1] 5 $PLAYER [1] &#34;N9&#34; . - 히스토리를 볼 수 있는 gogo함수를 만들어보자. . gogo_history = function(){ rslt_ = as_tibble(record()) ## go를 시작하기전의 결과가 티블로 만들어짐 for(i in 1:5){ go() rslt_ = rbind(rslt_, as_tibble(record())) } print(rslt_) } . reset() record() . $PRE_TOSSRSLT [1] NA $SURV [1] 10 $STAGE [1] 0 $PLAYER [1] &#34;A&#34; . gogo_history() . # A tibble: 6 × 4 PRE_TOSSRSLT SURV STAGE PLAYER &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 NA 10 0 A 2 FALSE 9 1 N9 3 TRUE 9 2 N9 4 TRUE 9 3 N9 5 FALSE 8 4 N8 6 TRUE 8 5 N8 . - 이제 simulate_once 라는 함수를 만들어서 시뮬레이션 결과를 저장하자. . simulate_once = function(){ reset() gogo() return(record()$SURV ) } . simulate_once() %&gt;% print . [1] 10 . - 따라서 답은 . simrslt = c() for (i in 1:100000) simrslt[i] = simulate_once() mean(simrslt) %&gt;% print . [1] 8.51736 . - 코드를 최종적으로 정리하면 . ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) SURV = 10 PLAYER = ARR[SURV] STAGE = 0 PROB = 0.8 TOSSRSLT = NA ### 변수들의 모음 . toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } record = function(){ list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) } go = function(){ PROB &lt;&lt;- 0.5+ (PLAYER==&#39;A&#39;)*0.3 TOSSRSLT &lt;&lt;- toss(PROB) if (TOSSRSLT==FALSE) SURV &lt;&lt;- SURV - 1 STAGE &lt;&lt;- STAGE + 1 PLAYER &lt;&lt;- ARR[SURV] } gogo = function() for(i in 1:5) go() gogo_history = function(){ rslt_ = as_tibble(record()) ## go를 시작하기전의 결과가 티블로 만들어짐 for(i in 1:5){ go() rslt_ = rbind(rslt_, as_tibble(record())) } print(rslt_) } simulate_once = function(){ reset() gogo() return(record()$SURV ) } ### 함수들의 모음 . simrslt = c() for (i in 1:100000) simrslt[i] = simulate_once() mean(simrslt) ### body . [1] 8.50571 . &#51060;&#47084;&#54620; &#48169;&#49885;&#51032; &#53076;&#46377;&#49828;&#53440;&#51068; . - 장점: 함수의 입력/출력을 상당부분 생략가능, 함수의 출력을 어딘가에 저장하는 번거로운 과정도 스킵가능, 구현이 쉬움 . - 단점: 지정한 변수들과 함수의 목록을 한번에 파악하기 힘듬. 하나의 노트북에서 다른 풀이도 함께하다보면 변수이름들이 매우 헷갈릴수 있음. . - 단점을 극복하기 위한 대안 (1) 하나의 노트북을 사용한다. (2) 변수나 함수들을 모두 초기화한다. (커널초기화) (3) 이 모든것을 하나의 함수로 묶는다. . - (2) 변수나 함수들을 모두 초기화하는 방법 . ls() ## 현재 R에 저장된 변수목록을 출력 . [1] &#34;ARR&#34; &#34;go&#34; &#34;gogo&#34; &#34;gogo_history&#34; [5] &#34;i&#34; &#34;PLAYER&#34; &#34;PROB&#34; &#34;record&#34; [9] &#34;reset&#34; &#34;rslt&#34; &#34;simrslt&#34; &#34;simulate_once&#34; [13] &#34;STAGE&#34; &#34;SURV&#34; &#34;toss&#34; &#34;TOSSRSLT&#34; [17] &#34;x&#34; &#34;x_&#34; &#34;xx_&#34; &#34;y&#34; . rm(list=ls()) # 현재 R환경에 있는 함수+변수를 삭제 . ls() ## 현재 R에 저장된 변수목록을 출력 . character(0) . 이제 R에는 더이상 함수나 변수가 없다. | . - (3) 이 모든것을 하나의 함수로 묶는방법 . rm(list=ls()) . ls() . character(0) . 일단 R환경은 깨끗한 상태임 | . SIMULATE = function(){ ### 변수들의 모음 ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) SURV = 10 PLAYER = ARR[SURV] STAGE = 0 PROB = 0.8 TOSSRSLT = NA ### Subfunction들의 모음 toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } record = function(){ list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) } go = function(){ PROB &lt;&lt;- 0.5+ (PLAYER==&#39;A&#39;)*0.3 TOSSRSLT &lt;&lt;- toss(PROB) if (TOSSRSLT==FALSE) SURV &lt;&lt;- SURV - 1 STAGE &lt;&lt;- STAGE + 1 PLAYER &lt;&lt;- ARR[SURV] } gogo = function() for(i in 1:5) go() gogo_history = function(){ rslt_ = as_tibble(record()) ## go를 시작하기전의 결과가 티블로 만들어짐 for(i in 1:5){ go() rslt_ = rbind(rslt_, as_tibble(record())) } print(rslt_) } simulate_once = function(){ reset() gogo() return(record()$SURV ) } ### BODY simrslt = c() for (i in 1:100000) simrslt[i] = simulate_once() mean(simrslt) } . ls() . [1] &#34;SIMULATE&#34; . 현재는 SIMULATE 하나만 저장되어있음 | . SIMULATE() . [1] 8.5075 . ls() . [1] &#34;SIMULATE&#34; . 실행한이후에도 SIMULATE 하나만 저장되어 있음 | .",
            "url": "https://guebin.github.io/IR2021/2021/12/09/(14%EC%A3%BC%EC%B0%A8)-12%EC%9B%949%EC%9D%BC.html",
            "relUrl": "/2021/12/09/(14%EC%A3%BC%EC%B0%A8)-12%EC%9B%949%EC%9D%BC.html",
            "date": " • Dec 9, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "(11주차) 11월18일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8) 지난시간 숙제풀이 . - (2/8) 정적분의 계산 (1) . - (3/8) 정적분의 계산 (2) . - (4/8) 정적분의 계산 (3) . - (5/8) 균등분포, 베르누이분포, 이항분포의 생성 . - (6/8) 샘플링 (1) . - (7/8) 샘플링 (2) . - (8/8) 숙제설명 . &#51221;&#51201;&#48516;&#51032; &#44228;&#49328; (2007&#45380; 9&#50900; &#54217;&#44032;&#50896;) . (문제) $ int_0^2 |x^2(x-1)| dx $ 의 값은? . (1) $ frac{3}{2}$ . (2) $2$ . (3) $ frac{5}{2}$ . (4) $3$ . (5) $ frac{7}{2}$ . (풀이) . x=seq(from=0, to=2, by=0.01) y=abs(x**2 * (x-1)) . plot(x,y,type=&#39;l&#39;) . - 아이디어: (1) 가로가 2 세로가 4인 작사각형에 임의의 점을 뿌린다. (2) 전체점의 수와 함수 아래에 위치한 점의 갯수를 센다. (3) 점의 갯수를 바탕으로 넓이를 추론한다. . xx=runif(10000) # 0~1 사이의 점을 랜덤으로 10000개 뽑음 . xx = xx*2 # 0~2사이의 값을 랜덤으로 10000개 뽑은것과 같은 효과 . yy=runif(10000)*4 # 0~4 사의의 점을 랜덤으로 10000개 뽑음 . plot(xx,yy) . 가로가 2, 세로가 4인 직사각형에 무작위로 점이 흩뿌려져 있다. . plot(xx,yy) lines(x,y,col=&#39;red&#39;,lwd=3) . 붉은선 아래의 점들이 몇개일까? . test = function(xx,yy){ yy &lt; abs(xx**2 * (xx-1)) } . print(c(xx[1],yy[1])) ## xx[1], yy[1] 의 값 = 무작위로 찍힌 값 print(abs(xx[1]**2 *(xx[1]-1))) ## xx[1]에 해당하는 붉은점의 값 test(xx[1],yy[1]) . [1] 0.830618 2.372124 [1] 0.1168611 . [1] FALSE . plot(xx,yy,col=&#39;gray&#39;) lines(x,y,col=&#39;red&#39;,lwd=3) points(xx[1],yy[1],col=&#39;blue&#39;) points(xx[1],abs(xx[1]**2 * (xx[1]-1)),col=&#39;red&#39;) . tst = c() for (i in 1:10000) tst[i] = test(xx[i],yy[i]) . head(tst) . [1] FALSE FALSE FALSE FALSE FALSE FALSE . plot(xx,yy,col=&#39;gray&#39;) lines(x,y,col=&#39;red&#39;,lwd=3) points(xx[tst],yy[tst],col=&#39;red&#39;) . 붉은점들의 갯수는? tst==TRUE인 점들의 수 . sum(tst) . [1] 1829 . 전체 10000개 중에서 1829개정도가 붉은점임. 따라서 . $$ frac{s}{8} approx frac{1829}{10000}$$ . 이므로 구하는 넓이는 대략적으로 . 1829/10000 * 8 . [1] 1.4632 . 따라서 답은 1번 3/2 이다. . - 이와 같은 방법을 몬테카를로 방법이라고 한다. . - 꽤 복잡한 함수에 대하여서도 정적분의 값을 근사적으로 계산해낼 수 있다는 장점이 있음. . (풀이2) . - 사실 그냥 아래와 같이 풀어도 된다. . sum(yy &lt; abs(xx^2 * (xx-1)) ) . [1] 1829 . &#47004;&#45924;&#48320;&#49688; . &#47004;&#45924;&#48320;&#49688;&#47484; &#49373;&#49457;&#54616;&#45716; &#48169;&#48277; . &#50696;&#51228;1: &#44512;&#46321;&#48516;&#54252; . - 목표: 구간 [0,1]에서 하나의 임의의 값을 뽑는것 (이때 구간 [0,1]에서 각 점이 뽑힐 확률은 동일) . runif(1) . [1] 0.7638336 . - 목표: 구간 [0,1]에서 10개의 값을 뽑고 싶다면? . runif(10) . [1] 0.43916197 0.58808151 0.01061738 0.57311258 0.62008149 0.79359762 [7] 0.43567517 0.06111325 0.66865770 0.98463477 . - 10000개의 값을 뽑아보고 평균이 0.5근처인지 체크해보자. . runif(10000) %&gt;% mean . [1] 0.5001962 . &#50696;&#51228;2: &#44512;&#46321;&#48516;&#54252; . - 목표: 구간 [0,2]에서 하나의 값을 임의로 뽑고 싶다. (이때 구간 [0,2]에서 각 점이 뽑힐 확률은 동일) . - 방법1 . runif(n=1,min=0,max=2) . [1] 0.7713044 . - 방법2 . runif(1)*2 . [1] 1.197119 . 왜 방법2처럼 해도되는가? $X sim U(0,1)$ 이면 $2X sim U(0,2)$ 이므로 | 이론적인 내용은 수리통계학에서 배울것임 | . - 10000개의 값을 뽑아보고 평균이 1인지 살펴보자. . runif(n=10000,min=0,max=2) %&gt;% mean . [1] 0.9979827 . (runif(10000)*2) %&gt;% mean . [1] 0.9942539 . &#50696;&#51228;3: &#48288;&#47476;&#45572;&#51060;&#48516;&#54252; ($n=1$&#51064; &#51060;&#54637;&#48516;&#54252;) . - 목표: 동전을 한번 던져서 앞면이 나오는 경우를 생성하고 싶음 (이때 동전은 공평한 동전이라 가정하자. 즉 앞면이 나올 횟수와 뒷면이 나올 횟수는 같다고 하자.) . rbinom(1,size=1,prob=0.5) . [1] 0 . 앞면이 1, 뒷면이 0이라고 생각 | . - 잘 되는것이 맞는지 한번 체크해보자. (10000개 정도의 동전을 던져서 결과를 저장하고 평균이 0.5인지 체크하자) . rbinom(10000,size=1,prob=0.5) %&gt;% mean . [1] 0.5022 . - 동전이 공평하지 않다고 하자. 예를들어 앞면이 나올 확률이 0.8이라고 생각하자. . rbinom(10000,size=1,prob=0.8) %&gt;% mean . [1] 0.8083 . &#50696;&#51228;4: &#51060;&#54637;&#48516;&#54252; . - 목표: 동전을 10회던져 앞면이 나올 총 횟수를 생성하자. . 동전을 10회던져 앞면이 나온 횟수를 $X$라고 하자. $X$를 생성하라. | . rbinom(1,size=10,prob=0.5) . [1] 3 . - 평균적으로 5가 나와야 한다. (10000번 정도 뽑아보고 관찰하자) . rbinom(10000,size=10,prob=0.5) %&gt;% mean . [1] 5.0029 . - 베르누이 분포는 이항분포의 특수한 경우이다. . - 직관적으로 생각하면 아래와 같이 이항분포를 생성해도 될 것 같다. . rbinom(10,size=1,prob=0.5) %&gt;% sum . [1] 4 . X=c() for (i in 1:10000) X[i] = rbinom(10,size=1,prob=0.5) %&gt;% sum . X . [1] 6 5 7 2 2 5 4 5 5 2 3 5 5 4 5 5 4 6 5 5 3 3 5 3 [25] 5 3 9 4 8 3 3 5 5 3 6 4 7 4 7 6 6 4 5 5 7 3 5 2 [49] 6 5 5 5 4 6 8 5 2 4 4 6 6 4 7 5 4 1 4 5 7 7 4 5 [73] 4 5 4 7 4 4 3 4 6 6 5 4 6 5 5 5 6 4 5 6 4 4 8 6 [97] 5 5 3 8 4 4 5 2 4 3 2 3 5 4 5 7 4 4 9 5 4 5 5 5 [121] 7 4 6 6 6 5 3 5 7 6 7 4 3 6 4 3 4 6 5 6 6 5 6 9 [145] 4 6 10 2 6 3 7 3 6 2 2 5 6 6 5 3 3 5 5 7 5 5 5 5 [169] 6 3 5 6 3 6 3 6 4 6 5 5 4 5 6 3 5 6 3 5 6 6 4 7 [193] 5 4 3 8 5 5 5 4 7 5 5 5 5 4 6 6 5 4 3 10 5 4 5 4 [217] 4 5 4 9 4 5 3 4 4 3 5 3 4 4 5 7 3 4 6 5 8 5 4 3 [241] 5 4 4 6 7 5 7 5 4 8 3 6 5 5 3 5 5 3 2 5 5 4 6 6 [265] 6 4 6 5 3 3 6 6 5 5 4 5 5 4 7 6 5 4 3 4 4 4 5 5 [289] 3 6 6 3 6 4 6 7 4 6 3 4 5 3 5 3 5 7 4 2 6 4 5 4 [313] 5 7 8 1 7 4 5 8 5 3 6 6 6 7 5 8 4 6 6 6 4 6 3 6 [337] 5 4 5 6 8 7 3 5 6 6 5 5 4 3 8 4 6 4 3 2 5 8 5 6 [361] 2 4 5 5 5 5 6 5 4 5 4 4 2 6 5 7 3 3 6 6 9 6 4 6 [385] 4 5 8 4 7 5 6 5 5 8 6 4 5 3 6 6 5 7 6 8 3 3 6 7 [409] 8 5 5 5 6 6 5 4 6 3 4 4 5 5 6 6 5 5 8 4 5 6 2 4 [433] 3 1 4 6 7 5 3 5 9 8 5 6 2 4 5 5 6 6 5 5 7 6 6 4 [457] 7 4 4 7 7 2 3 7 3 7 4 5 6 4 4 4 5 7 2 4 8 7 6 6 [481] 5 4 4 6 5 5 3 7 2 3 8 4 4 3 5 3 6 4 6 6 5 4 4 7 [505] 3 6 3 5 2 3 4 5 6 4 3 4 7 5 7 6 4 6 7 2 6 8 5 2 [529] 7 5 3 8 7 6 5 3 6 5 7 2 6 3 5 5 3 4 6 2 2 4 6 3 [553] 5 6 8 4 4 7 5 6 2 8 7 5 6 5 1 7 7 2 5 4 5 7 4 6 [577] 7 3 6 7 6 4 4 7 5 5 5 5 4 1 5 5 5 5 6 1 5 2 3 2 [601] 3 5 6 0 5 4 3 5 6 2 5 3 5 6 6 6 2 4 4 4 3 5 7 5 [625] 4 6 4 9 4 7 4 5 7 8 6 5 5 6 7 3 4 4 4 5 6 5 6 3 [649] 6 7 5 5 3 4 5 3 4 6 3 4 3 7 3 5 6 6 5 6 6 3 3 5 [673] 6 4 2 6 6 6 6 4 5 5 5 3 7 4 6 3 4 6 6 7 3 1 8 1 [697] 7 6 8 7 4 7 3 3 3 4 3 8 4 4 6 3 6 2 2 5 3 5 8 6 [721] 2 6 5 7 6 5 7 4 7 6 3 5 4 4 6 7 5 6 4 5 4 4 6 5 [745] 4 7 6 5 6 7 5 7 2 5 2 5 3 6 5 7 7 6 4 3 2 1 9 6 [769] 5 6 4 8 6 5 4 5 5 3 5 3 5 6 8 5 5 6 2 5 3 5 3 4 [793] 4 5 5 4 4 6 4 4 4 5 5 5 6 7 5 3 7 6 5 7 7 5 6 7 [817] 3 6 4 3 6 5 6 3 7 5 6 6 6 6 4 7 6 5 3 3 6 5 3 5 [841] 5 6 5 4 6 6 5 6 5 4 5 6 3 4 5 5 4 8 3 6 4 5 6 8 [865] 5 6 9 5 7 7 4 4 6 7 4 5 6 4 4 5 6 6 4 5 2 5 6 3 [889] 5 5 5 5 3 5 5 7 3 6 6 7 5 2 5 5 8 4 3 4 6 6 3 5 [913] 7 7 5 6 5 6 4 3 7 4 9 9 7 4 3 6 4 3 4 3 5 6 5 4 [937] 5 5 4 4 2 3 4 7 6 6 4 5 5 7 5 8 6 8 5 5 6 6 4 6 [961] 6 2 5 8 8 5 7 6 6 7 7 8 3 5 3 4 6 6 6 5 7 3 6 4 [985] 1 5 5 2 4 7 4 8 5 6 3 5 4 6 6 5 [ reached getOption(&#34;max.print&#34;) -- omitted 9000 entries ] . 직관적으로 생각하면 X는 rbinom(10000,size=10,prob=0.5) 와 같은 효과 (랜덤성 때문에 같은 값은 아님) 일 것 같은데 이는 실제로 그러하다. (좀 더 엄밀한 증명은 수리통계 시간에 배운다) | . X %&gt;% mean() . [1] 5.0216 . &#50612;&#46496;&#54620; &#51665;&#54633;&#50640;&#49436; &#49368;&#54540;&#47553; . &#50696;&#51228;5: &#48708;&#48373;&#50896;&#52628;&#52636; . - 주머니에서 빨간공 2개와 파란공 3개가 있다고 하자. . set = c(rep(&quot;red&quot;,2),rep(&quot;blue&quot;,3)) set . [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; . - 이러한 집합에서 랜덤으로 3개의 원소를 고르고 싶다면? (단, 뽑은 공은 다시 넣지 않는다) . sample(set,size=3) . [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; . - 50번정도 해보자. . for (i in 1:50) sample(set,size=3) %&gt;% print . [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; . 빨간공을 3번 뽑지는 못함 | . &#50696;&#51228;6: &#48373;&#50896;&#52628;&#52636; . - 뽑은공을 다시 넣는다고 가정한다면? . set = c(rep(&quot;red&quot;,2),rep(&quot;blue&quot;,3)) set . [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; . for (i in 1:50) sample(set, size=3,replace = TRUE) %&gt;% print . [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; . 빨간공을 3번 뽑을 수 있음 | . (&#51064;&#45937;&#49828;,&#54869;&#47456;) &#51221;&#48372;&#44032; &#51452;&#50612;&#51276;&#51012; &#44221;&#50864; &#49368;&#54540;&#47553; . &#50696;&#51228;7: &#50696;&#51228;6&#51032; &#45796;&#47480;&#44396;&#54788; . - 예제6의 코드는 아래와 같다. . set = c(&#39;red&#39;,&#39;blue&#39;) ## 인덱스.. p = c(0.4,0.6) ## 인덱스에 해당하는 확률 . sample(set,size=3, prob=p, replace = T) . [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; . - 아래와 같은 코드로도 응용가능하다. . sample(set,size=20,prob=c(0.95,0.05),replace=T) . [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; [11] &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; . &#51204;&#52404;&#51665;&#54633;&#50640;&#49436; &#49436;&#47196; &#45796;&#47480; &#54869;&#47456;&#47196; &#50896;&#49548;&#44032; &#48977;&#55176;&#45716; &#44221;&#50864; . &#50696;&#51228;8 . - 예제7의 코드에서 replace를 제외한다면? . set = c(&#39;red&#39;,&#39;blue&#39;) ## 인덱스.. . sample(set,size=20,prob=c(0.95,0.05)) . Error in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when &#39;replace = FALSE&#39; Traceback: 1. sample(set, size = 20, prob = c(0.95, 0.05)) 2. sample.int(length(x), size, replace, prob) . 당연히 에러가남 (원소가 2개 있는 set에서 20개를 뽑으라고 하니..) | . - 아래는 에러가 나지 않을 것임 . sample(set,size=2,prob=c(0.95,0.05)) . [1] &#34;red&#34; &#34;blue&#34; . - 의미는? . rslt = matrix(rep(&quot;-&quot;,1000*2),ncol=2) head(rslt) . [,1] [,2] [1,] - - [2,] - - [3,] - - [4,] - - [5,] - - [6,] - - . for (i in 1:1000) rslt[i,] = sample(set,size=2,prob=c(0.95,0.05)) . head(rslt) . [,1] [,2] [1,] red blue [2,] red blue [3,] red blue [4,] red blue [5,] red blue [6,] red blue . sum(rslt[,1]==&#39;red&#39;)/1000 . [1] 0.947 . 대략 95% | . - 첫번째가 붉은 공이 뽑힐 확률은 95%임. 그리고 두번째 공은 첫번째 공과 다른색이 뽑힘 . &#49689;&#51228;: &#51669;&#44160;&#45796;&#47532; &#44148;&#45320;&#44592; . (유리,강화유리)의 쌍으로 이루어진 징검다리가 총 5개 있다고 하자. (따라서 징검다리는 모두 10개이다) . 강화유리로 된 징검다리를 밟으면 살아남지만 유리로 된 징검다리를 밟으면 죽는다. . 따라서 강화유리로 된 징검다리를 계속 골라야 살아남을 수 있다. . A씨는 유리공장에서 20년 근무한 장인으로 유리와 강화유리를 구분할수 있는 능력을 가졌다고 하자. . 그래서 강화유리로 된 징검다리를 고를 확률이 80%라고 하자. . A씨가 살아남을 확률을 시뮬레이션을 통하여 구하여라. . Hint: 총 1000번의 시뮬레이션을 수행하고 그중에서 A씨가 살아남는 케이스가 몇회정도 되는지 찾아라. .",
            "url": "https://guebin.github.io/IR2021/2021/11/18/(11%EC%A3%BC%EC%B0%A8)-11%EC%9B%9418%EC%9D%BC.html",
            "relUrl": "/2021/11/18/(11%EC%A3%BC%EC%B0%A8)-11%EC%9B%9418%EC%9D%BC.html",
            "date": " • Nov 18, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "2021년 2학기 R입문 중간고사 풀이",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - 문제5, 문제6은 수업시간에 설명하였으므로 풀이생략합니다. . 1. R&#51012; &#51060;&#50857;&#54616;&#50668; &#45796;&#51020;&#51012; &#44228;&#49328;&#54616;&#50668;&#46972;. (3&#51216;) . (a) $2^{-5}+2^{3}$ . (b) $ sqrt{33}$ . (c) $ sum_{k=1}^{100} frac{1}{k^2+2k+1}= sum_{k=1}^{100}(k+1)^{-2}$ . (풀이) . - (c)만 풀겠습니다. . - 방법1: for문을 이용 . ak &lt;-c() for (k in 1:100) ak[k] &lt;- 1/(k**2 + 2*k + 1) sum(ak) . [1] 0.6350819 . - 방법2: 벡터의 연산을 이용한다. . k=1:100 sum(1/(k**2 + 2*k + 1) ) . [1] 0.6350819 . - 수학을 좋아하는 사람? . k=1:100 sum((k+1)^(-2)) . [1] 0.6350819 . - 제 생각에는 방법2가 좋은것 같아요. (계산효율면에서 좋고 디버깅이 편해요) . 1:100 . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 [91] 91 92 93 94 95 96 97 98 99 100 . (1:100)**2 . [1] 1 4 9 16 25 36 49 64 81 100 121 144 [13] 169 196 225 256 289 324 361 400 441 484 529 576 [25] 625 676 729 784 841 900 961 1024 1089 1156 1225 1296 [37] 1369 1444 1521 1600 1681 1764 1849 1936 2025 2116 2209 2304 [49] 2401 2500 2601 2704 2809 2916 3025 3136 3249 3364 3481 3600 [61] 3721 3844 3969 4096 4225 4356 4489 4624 4761 4900 5041 5184 [73] 5329 5476 5625 5776 5929 6084 6241 6400 6561 6724 6889 7056 [85] 7225 7396 7569 7744 7921 8100 8281 8464 8649 8836 9025 9216 [97] 9409 9604 9801 10000 . (1:100)**2 + 2*(1:100) . [1] 3 8 15 24 35 48 63 80 99 120 143 168 [13] 195 224 255 288 323 360 399 440 483 528 575 624 [25] 675 728 783 840 899 960 1023 1088 1155 1224 1295 1368 [37] 1443 1520 1599 1680 1763 1848 1935 2024 2115 2208 2303 2400 [49] 2499 2600 2703 2808 2915 3024 3135 3248 3363 3480 3599 3720 [61] 3843 3968 4095 4224 4355 4488 4623 4760 4899 5040 5183 5328 [73] 5475 5624 5775 5928 6083 6240 6399 6560 6723 6888 7055 7224 [85] 7395 7568 7743 7920 8099 8280 8463 8648 8835 9024 9215 9408 [97] 9603 9800 9999 10200 . (1:100)**2 + 2*(1:100) +1 . [1] 4 9 16 25 36 49 64 81 100 121 144 169 [13] 196 225 256 289 324 361 400 441 484 529 576 625 [25] 676 729 784 841 900 961 1024 1089 1156 1225 1296 1369 [37] 1444 1521 1600 1681 1764 1849 1936 2025 2116 2209 2304 2401 [49] 2500 2601 2704 2809 2916 3025 3136 3249 3364 3481 3600 3721 [61] 3844 3969 4096 4225 4356 4489 4624 4761 4900 5041 5184 5329 [73] 5476 5625 5776 5929 6084 6241 6400 6561 6724 6889 7056 7225 [85] 7396 7569 7744 7921 8100 8281 8464 8649 8836 9025 9216 9409 [97] 9604 9801 10000 10201 . 1 / ((1:100)**2 + 2*(1:100) +1) . [1] 0.2500000000 0.1111111111 0.0625000000 0.0400000000 0.0277777778 [6] 0.0204081633 0.0156250000 0.0123456790 0.0100000000 0.0082644628 [11] 0.0069444444 0.0059171598 0.0051020408 0.0044444444 0.0039062500 [16] 0.0034602076 0.0030864198 0.0027700831 0.0025000000 0.0022675737 [21] 0.0020661157 0.0018903592 0.0017361111 0.0016000000 0.0014792899 [26] 0.0013717421 0.0012755102 0.0011890606 0.0011111111 0.0010405827 [31] 0.0009765625 0.0009182736 0.0008650519 0.0008163265 0.0007716049 [36] 0.0007304602 0.0006925208 0.0006574622 0.0006250000 0.0005948840 [41] 0.0005668934 0.0005408329 0.0005165289 0.0004938272 0.0004725898 [46] 0.0004526935 0.0004340278 0.0004164931 0.0004000000 0.0003844675 [51] 0.0003698225 0.0003559986 0.0003429355 0.0003305785 0.0003188776 [56] 0.0003077870 0.0002972652 0.0002872738 0.0002777778 0.0002687450 [61] 0.0002601457 0.0002519526 0.0002441406 0.0002366864 0.0002295684 [66] 0.0002227668 0.0002162630 0.0002100399 0.0002040816 0.0001983733 [71] 0.0001929012 0.0001876525 0.0001826150 0.0001777778 0.0001731302 [76] 0.0001686625 0.0001643655 0.0001602307 0.0001562500 0.0001524158 [81] 0.0001487210 0.0001451589 0.0001417234 0.0001384083 0.0001352082 [86] 0.0001321178 0.0001291322 0.0001262467 0.0001234568 0.0001207584 [91] 0.0001181474 0.0001156203 0.0001131734 0.0001108033 0.0001085069 [96] 0.0001062812 0.0001041233 0.0001020304 0.0001000000 0.0000980296 . sum(1 / ((1:100)**2 + 2*(1:100) +1)) . [1] 0.6350819 . 2. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (2&#51216;) . (a) &#50500;&#47000;&#50752; &#44057;&#51008; &#49688;&#50676;&#51012; &#49373;&#49457;&#54616;&#46972;. . $$x=(-10,-9.5,-9.0,...,9.0,9.5,10)$$ . (b) &#49373;&#49457;&#46108; &#49688;&#50676;&#50640; &#45824;&#54616;&#50668; &#50500;&#47000;&#47484; &#47564;&#51313;&#54616;&#45716; $y$&#47484; &#44228;&#49328;&#54616;&#46972;. . $$y= begin{cases} x &amp; |x|&gt;5 0 &amp; |x| leq 2 5 &amp; o.w. end{cases}$$ (풀이) . - 그냥 예제문제 . seq(-10,10,0.5) . [1] -10.0 -9.5 -9.0 -8.5 -8.0 -7.5 -7.0 -6.5 -6.0 -5.5 -5.0 -4.5 [13] -4.0 -3.5 -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 [25] 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 [37] 8.0 8.5 9.0 9.5 10.0 . x=seq(-10,10,0.5) . ifelse(abs(x)&gt;5,x, ifelse(abs(x)&lt;=2,0,5)) . [1] -10.0 -9.5 -9.0 -8.5 -8.0 -7.5 -7.0 -6.5 -6.0 -5.5 5.0 5.0 [13] 5.0 5.0 5.0 5.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [25] 0.0 5.0 5.0 5.0 5.0 5.0 5.0 5.5 6.0 6.5 7.0 7.5 [37] 8.0 8.5 9.0 9.5 10.0 . - 검산 . cbind(x,ifelse(abs(x)&gt;5,x, ifelse(abs(x)&lt;=2,0,5))) . x [1,] -10.0 -10.0 [2,] -9.5 -9.5 [3,] -9.0 -9.0 [4,] -8.5 -8.5 [5,] -8.0 -8.0 [6,] -7.5 -7.5 [7,] -7.0 -7.0 [8,] -6.5 -6.5 [9,] -6.0 -6.0 [10,] -5.5 -5.5 [11,] -5.0 5.0 [12,] -4.5 5.0 [13,] -4.0 5.0 [14,] -3.5 5.0 [15,] -3.0 5.0 [16,] -2.5 5.0 [17,] -2.0 0.0 [18,] -1.5 0.0 [19,] -1.0 0.0 [20,] -0.5 0.0 [21,] 0.0 0.0 [22,] 0.5 0.0 [23,] 1.0 0.0 [24,] 1.5 0.0 [25,] 2.0 0.0 [26,] 2.5 5.0 [27,] 3.0 5.0 [28,] 3.5 5.0 [29,] 4.0 5.0 [30,] 4.5 5.0 [31,] 5.0 5.0 [32,] 5.5 5.5 [33,] 6.0 6.0 [34,] 6.5 6.5 [35,] 7.0 7.0 [36,] 7.5 7.5 [37,] 8.0 8.0 [38,] 8.5 8.5 [39,] 9.0 9.0 [40,] 9.5 9.5 [41,] 10.0 10.0 . 3. $x=(-10,-9,-8, dots,8,9,10)$&#51032; &#44033; &#50896;&#49548;&#50640; &#45824;&#54616;&#50668; $h(g(f(x)))$&#51032; &#44228;&#49328;&#44208;&#44284;&#47484; &#44396;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. (10&#51216;) . 단, $f(x)$,$g(x)$, $h(x)$의 정의는 각각 아래와 같다. . $f(x)=2x+3 $ | $g(x)= frac{e^x}{1+e^x}$ | $h(x)=max(x,0)$ | . (풀이) . - 문제 의도가 좀 왜곡되었어요.. $x=(-10,-9,-8, dots, 8,9,10)$의 각 원소에 대하여! 로 바꿔야합니다. . library(tidyverse) . f = function(x) 2*x +3 g = function(x) exp(x) / (1+exp(x)) h = function(x) max(x,0) -10:10 %&gt;% f %&gt;% g %&gt;% h . [1] 1 . - 원래 의도는 이거였습니다. . f = function(x) 2*x +3 g = function(x) exp(x) / (1+exp(x)) h = function(x) ifelse(y&gt;0,y,0) -10:10 %&gt;% f %&gt;% g %&gt;% h . [1] 4.139938e-08 3.059022e-07 2.260324e-06 1.670142e-05 1.233946e-04 [6] 9.110512e-04 6.692851e-03 4.742587e-02 2.689414e-01 7.310586e-01 [11] 9.525741e-01 9.933071e-01 9.990889e-01 9.998766e-01 9.999833e-01 [16] 9.999977e-01 9.999997e-01 1.000000e+00 1.000000e+00 1.000000e+00 [21] 1.000000e+00 . 4. &#50500;&#47000;&#51473; &#50739;&#51008;&#44163;&#51008;? (O / X &#47196; &#45813;&#50504;&#51648;&#47484; &#50416;&#44256; &#45813;&#51032; &#44540;&#44144;&#44032; &#46104;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54624;&#44163;) (10&#51216;) . (a) $1= frac{1}{2}+ frac{1}{4} + frac{1}{8} dots $ . (b) $e^x= 1+x+x^2+x^3+ dots $ . (풀이) . sum=0 for (i in 1:10){ sum=sum+(1/2)**i print(sum) } . [1] 0.5 [1] 0.75 [1] 0.875 [1] 0.9375 [1] 0.96875 [1] 0.984375 [1] 0.9921875 [1] 0.9960938 [1] 0.9980469 [1] 0.9990234 . 1에 점점 가까워짐 | . 5. &#45796;&#51020;&#51012; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (10&#51216;) . 다음은 어느 회사의 연봉에 대한 규정이다. . (가) 입사 첫째 해 연봉은 $a$원이고, 입사 19년째 해까지의 연봉은 해마다 직전 연봉에서 8%씩 인상된다. . (나) 입사 20년째 해부터의 연봉은 입사 19년째 해 연봉의 75%로 한다. . 이 회사에 입사한 사람이 28년동안 근무하여 받는 연봉의 총합은? . 6. &#45796;&#51020; &#47928;&#51109;&#51012; &#51069;&#44256; &#52280;&#44144;&#51667;&#51012; &#54032;&#45800;&#54616;&#49884;&#50724;. (10&#51216;) . (a) _a&#45716; &#48320;&#49688;&#51060;&#47492;&#51004;&#47196; &#44032;&#45733;&#54616;&#45796;. . (b) &#48289;&#53552;&#51032; &#50896;&#49548;&#45716; &#49688;&#52824;&#54805;(numeric)&#47564; &#44032;&#45733;&#54616;&#45796;. . (c) &#45436;&#47532;&#54805;(logical)&#48320;&#49688;&#45716; &#49688;&#52824;&#54805; &#48320;&#49688;&#47196; &#48320;&#54872;&#54624; &#49688; &#50630;&#45796;. . (d) R&#50640;&#49436; {}&#45716; ()&#47196; &#48148;&#44992; &#49688; &#51080;&#45796;. . 7. 100&#44060;&#51032; &#46972;&#52964; (15&#51216;) . 복도에 100개의 라커가 있다. 복도를 어떤 남자가 100개의 라커 문을 전부 연다. 그리고 나서 짝수 번호의 라커를 전부 닫는다. 그 다음에는 번호가 3의 배수인 라커를 순서대로 찾아다니며 열려 있으면 닫고, 닫혀 있으면 연다. 그 다음에는 번호가 4의 배수인 라커를 순서대로 찾아다니며 열려있으면 닫고, 닫혀있으면 연다. 이후에 5의 배수, 6의 배수 .. 인 라커를 순서대로 찾아다니며 행동을 반복한다. 이런식으로 복도를 100번 지나가면 열린 라커의 문은 몇개가 되겠는가? . (풀이1) . - 문을 모두 닫은 상태로 둔다. . x= rep(FALSE, 100) . x . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [97] FALSE FALSE FALSE FALSE . - 문을 여는 함수를 만든다. (닫혀있으면 열고, 열려있으면 닫는함수) . f&lt;- function(x) !x . 10월7일강의 논리연산자 예제1 | . x %&gt;% f . [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE . 문이 잘 열린다. | . - 2,3,4,5 ... 의 배수를 찾아서 문을 열자. . Step1: 2,3,4,5의 배수에 해당하는 원소를 뽑는 코드를 작성한다. | Step2: Step1에서 나온 원소에 한정하여 문을 열거나 닫는다. | . - 2의 배수 구현예시 . (1:100) %% 2 == 0 . [1] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [13] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [25] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [37] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [49] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [61] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [73] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [85] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [97] FALSE TRUE FALSE TRUE . 짝이면 TRUE, 홀이면 FALSE 인 벡터 | . x[(1:100) %% 2 == 0 ] . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] FALSE FALSE . 1~100까지의 라커중 짝수에 해당하는 라커만 추출 | . x[(1:100) %% 2 == 0 ] %&gt;% f . [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [46] TRUE TRUE TRUE TRUE TRUE . 1~100까지의 라커중 짝수에 해당하는 라커만 추출 $ to$ 그 라커들은 문을 열었음 | . x[(1:100) %% 2 == 0 ] &lt;- x[(1:100) %% 2 == 0 ] %&gt;% f x . [1] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [13] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [25] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [37] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [49] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [61] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [73] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [85] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [97] FALSE TRUE FALSE TRUE . 결과를 저장 | . - 3의 배수 구현예시 . x[(1:100) %% 3 == 0 ] &lt;- x[(1:100) %% 3 == 0 ] %&gt;% f . - 4의 배수.. 5의 배수.. $ to$ 함수를 만들자. . g=function(x,a){ n=length(x) x[(1:n) %% a == 0 ] &lt;- x[(1:n) %% a == 0 ] %&gt;% f ## 연산 x ## 결과를 리턴 } . - 검산을 해보자. (검산을 쉽게하기 위해서 10개정도의 라커만 고려하자.) . x=rep(FALSE, 10) x . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE . x %&gt;% f . [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE . x %&gt;% f %&gt;% g(2) . [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE . x %&gt;% f %&gt;% g(2) %&gt;% g(3) . [1] TRUE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE . - 잘 되는것 같습니다. 이제 일반화해서 답을 구해보면 . x=rep(FALSE, 100) # x를 선언, FALSE의 의미는 문이 닫혀있다. x=f(x) # 1회 복도를 지나가면서 모든 문을 열어요 for (i in 2:100){ # 2회부터 100회까지 지나가면서 x=g(x,i) # (1) 2,3,4,5 ... , 100의 배수에 해당하는 문을 선택 (2) 문이 열려있으면 닫고, 닫혀있으면 열어요 } . - 결과는 아래와 같다. . x . [1] TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE [13] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [61] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [97] FALSE FALSE FALSE TRUE . sum(x) . [1] 10 . (풀이2) . x=rep(TRUE,100) for (i in 2:100) x[(1:100) %% i ==0] = !( x[(1:100) %% i ==0] ) sum(x) . [1] 10 . 시험제출용 코드입니다. 공부용은 아니에요 | 차근차근 디버깅을 하고 코드를 확인해가면서 혹시 모를 실수를 방지할 수 있는 풀이 1이 좋아요. | 코드 중간결과를 시각화해서 내가 잘 구현하고 있는지 끊임없이 확인해야 합니다. | 그 다음에 코드를 효율적으로 정리합니다. | . 8. &#47924;&#44417;&#54868; &#44867;&#51060; &#54588;&#50632;&#49845;&#45768;&#45796;. (25&#51216;) . 총 456명의 참가자가 &#39;무궁화 꽃이 피었습니다&#39; 게임에 참가한다. 기본적인 게임의 규칙은 아래와 같다. . 술래는 총 10회간 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39; 를 외친다. . | 참가자는 술래가 있는 곳 까지 이동해야 살 수 있다. . | 술래는 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39;를 외치다가 구호가 끝남과 동시에 뒤를 돌아본다. 이때 움직이는 사람은 죽는다 . | . 따라서 참가자는 술래가 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39;를 외치는 동안만 이동할 수 있다. 욕심을 부려 더 이동하고자 하면 죽을 수 있다. 반대로 죽는 것을 지나치게 두려워한 나머지 매턴마다 조금씩만 이동한다면 10회의 제한횟수 내에 술래에게 도달하지 못하여 죽는다. . 게임환경과 관련된 세부적인 설정은 아래와 같다. . 술래와 참가자의 거리는 35이다. . | 술래는 처음 벽을 보고 $x$초간 무궁화 꽃이 피었습니다를 외친다. . | 모든 참가자는 1초에 거리1이상 움직일 수 없다고 가정한다. (예를들어 2.4초 동안은 최대 2.4의 거리를 이동할 수 있다. 반면 이동을 원치않으면 0의 거리만큼 움직이므로 0~2.4사이의 거리를 움직일 수 있다) . | . 술래와 참가자에 대한 설정값은 아래와 같다. . 술래에 대한 설정값 . 처음에는 술래가 10초간 무궁화 꽃이 피었습니다를 외친다. . | 그 다음에는 술래가 9.5초간 무궁화 꽃이 피었습니다를 외친다. . | 그 다음에도 0.5초씩 구호를 외치는 시간을 줄인다. 이것을 10회 반복한다. . | . 참가자에 대한 설정값 . 처음에는 참가자가 &quot;본인의번호/100&quot;을 계산하여 나온 숫자만큼 움직인다. 즉 10번 참가자는 0.1의 거리를 움직이고 456번 참가자는 4.56의 거리를 움직인다. . | 그 다음은 처음에 본인이 이동했던 거리에 1씩 더하여 움직인다. 즉 10번 참가자는 1.1의 거리를 움직이고 456번 참가자는 5.56의 거리를 움직인다. . | . - 예시1 . 300번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 3 | 4 | 5 | 6 | 7 | 7.5 | . 참가자의 총 이동거리 | 3 | 7 | 12 | 18 | 25 | 32.5 | . 생존할 수 없다. (6회에서 32.5까지 이동후 사망) . - 예시2 . 350번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 3.5 | 4.5 | 5.5 | 6.5 | 7.5 | 7.5 | . 참가자의 총 이동거리 | 3.5 | 8 | 13.5 | 20 | 27.5 | 35 | . 생존 할 수 있다. (6회에서 정확하게 7.5초간 이동하고 살아남는다) . - 예시3 . 400번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 4 | 5 | 6 | 7 | 8 | 5 | . 참가자의 총 이동거리 | 4 | 9 | 15 | 22 | 30 | 35 | . 생존 할 수 있다. (6회에서 5초간만 이동하면 35만큼 이동하므로 살아남는다) . (a) 1&#48264;, 67&#48264;, 218&#48264;, 456&#48264; &#52280;&#44032;&#51088;&#51032; &#49373;&#51316;&#50668;&#48512;&#47484; &#54869;&#51064;&#54616;&#45716; &#54632;&#49688;&#47484; &#51089;&#49457;&#54616;&#46972;. . (b) &#51204;&#52404; &#49373;&#51316;&#51088;&#51473; &#47751;&#47749;&#51060; &#49332;&#50500;&#45224;&#45716;&#51648; &#44228;&#49328;&#54616;&#46972;. . (풀이) . - 전략: 각 플레이어별로 죽느냐 사느냐를 판단하는 로직을 구현하고 for문을 돌리면 된다. . - 죽느냐 사느냐를 판단하는 방법: 살아있는 동안 이동한 총거리 &gt;= 35 . - 살아있는 동안 이동한 총거리를 계산하는 방법: . 죽을위험이 없는 횟수에서 이동한 총거리 + 죽을위험이 있는 횟수에서 술래의 외침시간 동안 이동한 거리 | . - 죽을위험이 없는 횟수에서 이동한 총거리 . num=350 x= seq(10,5.5,by=-.5) ## 술래의 외침시간 steps = num/100 + 0:9 ## 참가자가 이동하려는 거리 . x&gt;=steps . [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE . sum(steps[x&gt;=steps]) . [1] 27.5 . - 죽을 위험이 있는 횟수에서 이동한 거리 . x[x&lt;steps][1] . [1] 7.5 . - 더하면? . sum(steps[x&gt;=steps]) + x[x&lt;steps][1] ## 총이동거리 . [1] 35 . - 총이동거리 &gt;= 35 이면 살아남을 수 있음 . sum(steps[x&gt;=steps]) + x[x&lt;steps][1] &gt;= 35 . [1] TRUE . - 정리하면 . x=seq(10,5.5,by= -0.5) surv&lt;-c() for (num in 1:456){ steps = num/100 + 0:9 surv[num] &lt;- sum(steps[x&gt;=steps]) + x[x&lt;steps][1] &gt;= 35 } sum(surv) . [1] 85 . 9. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#49884;&#44033;&#54868; &#54616;&#46972;. (15&#51216;) . 다음은 인터넷에서 어떠한 자료를 다운받아 매트릭스로 저장하는 코드이다. . df=read.csv(&quot;https://raw.githubusercontent.com/miruetoto/yechan/master/_notebooks/round2.csv&quot;) mat=as.matrix(df) . 매트릭스는 mat이라는 변수에 저장되어 있다. . df=read.csv(&quot;https://raw.githubusercontent.com/miruetoto/yechan/master/_notebooks/round2.csv&quot;) mat=as.matrix(df) . (a) mat&#51032; &#52395;&#48264;&#51704; &#50676;&#51012; $x$, &#46160;&#48264;&#51704;&#50676;&#51012; $y$&#47196; &#49373;&#44033;&#54616;&#44256; plot&#54632;&#49688;&#47484; &#53685;&#54616;&#50668; &#50500;&#47000;&#50752; &#44057;&#51008; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. . plot(mat[,1],mat[,2]) . plot(mat) . R은 알아서 해석해서 해주는 것이 좀 많아요.. | 이것은 프로그램 만든 사람이 편의성을 위해 &quot;만들어준&quot; 기능입니다. | 이러한 기능을 이용한 풀이는 좋은 풀이가 아닌데 그 이유는 프로그램을 만든 사람의 마음에 따라서 시각화가 가능하기도 하고 불가능하기도 합니다. | . (b) &#47588;&#53944;&#47533;&#49828;&#51032; &#52395;&#48264;&#51704; &#54665;(first row)&#47484; &#52636;&#47141;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . - 힌트: 출력결과는 (12,313)이 나와야 한다. . mat[1,] . x y 12 313 . (c) (b)&#51032; &#44208;&#44284;&#50640; &#50500;&#47000;&#51032; &#50672;&#49328;&#51012; &#49688;&#54665;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . $$ begin{bmatrix} 0 &amp; -1 -1 &amp; 0 end{bmatrix} begin{bmatrix} 12 313 end{bmatrix} $$ f = function(X){ dim(X)=c(2,1) X } . rbind(c(0,-1),c(-1,0)) %*% f(mat[1,]) . [,1] [1,] -313 [2,] -12 . (d) (b)-(c) &#44284;&#51221;&#51012; mat&#51032; &#47784;&#46304;&#54665;&#50640; &#48152;&#48373;&#54616;&#50668; &#49352;&#47196;&#50868; &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46308;&#50612;&#46972;. . - 힌트: 아래의 과정을 따른다. . (i) mat와 동일한 dim을 가진 mat2를 만든다. | (ii) mat의 첫번째 행에 (b)-(c)의 과정을 적용하여 길이가 2인 벡터를 얻는다. | (iii) (ii)의 과정에서 얻은 벡터를 새로운 매트릭스의 첫번째 행에 넣는다. | (iv) mat의 두번째 행에 대하여 (ii)-(iii)의 과정을 반복한다. 이후 세번째, 네번째 행에 대하여 (ii)-(iii)의 과정을 반복한다. | . g = function(X){ dim(X)=c(1,2) X } . dim(mat2) . [1] 5513 2 . mat2 = mat*0 for (i in 1:5513) mat2[i,] = rbind(c(0,-1),c(-1,0)) %*% f(mat[i,]) %&gt;% g . (e) (d)&#51032; &#44208;&#44284;&#47196; &#49373;&#49457;&#46104; &#47588;&#53944;&#47533;&#49828;&#51032; &#52395;&#48264;&#51704; &#50676;&#51012; x, &#46160;&#48264;&#51704; &#50676;&#51012; y&#47196; &#54616;&#44256; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. (&#51216;&#51032; &#49353;&#51008; &#48521;&#51008;&#49353;&#51004;&#47196; &#54616;&#46972;) . - 힌트: 아래와 같은 그림이 나와야 한다. . plot(mat2[,1],mat2[,2],col=&#39;red&#39;) . (풀이) . - 사실 아래는 같음 . rbind(c(0,-1),c(-1,0)) %*% c(12,312) ## c(12,313) 벡터 . [,1] [1,] -312 [2,] -12 . rbind(c(0,-1),c(-1,0)) %*% matrix(c(12,312),nrow=2) . [,1] [1,] -312 [2,] -12 . - 그리고 아래도 같음 . c(12,313) %*% rbind(c(0,-1),c(-1,0)) . [,1] [,2] [1,] -313 -12 . matrix(c(12,313),nrow=1) %*% rbind(c(0,-1),c(-1,0)) . [,1] [,2] [1,] -313 -12 . - c(12,313)이 때로는 벡터로, 때로는 $n times 1$인 매트릭스로 생각할 수 있고, 때로는 $1 times n$ 매트릭스로 해석할 수도 있음. . - 따라서 아래와 같이 풀어도 가능함. . mat2 = mat*0 for (i in 1:5513) mat2[i,] = rbind(c(0,-1),c(-1,0)) %*% mat[i,] . plot(mat2,col=&#39;red&#39;) . (풀이3) . - 매트릭스의 곱셈을 잘 이해했다면? . head(mat) . x y [1,] 12 313 [2,] 12 314 [3,] 13 279 [4,] 13 311 [5,] 13 312 [6,] 13 313 . rbind(c(0,-1),c(-1,0)) %*% c(12,313) . [,1] [1,] -313 [2,] -12 . rbind(c(0,-1),c(-1,0)) %*% c(12,314) . [,1] [1,] -314 [2,] -12 . cbind(c(12,313),c(12,314)) . [,1] [,2] [1,] 12 12 [2,] 313 314 . rbind(c(0,-1),c(-1,0)) %*% cbind(c(12,313),c(12,314)) . [,1] [,2] [1,] -313 -314 [2,] -12 -12 . - 응용하면 . rbind(c(0,-1),c(-1,0)) %*% t(mat) %&gt;% t %&gt;% plot(col=&#39;red&#39;) . - 매트릭스 A,B의 곱에서 뒷부분을 임의의 칼럼으로 쪼개서 각각 연산한뒤 합쳐도 성립한다. . - 매트릭스 A,B의 곱에서 앞부분을 임의의 로우로 쪼개서 각각 연산한뒤 합쳐도 성립한다. .",
            "url": "https://guebin.github.io/IR2021/2021/11/11/2021%EB%85%84-2%ED%95%99%EA%B8%B0-R%EC%9E%85%EB%AC%B8%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%ED%92%80%EC%9D%B4.html",
            "relUrl": "/2021/11/11/2021%EB%85%84-2%ED%95%99%EA%B8%B0-R%EC%9E%85%EB%AC%B8%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%ED%92%80%EC%9D%B4.html",
            "date": " • Nov 11, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "(8주차) 11월2일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) 중간고사 대비 설명 (1) . - (2/4) 중간고사 대비 설명 (2) . - (3/4) 백터/매트릭스의 결합 . - (4/4) 매트릭스 원소선택, 벡터관련 연산, 매트릭스 관련연산, 티블(데이터프레임) . %&gt;% . - tidyverse중 하나의 dplyr의 기능 . library(dplyr) . - 예시1 . f&lt;-function(x) x+2 . f(2) . [1] 4 . 2 %&gt;% f . [1] 4 . - 예시2 . f&lt;-function(x,y) x**2+y . f(2,3) . [1] 7 . 2 %&gt;% f(3) . [1] 7 . 3 %&gt;% f(2) . [1] 11 . - 포인트: 함수의 첫번째 입력이 %&gt;% 의 왼쪽의 결과로 생각한다. . 하나의 입력만 받는 함수라면 함수이름만 쓸 수 있다! | 첫입력을 생략한다는 것이 포인트! | . &#46160; &#44060; &#51060;&#49345;&#51032; &#48289;&#53552;, &#54665;&#47148;&#51012; &#44208;&#54633; . &#48289;&#53552;&#51032; &#44208;&#54633; . - 예제1 . x&lt;-c(1,2,3) y&lt;-c(1,2,3,4) . x . [1] 1 2 3 . y . [1] 1 2 3 4 . c(x,y) . [1] 1 2 3 1 2 3 4 . c(y,x) . [1] 1 2 3 4 1 2 3 . c(x,2,2,2,y) . [1] 1 2 3 2 2 2 1 2 3 4 . c는 사실 결합하라라는 의미를 가짐 | . - 예제2 . x&lt;-c(1,2,3) y&lt;-c(4,4,4) . cbind(x,y) . x y [1,] 1 4 [2,] 2 4 [3,] 3 4 . - 예제2-1 . x&lt;-c(1,2,3,4) y&lt;-c(1,2) cbind(x,y) . x y [1,] 1 1 [2,] 2 2 [3,] 3 1 [4,] 4 2 . - 예제2-2 . x&lt;-c(1,2,3,4) cbind(1,x) . x [1,] 1 1 [2,] 1 2 [3,] 1 3 [4,] 1 4 . - 예제3 . x&lt;-c(1,2,3,4) y&lt;-c(1,2) rbind(x,y) . [,1] [,2] [,3] [,4] x 1 2 3 4 y 1 2 1 2 . - 예제4 . x&lt;-c(1,2,3) y&lt;-c(4,5) . cbind(1,c(x,y)) . [,1] [,2] [1,] 1 1 [2,] 1 2 [3,] 1 3 [4,] 1 4 [5,] 1 5 . &#47588;&#53944;&#47533;&#49828;&#51032; &#44208;&#54633; . - 예제1 . X&lt;-rbind(1:5,6:10) y&lt;-c(1,2) . X . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 . y . [1] 1 2 . cbind(X,y,y,X) . y y [1,] 1 2 3 4 5 1 1 1 2 3 4 5 [2,] 6 7 8 9 10 2 2 6 7 8 9 10 . * 이름을 지우기 위해서는 아래와 같이 하면 된다. . XyyX= cbind(X,y,y,X) colnames(XyyX)= NULL XyyX . [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [1,] 1 2 3 4 5 1 1 1 2 3 4 5 [2,] 6 7 8 9 10 2 2 6 7 8 9 10 . - 예제2 . X&lt;-rbind(1:5,6:10) rbind(X,1) . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 [3,] 1 1 1 1 1 . - 예제3 . X &lt;- rbind(1:5,6:10,1:5) Y &lt;- cbind(1:3,4:6,7:9) . X . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 [3,] 1 2 3 4 5 . Y . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . cbind(X,Y) . [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [1,] 1 2 3 4 5 1 4 7 [2,] 6 7 8 9 10 2 5 8 [3,] 1 2 3 4 5 3 6 9 . rbind(X,Y) . Error in rbind(X, Y): number of columns of matrices must match (see arg 2) Traceback: 1. rbind(X, Y) . 드디어 에러!! | . &#47588;&#53944;&#47533;&#49828; &#50896;&#49548; &#49440;&#53469; . X&lt;-rbind(1:5,6:10,1:5) X . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 [3,] 1 2 3 4 5 . - 예제1 . X[,1] . [1] 1 6 1 . 선택된 것은 자동으로 벡터화 된다. | . x=X[,1] . x . [1] 1 6 1 . dim(x) . NULL . dim(x)&lt;-c(3,1) . x . [,1] [1,] 1 [2,] 6 [3,] 1 . - 예제2 . X[,1:2] . [,1] [,2] [1,] 1 2 [2,] 6 7 [3,] 1 2 . - 예제3 . X[,-1] . [,1] [,2] [,3] [,4] [1,] 2 3 4 5 [2,] 7 8 9 10 [3,] 2 3 4 5 . - 예제4 . X[,-(1:2)] . [,1] [,2] [,3] [1,] 3 4 5 [2,] 8 9 10 [3,] 3 4 5 . - 예제5 . X[1:2,] . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 . - 예제6 . X[1:2,1:3] . [,1] [,2] [,3] [1,] 1 2 3 [2,] 6 7 8 . - 예제7 . X[1:2, -1] . [,1] [,2] [,3] [,4] [1,] 2 3 4 5 [2,] 7 8 9 10 . &#48289;&#53552;&#44288;&#47144; &#50672;&#49328; . - 예제1 . c(1,2,5) %in% c(1,2,3,4) . [1] TRUE TRUE FALSE . - 예제2 . union(c(1,1,2,2),c(2,3,4)) . [1] 1 2 3 4 . - 예제3 . intersect(1:5,2:6) . [1] 2 3 4 5 . - 예제4 . x=1:5 . x %*% x . [,1] [1,] 55 . - 예제5 . x=1:5 . x %o% x . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 2 4 6 8 10 [3,] 3 6 9 12 15 [4,] 4 8 12 16 20 [5,] 5 10 15 20 25 . &#47588;&#53944;&#47533;&#49828; &#44288;&#47144;&#50672;&#49328; . - 예제1: 트랜스포즈 . A=cbind(c(1,2,3),c(4,5,6),c(7,8,9)) . A . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . t(A) . [,1] [,2] [,3] [1,] 1 2 3 [2,] 4 5 6 [3,] 7 8 9 . - 예제2: 상수 곱하기 . A=cbind(c(1,2,3),c(4,5,6),c(7,8,9)) A . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . -A . [,1] [,2] [,3] [1,] -1 -4 -7 [2,] -2 -5 -8 [3,] -3 -6 -9 . A*2 . [,1] [,2] [,3] [1,] 2 8 14 [2,] 4 10 16 [3,] 6 12 18 . - 예제3: 덧셈, 뺄셈 . A=cbind(c(1,2,3),c(4,5,6),c(7,8,9)) B=cbind(1:3,1:3,2:4) . A . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . B . [,1] [,2] [,3] [1,] 1 1 2 [2,] 2 2 3 [3,] 3 3 4 . A+B . [,1] [,2] [,3] [1,] 2 5 9 [2,] 4 7 11 [3,] 6 9 13 . - 예제4: 행렬곱셈 . A=cbind(1:2,2:3) A . [,1] [,2] [1,] 1 2 [2,] 2 3 . A %*% A . [,1] [,2] [1,] 5 8 [2,] 8 13 . - 예제5: 역행렬 . A=rbind(c(0,1),c(2,0)) A . [,1] [,2] [1,] 0 1 [2,] 2 0 . solve(A) . [,1] [,2] [1,] 0 0.5 [2,] 1 0.0 . A %*% solve(A) . [,1] [,2] [1,] 1 0 [2,] 0 1 . &#54000;&#48660; &#47564;&#46300;&#45716; &#48169;&#48277; . - 보통 초보단계에서는 일부러 만들기보다 만들어져 있는 경우가 많아요 . - 벡터로 만들기 . x&lt;-c(1,2,3) y&lt;-c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) . tb=tibble(x=x,y=y) . tb . x y 1 1 a 2 2 b 3 3 c . tb$x . [1] 1 2 3 . tb$y . [1] &#34;a&#34; &#34;b&#34; &#34;c&#34; . - 매트릭스로 만들기 . X=cbind(1:10,31:40) X . [,1] [,2] [1,] 1 31 [2,] 2 32 [3,] 3 33 [4,] 4 34 [5,] 5 35 [6,] 6 36 [7,] 7 37 [8,] 8 38 [9,] 9 39 [10,] 10 40 . tb=as_tibble(X) . tb . V1 V2 1 1 31 2 2 32 3 3 33 4 4 34 5 5 35 6 6 36 7 7 37 8 8 38 9 9 39 10 10 40 . &#54000;&#48660;&#51012; &#50416;&#45716; &#51060;&#50976;? . mutate . tb %&gt;% mutate(V3=V1**2+V2,V4=-V3, V5=V4-1) . V1 V2 V3 V4 V5 1 1 31 32 -32 -33 2 2 32 36 -36 -37 3 3 33 42 -42 -43 4 4 34 50 -50 -51 5 5 35 60 -60 -61 6 6 36 72 -72 -73 7 7 37 86 -86 -87 8 8 38 102 -102 -103 9 9 39 120 -120 -121 10 10 40 140 -140 -141 . 열간의 결합으로 새로운 열을 만들기 편리함 | . tb . V1 V2 1 1 31 2 2 32 3 3 33 4 4 34 5 5 35 6 6 36 7 7 37 8 8 38 9 9 39 10 10 40 . 연산을 해도 원래 데이터 프레임은 변화하지 않음. 변화를 위해서는 아래를 해야함. | . tb &lt;- tb %&gt;% mutate(V3=V1**2+V2,V4=-V3, V5=V4-1) . - 아래와 같은코드임 . mutate(tb, V3=V1**2+V2,V4=-V3, V5=V4-1) . V1 V2 V3 V4 V5 1 1 31 32 -32 -33 2 2 32 36 -36 -37 3 3 33 42 -42 -43 4 4 34 50 -50 -51 5 5 35 60 -60 -61 6 6 36 72 -72 -73 7 7 37 86 -86 -87 8 8 38 102 -102 -103 9 9 39 120 -120 -121 10 10 40 140 -140 -141 . filter . tb2 &lt;- tb %&gt;% mutate(V3=V1**2+V2,V4=-V3, V5=V4-1) . tb2 . V1 V2 V3 V4 V5 1 1 31 32 -32 -33 2 2 32 36 -36 -37 3 3 33 42 -42 -43 4 4 34 50 -50 -51 5 5 35 60 -60 -61 6 6 36 72 -72 -73 7 7 37 86 -86 -87 8 8 38 102 -102 -103 9 9 39 120 -120 -121 10 10 40 140 -140 -141 . tb2 %&gt;% filter(V1&gt;5, V3&lt;100) . V1 V2 V3 V4 V5 1 6 36 72 -72 -73 2 7 37 86 -86 -87 . mutate + filter &#44032;&#45733; . tb . V1 V2 1 1 31 2 2 32 3 3 33 4 4 34 5 5 35 6 6 36 7 7 37 8 8 38 9 9 39 10 10 40 . tb %&gt;% mutate(V3=(V1-mean(V1))/sd(V1)) . V1 V2 V3 1 1 31 -1.4863011 2 2 32 -1.1560120 3 3 33 -0.8257228 4 4 34 -0.4954337 5 5 35 -0.1651446 6 6 36 0.1651446 7 7 37 0.4954337 8 8 38 0.8257228 9 9 39 1.1560120 10 10 40 1.4863011 . tb %&gt;% mutate(V3=(V1-mean(V1))/sd(V1)) %&gt;% filter(V3&gt;0.5) . V1 V2 V3 1 8 38 0.8257228 2 9 39 1.1560120 3 10 40 1.4863011 .",
            "url": "https://guebin.github.io/IR2021/2021/11/02/(8%EC%A3%BC%EC%B0%A8)-11%EC%9B%942%EC%9D%BC.html",
            "relUrl": "/2021/11/02/(8%EC%A3%BC%EC%B0%A8)-11%EC%9B%942%EC%9D%BC.html",
            "date": " • Nov 2, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "(5주차) 10월7일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) while, break, ifelse . - (2/4) switch, reapeat, next . - (3/4) 산술연산자, 논리연산자 . - (4/4) 비교연산자, 과제설명 . &#51312;&#44148;, &#48152;&#48373;, &#47336;&#54532;&#53448;&#52636; . while . - 예제1 . tot = 0 i = 1 while(i&lt;=100){ tot=tot+i i = i+1 } . tot . [1] 5050 . - 예제1의 다른구현(1) . tot=0 for (i in 1:100) tot = tot +i . tot . [1] 5050 . - 예제1의 다른구현(2) . tot = 0 i = 1 while(TRUE){ tot = tot+i i=i+1 if (i&gt;100) break } . tot . [1] 5050 . - 예제1의 다른구현(3) . tot = 0 i = 1 while(TRUE){ tot = tot+i if (i&gt;=100) break i=i+1 } . tot . [1] 5050 . - 저는 while을 싫어합니다. . - 어쩔수 없이 써야할때가 있어서 알고있는 것입니다. . break . - 예제1 . for (i in 1:10){ print(i) if(i==3) break } . [1] 1 [1] 2 [1] 3 . - 예제2 . for (i in 1:10){ for (j in 1:10){ print(c(i,j)) if(j==3) break } if(i==5) break } . [1] 1 1 [1] 1 2 [1] 1 3 [1] 2 1 [1] 2 2 [1] 2 3 [1] 3 1 [1] 3 2 [1] 3 3 [1] 4 1 [1] 4 2 [1] 4 3 [1] 5 1 [1] 5 2 [1] 5 3 . ifelse . - 예제1 . x= -2:2 x . [1] -2 -1 0 1 2 . ifelse(x&gt;0,x,-x) . [1] 2 1 0 1 2 . - 예제1의 다른구현 . length(x) . [1] 5 . y_ = x*0 y_ . [1] 0 0 0 0 0 . for (i in 1:length(x)){ if (x[i]&gt;0) y_[i] = x[i] else y_[i] = -x[i] } . y_ . [1] 2 1 0 1 2 . - 예제2 . x= -5:5 x . [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 . y=ifelse(x&lt;0, 0, ifelse(x&gt;2,x,1)) . y . [1] 0 0 0 0 0 1 1 1 3 4 5 . plot(x,x) points(x,y,col=2,pch=16) . - 예제2의 다른구현 . x= -5:5 x . [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 . y=x*0 y . [1] 0 0 0 0 0 0 0 0 0 0 0 . n=length(x) n . [1] 11 . for(i in 1:n){ if(x[i]&lt;0) y[i]=0 else if (x[i]&gt;2) y[i]=x[i] else y[i]=1 } . y . [1] 0 0 0 0 0 1 1 1 3 4 5 . - ifelse와 if~else는 성격이 조금 다름 . ifelse: 조건에 부합하는 새로운 벡터를 생성하는데 특화되어있음 | if~else: 조건에 따라 코드의 실행흐름을 제어하는 성격의 문법 | . switch . - 예제1 . switch(1, 10,20,30) . [1] 10 . switch(2, 10,20,30) . [1] 20 . switch(3, 10,20,30) . [1] 30 . - 예제2 . switch(1, c(1,2,3),20,c(30,40)) . [1] 1 2 3 . switch(2, c(1,2,3),20,c(30,40)) . [1] 20 . switch(3, c(1,2,3),20,c(30,40)) . [1] 30 40 . - 예제3 . switch(&#39;a1&#39;, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 1 2 3 . switch(&#39;a2&#39;, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 20 . switch(&#39;a3&#39;, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 30 40 . - 예제4 . (예비학습) . x=1:10 x . [1] 1 2 3 4 5 6 7 8 9 10 . c( mean(x), mean(x**2), mean((x-mean(x))**2) ) . [1] 5.50 38.50 8.25 . 38.50 - 5.50**2 . [1] 8.25 . (예제시작) . switch(&quot;f1&quot;, f1=mean(x), f2=mean(x**2), f3=mean((x-mean(x))**2) ) . [1] 5.5 . switch(&quot;f2&quot;, f1=mean(x), f2=mean(x**2), f3=mean((x-mean(x))**2) ) . [1] 38.5 . switch(&quot;f3&quot;, f1=mean(x), f2=mean(x**2), f3=mean((x-mean(x))**2) ) . [1] 8.25 . - 예제5 . myfun&lt;-function(x,f){ switch(f, meann=mean(x), sqmeann=mean(x**2), varr=mean((x-mean(x))**2) ) } . x=1:5 myfun(x,&quot;meann&quot;) myfun(x,&quot;sqmeann&quot;) myfun(x,&quot;varr&quot;) . [1] 3 . [1] 11 . [1] 2 . repeat . - 예제1 . tot=0 i=1 repeat{ tot=tot+i i=i+1 if (i&gt;100) break } . tot . [1] 5050 . - 잘못된 예제1 . tot=0 i=1 repeat{ tot=tot+i i=i+1 } . next . - 예제1 . for(i in 1:5){ if(i==3) next else print(i) } . [1] 1 [1] 2 [1] 4 [1] 5 . break와 비교 . for(i in 1:5){ if(i==3) break else print(i) } . [1] 1 [1] 2 . - 예제2 . i=0 repeat{ i=i+1 if (i&gt;5) break if (i==3) next print(i) } . [1] 1 [1] 2 [1] 4 [1] 5 . &#50836;&#50557; . - 조건: if, if~else / ifelse, switch . - 반복: for, while, repeat . - 루프탈출: break, next . &#50672;&#49328;&#51088; . &#49328;&#49696;&#50672;&#49328;&#51088; . - 예제1 . 5+2 . [1] 7 . 6-2 . [1] 4 . 3*4 . [1] 12 . 6/5 . [1] 1.2 . - 예제2 . 2^3 . [1] 8 . 2**3 . [1] 8 . - 예제3 . 31%%3 . [1] 1 . 31%/%3 . [1] 10 . &#45436;&#47532;&#50672;&#49328;&#51088; . - 예제1 . x=c(T,T,F,F,T) y=c(TRUE,FALSE,TRUE,FALSE,TRUE) . x . [1] TRUE TRUE FALSE FALSE TRUE . y . [1] TRUE FALSE TRUE FALSE TRUE . print(x) print(!x) . [1] TRUE TRUE FALSE FALSE TRUE [1] FALSE FALSE TRUE TRUE FALSE . print(y) print(!y) . [1] TRUE FALSE TRUE FALSE TRUE [1] FALSE TRUE FALSE TRUE FALSE . . Note: TRUE, FALSE 로 구성된 열을 잘 다루면 인덱싱에 유리하다. . - 예제2: 예제1의 응용 . x=1:30 x . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 . x%%3 . [1] 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 . x[x%%3==0] # 3의 배수인것만 출력 . [1] 3 6 9 12 15 18 21 24 27 30 . x[!(x%%3==0)] # 3의 배수가 아닌것만 출력 . [1] 1 2 4 5 7 8 10 11 13 14 16 17 19 20 22 23 25 26 28 29 . - 예제2의 다른구현 (논리연산자와 TRUE/FALSE 로 이루어진 열을 다루는데 익숙하지 않다면 고생스러울 때가 있음) . x&lt;-c() j=1 for (i in 1:30){ if (i%%3 == 0) { x[j]= i j=j+1 } } . x . [1] 3 6 9 12 15 18 21 24 27 30 . x&lt;-c() j=1 for (i in 1:30){ if (i%%3 != 0) { x[j]= i j=j+1 } } . x . [1] 1 2 4 5 7 8 10 11 13 14 16 17 19 20 22 23 25 26 28 29 . - 예제3 . x=c(T,T,F,F,T) y=c(T,F,T,F,T) . print(x) print(y) print(x&amp;y) ## and 연산자, 하나라도 FALSE이면 FALSE . [1] TRUE TRUE FALSE FALSE TRUE [1] TRUE FALSE TRUE FALSE TRUE [1] TRUE FALSE FALSE FALSE TRUE . - 예제4: 예제3의 응용 . x=1:50 . x[(x&gt;30) &amp; (x%%3==0)] # 30보다크고, 3의 배수인것들 . [1] 33 36 39 42 45 48 . x[(x&gt;30) &amp; !(x%%3==0)] . [1] 31 32 34 35 37 38 40 41 43 44 46 47 49 50 . - 예제5 . x=c(T,T,F,F,T) y=c(T,F,T,F,T) . print(x) print(y) print(x|y) ## or 연산자, 하나라도 TRUE이면 TRUE . [1] TRUE TRUE FALSE FALSE TRUE [1] TRUE FALSE TRUE FALSE TRUE [1] TRUE TRUE TRUE FALSE TRUE . - 예제6: 예제5를 응용 . x=1:50 x . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 . x&gt;30 | x&lt;10 . [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE [37] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [49] TRUE TRUE . x[x&gt;30 | x&lt;10] . [1] 1 2 3 4 5 6 7 8 9 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 [26] 47 48 49 50 . - 예제7 . x=c(T,F,T,T,F) y=c(F,T,F,F,T) . print(x) print(y) print(x&amp;&amp;y) . [1] TRUE FALSE TRUE TRUE FALSE [1] FALSE TRUE FALSE FALSE TRUE [1] FALSE . x&amp;&amp;y 와 (x&amp;y)[1]는 거의 같음 | . - 예제8 . x=c(T,F,T,T,F) y=c(F,T,F,F,T) . print(x) print(y) print(x||y) . [1] TRUE FALSE TRUE TRUE FALSE [1] FALSE TRUE FALSE FALSE TRUE [1] TRUE . x||y 와 (x|y)[1]는 거의 같음 | . &#48708;&#44368;&#50672;&#49328;&#51088; . - 예제1 . x=c(1,2,3,4,5) y=c(2,2,3,2,1) . x==y . [1] FALSE TRUE TRUE FALSE FALSE . x!=y . [1] TRUE FALSE FALSE TRUE TRUE . !(x==y) . [1] TRUE FALSE FALSE TRUE TRUE . - 예제1의 잘못된 적용 (1) . x=c(1,2,3,4,5) y=c(2,2,3,2,1) . x=y . x . [1] 2 2 3 2 1 . - 예제1의 잘못된 적용 (2) . x=c(1,2,3,4,5) y=c(2,2,3,2,1) . x=!y . x . [1] FALSE FALSE FALSE FALSE FALSE . ???? 왜 이런결과가? | . (잘못된 결과의 분석) . !y . [1] FALSE FALSE FALSE FALSE FALSE . !c(1,1,0,0) . [1] FALSE FALSE TRUE TRUE . !c(2,2,0,0) . [1] FALSE FALSE TRUE TRUE . - 예제2 . x=c(1,2,3,4,5) y=c(2,2,3,2,1) . x&gt;y . [1] FALSE FALSE FALSE TRUE TRUE . x&lt;y . [1] TRUE FALSE FALSE FALSE FALSE . x&gt;=y . [1] FALSE TRUE TRUE TRUE TRUE . x&lt;=y . [1] TRUE TRUE TRUE FALSE FALSE . - 예제2의 잘못된 사용 . x=&gt;y . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:3: unexpected &#39;&gt;&#39; 1: x=&gt; ^ Traceback: . x=&lt;y . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:3: unexpected &#39;&lt;&#39; 1: x=&lt; ^ Traceback: . &#49689;&#51228; . x= -100:100/10 . x . [1] -10.0 -9.9 -9.8 -9.7 -9.6 -9.5 -9.4 -9.3 -9.2 -9.1 -9.0 -8.9 [13] -8.8 -8.7 -8.6 -8.5 -8.4 -8.3 -8.2 -8.1 -8.0 -7.9 -7.8 -7.7 [25] -7.6 -7.5 -7.4 -7.3 -7.2 -7.1 -7.0 -6.9 -6.8 -6.7 -6.6 -6.5 [37] -6.4 -6.3 -6.2 -6.1 -6.0 -5.9 -5.8 -5.7 -5.6 -5.5 -5.4 -5.3 [49] -5.2 -5.1 -5.0 -4.9 -4.8 -4.7 -4.6 -4.5 -4.4 -4.3 -4.2 -4.1 [61] -4.0 -3.9 -3.8 -3.7 -3.6 -3.5 -3.4 -3.3 -3.2 -3.1 -3.0 -2.9 [73] -2.8 -2.7 -2.6 -2.5 -2.4 -2.3 -2.2 -2.1 -2.0 -1.9 -1.8 -1.7 [85] -1.6 -1.5 -1.4 -1.3 -1.2 -1.1 -1.0 -0.9 -0.8 -0.7 -0.6 -0.5 [97] -0.4 -0.3 -0.2 -0.1 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 [109] 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 [121] 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3.0 3.1 [133] 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 4.0 4.1 4.2 4.3 [145] 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 5.5 [157] 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 [169] 6.8 6.9 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 [181] 8.0 8.1 8.2 8.3 8.4 8.5 8.6 8.7 8.8 8.9 9.0 9.1 [193] 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0 . 아래와 같은 $y$를 생성하라. . $y= begin{cases} x &amp; |x|&gt;5 0 &amp; |x| leq 2 5 &amp; o.w. end{cases}$ . 힌트: ifelse를 중첩, abs()함수를 이용 . ifelse(abs(x)&gt;5,x,ifelse(abs(x)&lt;=2,0,5)) . [1] -10.0 -9.9 -9.8 -9.7 -9.6 -9.5 -9.4 -9.3 -9.2 -9.1 -9.0 -8.9 [13] -8.8 -8.7 -8.6 -8.5 -8.4 -8.3 -8.2 -8.1 -8.0 -7.9 -7.8 -7.7 [25] -7.6 -7.5 -7.4 -7.3 -7.2 -7.1 -7.0 -6.9 -6.8 -6.7 -6.6 -6.5 [37] -6.4 -6.3 -6.2 -6.1 -6.0 -5.9 -5.8 -5.7 -5.6 -5.5 -5.4 -5.3 [49] -5.2 -5.1 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 [61] 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 [73] 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 0.0 0.0 0.0 0.0 [85] 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [97] 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [109] 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [121] 0.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 [133] 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 [145] 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.1 5.2 5.3 5.4 5.5 [157] 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 [169] 6.8 6.9 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 [181] 8.0 8.1 8.2 8.3 8.4 8.5 8.6 8.7 8.8 8.9 9.0 9.1 [193] 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0 .",
            "url": "https://guebin.github.io/IR2021/2021/10/07/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%947%EC%9D%BC.html",
            "relUrl": "/2021/10/07/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%947%EC%9D%BC.html",
            "date": " • Oct 7, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "(4주차) 10월5일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/3) 2007년(나) 9월/평가원 16(고3) 풀이 (1) . - (2/3) 2007년(나) 9월/평가원 16(고3) 풀이 (2) . - (3/3) 2007년(나) 9월/평가원 16(고3) 풀이 (3), for+break, while, 과제설명 . 2007(&#45208;) 9&#50900;/&#54217;&#44032;&#50896; 16(&#44256;3) . 자연수 $n$에 대하여 점 $P_n$을 다음 규칙에 따라 정한다. . (가) 점 $P_1$의 좌표는 $(1,1)$이다. . (나) 점 $P_n$의 좌표가 $(a,b)$일때, . $b&lt;2^a$이면 점 $P_{n+1}$의 좌표는 $(a,b+1)$이고 | $b=2^a$이면 점 $P_{n+1}$의 좌표는 $(a+1,1)$이다. | . 점 $P_n$의 좌표가 $(10,2^{10})$일 때, $n$의 값은? . (1) $2^{10}-2$ . (2) $2^{10}+2$ . (3) $2^{11}-2$ . (4) $2^{11}$ . (5) $2^{11}+2$ . (풀이전략) . - $P_1$로부터 $P_2$를 구한다. . - $P_2=(10,2^{10})$인지 체크 . 맞다면 $n=2$ | 아니라면 아래를 진행 | . - $P_2$에서 $P_3$을 구한다. . - $P_3=(10,2^{10})$인지 체크 . 맞다면 n=3 | 아니라면 아래를 진행 | . - ... . 그래서 아래와 같은 로직이면 좋겠다. . - for $n=1,2, dots, 2^{11}+2$까지 아래를 반복함 (단, $P_n=(10,2^{10})$인 경우에는 반복중지) . if Pn==(10,2^(10)) 인 경우: 반복문 탈출 else 반복할내용 . (풀이) . a=c() b=c() a[1]=1 b[1]=1 for(n in 1:2^12){ if ((a[n]==10)&amp;(b[n]==2^10)){ print(n) break }else{ ## 탈출못했을때 실행되는 코드 (실질적인 문제풀이 if(b[n]&lt;2^(a[n])){ a[n+1]=a[n] b[n+1]=b[n]+1 }else{ if(b[n]==2^(a[n])){ a[n+1]=a[n]+1 b[n+1]=1 } } } } . [1] 2046 . c(2^10-2 , 2^10+2 , 2^11-2 , 2^11 , 2^11+2) . [1] 1022 1026 2046 2048 2050 . 답은 3번 . &#48152;&#48373;&#47928;&#51012; &#51201;&#45817;&#54620; &#51312;&#44148;&#54616;&#50640;&#47564; &#49688;&#54665;&#54616;&#45716; &#48169;&#48277; . (1) 방법1: for + break 를 적절하게 활용 . (2) 방법2: while 을 이용 . x= -5 while(x&lt;0){ print(&#39;x는음수&#39;) x= x+1 } . [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; . &#49689;&#51228; . - for + break를 활용하여 위와 같은 결과가 나오도록 코드를 작성하라. . for (x in -5:10){ if (????){ break }else{ print(&#39;x는음수&#39;) #x=x+1 } } . [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; .",
            "url": "https://guebin.github.io/IR2021/2021/10/05/(4%EC%A3%BC%EC%B0%A8)-10%EC%9B%945%EC%9D%BC.html",
            "relUrl": "/2021/10/05/(4%EC%A3%BC%EC%B0%A8)-10%EC%9B%945%EC%9D%BC.html",
            "date": " • Oct 5, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "(3주차) 9월16일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/2): 2010(나) 6월/평가원 4 (고3) . - (2/2): 2021(가) 9월/평가원 10 (고3), for문 . - 추가영상: 주피터랩, Rstudio . 2010(&#45208;) 6&#50900;/&#54217;&#44032;&#50896; 4 (&#44256;3) . (문제) 실수 $a$가 $ frac{2^a+2^{-a}}{2^{a}-2^{-a}}=-2$를 만족시킬때, $4^a+4^{-a}$의 값은? . (보기) (1) $ frac{5}{2}$ (2) $ frac{10}{3}$ (3) $ frac{17}{4}$ (4) $ frac{26}{5}$ (5) $ frac{37}{6}$ . (풀이) . - 먼저 $ frac{2^{a}+2^{-a}}{2^a-2^{-a}}=-2$를 만족하는 $a$를 찾아보자. . - $f(a)= frac{2^{a}+2^{-a}}{2^a-2^{-a}}$라고 두고 $f(a)=-2$를 만족하는 $a$를 찾으면 된다. . - 함수를 선언하자. . ### 이렇게 한다고 함수가 선언되지는 않는다. f(a) = (2^a + 2^(-a)) / (2^(a)-2^(-a)) . f&lt;-function(a){ (2^a + 2^(-a)) / (2^(a)-2^(-a)) } . - 잘 선언되었는지 확인: $a=1$을 넣으면 $f(a)= frac{2+0.5}{2-0.5}= frac{2.5}{1.5}$ . print(f(1)) print(2.5/1.5) . [1] 1.666667 [1] 1.666667 . 잘 선언된 것 같다. | . - $f(a)$의 그래프를 그리고 $f(a)=-2$에 해당하는 수평선을 그려서 대략적으로 값을 유추하여 보자. . a=seq(from=-5,to=5,by=0.1) . plot(a,f(a)) abline(h=-2,col=&#39;red&#39;) . - 우선 $-2 &lt; a&lt; 0$ 인 것 같다. 범위를 좁히고, by옵션을 사용하여 더 촘촘히 다시 그려보자. . a = seq(from=-2, to=0, by=0.0001) . plot(a,f(a)) abline(h=-2,col=&#39;red&#39;) . ?? | 함수모양을 보니 $a=0$이면 $f(a)$의 분모가 0이 되어서 정의되지 않음. | . - 범위를 $-2 &lt; a&lt; -0.1$ 로 수정해보자. . a = seq(from=-2, to=-0.1, by=0.0001) plot(a,f(a),type=&#39;l&#39;,lwd=4) abline(h=-2,col=2,lty=2,lwd=4) . col: 칼라조정 (2=빨강, &#39;red&#39;=빨강 // 4=파랑, &#39;blue&#39;=파랑) | lty: 점선의 type조정 | lwd: 선의 두께 조정 | . - 이제 해를 찾아보자. $f(a)=-2$를 찾아야 하므로 f(a)== -2를 조건식으로 걸자. . f(a)== -2 . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [805] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [817] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [829] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [841] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [853] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [865] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [877] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [889] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [901] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [913] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [925] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [937] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [949] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [961] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [973] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [985] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [997] FALSE FALSE FALSE FALSE [ reached getOption(&#34;max.print&#34;) -- omitted 18001 entries ] . - 이중에 적당한 값이 있어야 한다. 보이진 않지만 (너무 많아서 눈으로 찾을수는 없지만) 어딘가에 TRUE가 하나는 있을것이다. . - TRUE가 있는지 체크할 수 있는 방법은 없을까? . . &#48372;&#52649;&#54617;&#49845;: &#52980;&#54504;&#53552;&#44032; TRUE, FALSE&#47484; &#51060;&#54644;&#54616;&#45716; &#48169;&#49885; . - 컴퓨터가 TRUE, FALSE를 1,0으로 각각 인식함. . - 아래 예제를 관찰 . TRUE + FALSE . [1] 1 . TRUE*2 . [1] 2 . TRUE+(FALSE-1) * 2 . [1] -1 . 2*c(TRUE, FALSE, TRUE) # 2*c(1,0,1) . [1] 2 0 2 . sum(c(TRUE,FALSE,TRUE)) . [1] 2 . . - 그럼 이제 f(a)==-2의 결과에서 TRUE가 진짜 있는지 찾아보자. . sum(f(a)==-2) . [1] 0 . - ??? 없음.. . - 사실 컴퓨터는 근사계산을 하였으므로 $f(a)=-2$인 $a$를 정확하게 찾기는 힘들다. 따라서 적당히 $f(a) approx -2$인 $a$를 찾는게 더 합리적이다. . - $f(a) approx -2 $ 인 $a$를 찾는건 $f(a)+2 approx 0$인 $a$를 찾는것과 같다. . - 목표: 즉 $f(a)+2$ 의 &quot;절대값&quot;이 0에 가까운 원소를 고르면 된다. . * 참고: 절대값을 구하는 방법 . abs(c(1,2,-2,3,-4)) . [1] 1 2 2 3 4 . - 위를 응용하면 . min(abs(f(a)+2)) # f(a)의 절대값중 가장 작은 값 . [1] 3.898777e-05 . - 이제 $a$는 아래와 같이 구할 수 있다. . TFarray &lt;- abs(f(a)+2) == min(abs(f(a)+2)) a[TFarray] . [1] -0.7925 . $a=-0.7925$ . - 따라서 $4^{a}+4^{-a}$는 . 4^(0.7925) + 4^(-0.7925) . [1] 3.333403 . (보기) (1) $ frac{5}{2}$ (2) $ frac{10}{3}$ (3) $ frac{17}{4}$ (4) $ frac{26}{5}$ (5) $ frac{37}{6}$ . 보기와 비교해보면 . c(5/2,10/3,17/4,26/5,37/6) . [1] 2.500000 3.333333 4.250000 5.200000 6.166667 . 따라서 답은 2번이다. . 2021(&#44032;) 9&#50900;/&#54217;&#44032;&#50896; 10(&#44256;3) . (문제) 수열 $ {a_n }$은 $a_1=12$이고, 모든 자연수 $n$에 대하여 $a_{n+1}+a_n=(-1)^{n+1} times n$을 만족시킨다. $a_k&gt; a_1$인 자연수 $k$의 최소값은? . (보기) (1) $2$ (2) $4$ (3) $6$ (4) $8$ (5) $10$ . (풀이1) . a1=12 n=1 a2= -a1 +(-1)^(n+1)*n n=2 a3= -a2 +(-1)^(n+1)*n . a3 . [1] 9 . 보기를 보니까 10이 최대값이므로 $a_{10}$까지만 구해보자. . a1=12 n=1 a2= -a1 +(-1)^(n+1)*n n=2 a3= -a2 +(-1)^(n+1)*n n=3 a4= -a3 +(-1)^(n+1)*n n=4 a5= -a4 +(-1)^(n+1)*n n=5 a6= -a5 +(-1)^(n+1)*n n=6 a7= -a6 +(-1)^(n+1)*n n=7 a8= -a7 +(-1)^(n+1)*n n=8 a9= -a8 +(-1)^(n+1)*n n=9 a10= -a9 +(-1)^(n+1)*n . a&lt;-c(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) print(a) . [1] 12 -11 9 -6 2 3 -9 16 -24 33 . (1:10)[a&gt;12] . [1] 8 10 . 답은 (4) $8$ 이다. . (풀이2) . - 풀이2를 소개하기 전에 아래와 같이 벡터를 넣는 법을 생각하자. . * 예비학습 . a_ &lt;-c() . a_ . NULL . a_[1] &lt;- 12 . a_ . [1] 12 . a_[2] &lt;- -12 . a_ . [1] 12 -12 . a_[4] &lt;- 3 . a_ . [1] 12 -12 NA 3 . - 풀이시작 (for문) . a&lt;-c() . a[1] &lt;- 12 . ## 아래와 같은 코드를 구현하고 싶다. n=1~9 a_{n+1}= -a_n +(-1)^(n+1)*n . for(n in 1:19){ a[n+1]&lt;- -a[n]+(-1)^(n+1)*n } . print(a) . [1] 12 -11 9 -6 2 3 -9 16 -24 33 -43 54 -66 79 -93 [16] 108 -124 141 -159 178 . print((1:20)[a&gt;12]) . [1] 8 10 12 14 16 18 20 . 답은 (4) 8이다. . &#49689;&#51228; . - 2021(가) 9월/평가원 10(고3) 에 해당하는 수열을 40번째 항까지 구하라. .",
            "url": "https://guebin.github.io/IR2021/2021/09/16/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9416%EC%9D%BC.html",
            "relUrl": "/2021/09/16/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9416%EC%9D%BC.html",
            "date": " • Sep 16, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "(1주차) 9월7일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/2): 2005년 예비평가(나) 12월/평가원26(고3) 첫번째 풀이 . - (2/2): 2005년 예비평가(나) 12월/평가원26(고3) 다양한 풀이 + 과제설명 . R&#51008; &#51339;&#51008; &#44228;&#49328;&#44592; &#51060;&#45796;. . 2005&#45380; &#50696;&#48708;&#54217;&#44032;(&#45208;) 12&#50900;/&#54217;&#44032;&#50896;26(&#44256;3) . 어떤 호수에서 수면에서의 빛의 세기가 $I_0$일 때, 수면이 $d$m인 곳에서의 빛의 세기 $I_d$는 다음과 같이 나타내어진다고 한다. . $$I_d=I_0 2^{-0.25d}$$ . 이 호수에서 빛의 세기가 수면에서의 빛의 세기의 25%인 곳의 수심은? (3점) . (1) 16m . (2) 12m . (3) 10m . (4) 8m . (5) 4m . (풀이1) . I0=1 d=8 Id=I0*0.25 . I0*2^(-0.25*d) ## 0.25 랑 비슷하면 된다. 현재는 Id=0.25니까.. . [1] 0.25 . (풀이2) . d=8 y=I0*2^(-0.25*d)/Id y . [1] 1 . - $y=1$이 나오는 $d$를 찾아보면된다. $ to$ 찾아보니까 $d=8$ . (풀이3) . - 함수라는걸 만들어보자. . - $d$를 입력하면, 알아서 $y$가 계산되면 좋겠다. . $$y=f(d)$$ . f&lt;-function(d){ y=I0*2^(-0.25*d)/Id y } . - $y=f(d)= frac{I_0 2^{-0.25 d}}{I_d}$ 를 함수를 만들자. . - $y=1$이 되는 $d$를 찾아보자. 그러면 답이다. . f(8) . [1] 1 . - $d=8$이 답이다. . (풀이4) . - $(d,f(d))$ 혹은 $(d,y)$를 그래프로 그려보자. . d&lt;-c(1,2,3) . d&lt;-seq(from=0,to=10,by=0.01) . y=I0*2^(-0.25*d)/Id . plot(d,y) . plot(d,y) abline(h=1,col=2,lwd=5,lty=3) . (풀이5) . x_&lt;-c(1,2,3,2,5) . x_ == 3 . [1] FALSE FALSE TRUE FALSE FALSE . d[y==1] . [1] 8 . &#49689;&#51228; . - 아래그림에서 수평선의 위치를 $y=2$로 조정하여 그려볼것 . plot(d,y) abline(h=1.1,col=2,lwd=5,lty=3) .",
            "url": "https://guebin.github.io/IR2021/2021/09/07/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%947%EC%9D%BC.html",
            "relUrl": "/2021/09/07/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%947%EC%9D%BC.html",
            "date": " • Sep 7, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "(A1) 깃허브와 fastpages를 이용하여 블로그 개설하기",
            "content": "About this doc . - 본 포스트는 2021년 1학기 Python 입문 강의내용중 일부를 업로드 하였음. . - Github, fastpages를 사용하여 블로그를 개설하고 관리하는 방법에 대한 설명임. . .",
            "url": "https://guebin.github.io/IR2021/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0-Copy1.html",
            "relUrl": "/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0-Copy1.html",
            "date": " • Aug 17, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "최규빈 . guebin@jbnu.ac.kr | 자연과학대학교 본관 205호 | 카카오톡 오픈채널 1 | . 2021년 2학기 종료후 폐쇄예정 &#8617; . |",
          "url": "https://guebin.github.io/IR2021/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://guebin.github.io/IR2021/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}