{
  
    
        "post0": {
            "title": "2021년 1학기 R입문 중간고사 풀이",
            "content": "1. R&#51012; &#51060;&#50857;&#54616;&#50668; &#45796;&#51020;&#51012; &#44228;&#49328;&#54616;&#50668;&#46972;. (3&#51216;) . (a) $2^{-5}+2^{3}$ . (b) $ sqrt{33}$ . (c) $ sum_{k=1}^{100} frac{1}{k^2+2k+1}= sum_{k=1}^{100}(k+1)^{-2}$ . (풀이) . - (c)만 풀겠습니다. . - 방법1: for문을 이용 . ak &lt;-c() for (k in 1:100) ak[k] &lt;- 1/(k**2 + 2*k + 1) sum(ak) . [1] 0.6350819 . - 방법2: 벡터의 연산을 이용한다. . k=1:100 sum(1/(k**2 + 2*k + 1) ) . [1] 0.6350819 . - 수학을 좋아하는 사람? . k=1:100 sum((k+1)^(-2)) . [1] 0.6350819 . - 제 생각에는 방법2가 좋은것 같아요. (계산효율면에서 좋고 디버깅이 편해요) . 1:100 . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 [91] 91 92 93 94 95 96 97 98 99 100 . (1:100)**2 . [1] 1 4 9 16 25 36 49 64 81 100 121 144 [13] 169 196 225 256 289 324 361 400 441 484 529 576 [25] 625 676 729 784 841 900 961 1024 1089 1156 1225 1296 [37] 1369 1444 1521 1600 1681 1764 1849 1936 2025 2116 2209 2304 [49] 2401 2500 2601 2704 2809 2916 3025 3136 3249 3364 3481 3600 [61] 3721 3844 3969 4096 4225 4356 4489 4624 4761 4900 5041 5184 [73] 5329 5476 5625 5776 5929 6084 6241 6400 6561 6724 6889 7056 [85] 7225 7396 7569 7744 7921 8100 8281 8464 8649 8836 9025 9216 [97] 9409 9604 9801 10000 . (1:100)**2 + 2*(1:100) . [1] 3 8 15 24 35 48 63 80 99 120 143 168 [13] 195 224 255 288 323 360 399 440 483 528 575 624 [25] 675 728 783 840 899 960 1023 1088 1155 1224 1295 1368 [37] 1443 1520 1599 1680 1763 1848 1935 2024 2115 2208 2303 2400 [49] 2499 2600 2703 2808 2915 3024 3135 3248 3363 3480 3599 3720 [61] 3843 3968 4095 4224 4355 4488 4623 4760 4899 5040 5183 5328 [73] 5475 5624 5775 5928 6083 6240 6399 6560 6723 6888 7055 7224 [85] 7395 7568 7743 7920 8099 8280 8463 8648 8835 9024 9215 9408 [97] 9603 9800 9999 10200 . (1:100)**2 + 2*(1:100) +1 . [1] 4 9 16 25 36 49 64 81 100 121 144 169 [13] 196 225 256 289 324 361 400 441 484 529 576 625 [25] 676 729 784 841 900 961 1024 1089 1156 1225 1296 1369 [37] 1444 1521 1600 1681 1764 1849 1936 2025 2116 2209 2304 2401 [49] 2500 2601 2704 2809 2916 3025 3136 3249 3364 3481 3600 3721 [61] 3844 3969 4096 4225 4356 4489 4624 4761 4900 5041 5184 5329 [73] 5476 5625 5776 5929 6084 6241 6400 6561 6724 6889 7056 7225 [85] 7396 7569 7744 7921 8100 8281 8464 8649 8836 9025 9216 9409 [97] 9604 9801 10000 10201 . 1 / ((1:100)**2 + 2*(1:100) +1) . [1] 0.2500000000 0.1111111111 0.0625000000 0.0400000000 0.0277777778 [6] 0.0204081633 0.0156250000 0.0123456790 0.0100000000 0.0082644628 [11] 0.0069444444 0.0059171598 0.0051020408 0.0044444444 0.0039062500 [16] 0.0034602076 0.0030864198 0.0027700831 0.0025000000 0.0022675737 [21] 0.0020661157 0.0018903592 0.0017361111 0.0016000000 0.0014792899 [26] 0.0013717421 0.0012755102 0.0011890606 0.0011111111 0.0010405827 [31] 0.0009765625 0.0009182736 0.0008650519 0.0008163265 0.0007716049 [36] 0.0007304602 0.0006925208 0.0006574622 0.0006250000 0.0005948840 [41] 0.0005668934 0.0005408329 0.0005165289 0.0004938272 0.0004725898 [46] 0.0004526935 0.0004340278 0.0004164931 0.0004000000 0.0003844675 [51] 0.0003698225 0.0003559986 0.0003429355 0.0003305785 0.0003188776 [56] 0.0003077870 0.0002972652 0.0002872738 0.0002777778 0.0002687450 [61] 0.0002601457 0.0002519526 0.0002441406 0.0002366864 0.0002295684 [66] 0.0002227668 0.0002162630 0.0002100399 0.0002040816 0.0001983733 [71] 0.0001929012 0.0001876525 0.0001826150 0.0001777778 0.0001731302 [76] 0.0001686625 0.0001643655 0.0001602307 0.0001562500 0.0001524158 [81] 0.0001487210 0.0001451589 0.0001417234 0.0001384083 0.0001352082 [86] 0.0001321178 0.0001291322 0.0001262467 0.0001234568 0.0001207584 [91] 0.0001181474 0.0001156203 0.0001131734 0.0001108033 0.0001085069 [96] 0.0001062812 0.0001041233 0.0001020304 0.0001000000 0.0000980296 . sum(1 / ((1:100)**2 + 2*(1:100) +1)) . [1] 0.6350819 . 2. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (2&#51216;) . (a) &#50500;&#47000;&#50752; &#44057;&#51008; &#49688;&#50676;&#51012; &#49373;&#49457;&#54616;&#46972;. . $$x=(-10,-9.5,-9.0,...,9.0,9.5,10)$$ . (b) &#49373;&#49457;&#46108; &#49688;&#50676;&#50640; &#45824;&#54616;&#50668; &#50500;&#47000;&#47484; &#47564;&#51313;&#54616;&#45716; $y$&#47484; &#44228;&#49328;&#54616;&#46972;. . $$y= begin{cases} x &amp; |x|&gt;5 0 &amp; |x| leq 2 5 &amp; o.w. end{cases}$$ (풀이) . - 그냥 예제문제 . seq(-10,10,0.5) . [1] -10.0 -9.5 -9.0 -8.5 -8.0 -7.5 -7.0 -6.5 -6.0 -5.5 -5.0 -4.5 [13] -4.0 -3.5 -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 [25] 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 [37] 8.0 8.5 9.0 9.5 10.0 . x=seq(-10,10,0.5) . ifelse(abs(x)&gt;5,x, ifelse(abs(x)&lt;=2,0,5)) . [1] -10.0 -9.5 -9.0 -8.5 -8.0 -7.5 -7.0 -6.5 -6.0 -5.5 5.0 5.0 [13] 5.0 5.0 5.0 5.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [25] 0.0 5.0 5.0 5.0 5.0 5.0 5.0 5.5 6.0 6.5 7.0 7.5 [37] 8.0 8.5 9.0 9.5 10.0 . - 검산 . cbind(x,ifelse(abs(x)&gt;5,x, ifelse(abs(x)&lt;=2,0,5))) . x [1,] -10.0 -10.0 [2,] -9.5 -9.5 [3,] -9.0 -9.0 [4,] -8.5 -8.5 [5,] -8.0 -8.0 [6,] -7.5 -7.5 [7,] -7.0 -7.0 [8,] -6.5 -6.5 [9,] -6.0 -6.0 [10,] -5.5 -5.5 [11,] -5.0 5.0 [12,] -4.5 5.0 [13,] -4.0 5.0 [14,] -3.5 5.0 [15,] -3.0 5.0 [16,] -2.5 5.0 [17,] -2.0 0.0 [18,] -1.5 0.0 [19,] -1.0 0.0 [20,] -0.5 0.0 [21,] 0.0 0.0 [22,] 0.5 0.0 [23,] 1.0 0.0 [24,] 1.5 0.0 [25,] 2.0 0.0 [26,] 2.5 5.0 [27,] 3.0 5.0 [28,] 3.5 5.0 [29,] 4.0 5.0 [30,] 4.5 5.0 [31,] 5.0 5.0 [32,] 5.5 5.5 [33,] 6.0 6.0 [34,] 6.5 6.5 [35,] 7.0 7.0 [36,] 7.5 7.5 [37,] 8.0 8.0 [38,] 8.5 8.5 [39,] 9.0 9.0 [40,] 9.5 9.5 [41,] 10.0 10.0 . 3. $x=(-10,-9,-8, dots,8,9,10)$&#51032; &#44033; &#50896;&#49548;&#50640; &#45824;&#54616;&#50668; $h(g(f(x)))$&#51032; &#44228;&#49328;&#44208;&#44284;&#47484; &#44396;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. (10&#51216;) . 단, $f(x)$,$g(x)$, $h(x)$의 정의는 각각 아래와 같다. . $f(x)=2x+3 $ | $g(x)= frac{e^x}{1+e^x}$ | $h(x)=max(x,0)$ | . (풀이) . - 문제 의도가 좀 왜곡되었어요.. $x=(-10,-9,-8, dots, 8,9,10)$의 각 원소에 대하여! 로 바꿔야합니다. . library(tidyverse) . f = function(x) 2*x +3 g = function(x) exp(x) / (1+exp(x)) h = function(x) max(x,0) -10:10 %&gt;% f %&gt;% g %&gt;% h . [1] 1 . - 원래 의도는 이거였습니다. . f = function(x) 2*x +3 g = function(x) exp(x) / (1+exp(x)) h = function(x) ifelse(y&gt;0,y,0) -10:10 %&gt;% f %&gt;% g %&gt;% h . [1] 4.139938e-08 3.059022e-07 2.260324e-06 1.670142e-05 1.233946e-04 [6] 9.110512e-04 6.692851e-03 4.742587e-02 2.689414e-01 7.310586e-01 [11] 9.525741e-01 9.933071e-01 9.990889e-01 9.998766e-01 9.999833e-01 [16] 9.999977e-01 9.999997e-01 1.000000e+00 1.000000e+00 1.000000e+00 [21] 1.000000e+00 . 4. &#50500;&#47000;&#51473; &#50739;&#51008;&#44163;&#51008;? (O / X &#47196; &#45813;&#50504;&#51648;&#47484; &#50416;&#44256; &#45813;&#51032; &#44540;&#44144;&#44032; &#46104;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54624;&#44163;) (10&#51216;) . (a) $1= frac{1}{2}+ frac{1}{4} + frac{1}{8} dots $ . (b) $e^x= 1+x+x^2+x^3+ dots $ . (풀이) . sum=0 for (i in 1:10){ sum=sum+(1/2)**i print(sum) } . [1] 0.5 [1] 0.75 [1] 0.875 [1] 0.9375 [1] 0.96875 [1] 0.984375 [1] 0.9921875 [1] 0.9960938 [1] 0.9980469 [1] 0.9990234 . 1에 점점 가까워짐 | . 5. &#45796;&#51020;&#51012; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (10&#51216;) . 다음은 어느 회사의 연봉에 대한 규정이다. . (가) 입사 첫째 해 연봉은 $a$원이고, 입사 19년째 해까지의 연봉은 해마다 직전 연봉에서 8%씩 인상된다. . (나) 입사 20년째 해부터의 연봉은 입사 19년째 해 연봉의 75%로 한다. . 이 회사에 입사한 사람이 28년동안 근무하여 받는 연봉의 총합은? . 6. &#45796;&#51020; &#47928;&#51109;&#51012; &#51069;&#44256; &#52280;&#44144;&#51667;&#51012; &#54032;&#45800;&#54616;&#49884;&#50724;. (10&#51216;) . (a) _a&#45716; &#48320;&#49688;&#51060;&#47492;&#51004;&#47196; &#44032;&#45733;&#54616;&#45796;. . (b) &#48289;&#53552;&#51032; &#50896;&#49548;&#45716; &#49688;&#52824;&#54805;(numeric)&#47564; &#44032;&#45733;&#54616;&#45796;. . (c) &#45436;&#47532;&#54805;(logical)&#48320;&#49688;&#45716; &#49688;&#52824;&#54805; &#48320;&#49688;&#47196; &#48320;&#54872;&#54624; &#49688; &#50630;&#45796;. . (d) R&#50640;&#49436; {}&#45716; ()&#47196; &#48148;&#44992; &#49688; &#51080;&#45796;. . 7. 100&#44060;&#51032; &#46972;&#52964; (15&#51216;) . 복도에 100개의 라커가 있다. 복도를 어떤 남자가 100개의 라커 문을 전부 연다. 그리고 나서 짝수 번호의 라커를 전부 닫는다. 그 다음에는 번호가 3의 배수인 라커를 순서대로 찾아다니며 열려 있으면 닫고, 닫혀 있으면 연다. 그 다음에는 번호가 4의 배수인 라커를 순서대로 찾아다니며 열려있으면 닫고, 닫혀있으면 연다. 이후에 5의 배수, 6의 배수 .. 인 라커를 순서대로 찾아다니며 행동을 반복한다. 이런식으로 복도를 100번 지나가면 열린 라커의 문은 몇개가 되겠는가? . (풀이1) . - 문을 모두 닫은 상태로 둔다. . x= rep(FALSE, 100) . x . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [97] FALSE FALSE FALSE FALSE . - 문을 여는 함수를 만든다. (닫혀있으면 열고, 열려있으면 닫는함수) . f&lt;- function(x) !x . 10월7일강의 논리연산자 예제1 | . x %&gt;% f . [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE . 문이 잘 열린다. | . - 2,3,4,5 ... 의 배수를 찾아서 문을 열자. . Step1: 2,3,4,5의 배수에 해당하는 원소를 뽑는 코드를 작성한다. | Step2: Step1에서 나온 원소에 한정하여 문을 열거나 닫는다. | . - 2의 배수 구현예시 . (1:100) %% 2 == 0 . [1] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [13] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [25] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [37] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [49] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [61] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [73] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [85] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [97] FALSE TRUE FALSE TRUE . 짝이면 TRUE, 홀이면 FALSE 인 벡터 | . x[(1:100) %% 2 == 0 ] . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] FALSE FALSE . 1~100까지의 라커중 짝수에 해당하는 라커만 추출 | . x[(1:100) %% 2 == 0 ] %&gt;% f . [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [46] TRUE TRUE TRUE TRUE TRUE . 1~100까지의 라커중 짝수에 해당하는 라커만 추출 $ to$ 그 라커들은 문을 열었음 | . x[(1:100) %% 2 == 0 ] &lt;- x[(1:100) %% 2 == 0 ] %&gt;% f x . [1] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [13] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [25] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [37] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [49] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [61] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [73] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [85] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [97] FALSE TRUE FALSE TRUE . 결과를 저장 | . - 3의 배수 구현예시 . x[(1:100) %% 3 == 0 ] &lt;- x[(1:100) %% 3 == 0 ] %&gt;% f . - 4의 배수.. 5의 배수.. $ to$ 함수를 만들자. . g=function(x,a){ n=length(x) x[(1:n) %% a == 0 ] &lt;- x[(1:n) %% a == 0 ] %&gt;% f ## 연산 x ## 결과를 리턴 } . - 검산을 해보자. (검산을 쉽게하기 위해서 10개정도의 라커만 고려하자.) . x=rep(FALSE, 10) x . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE . x %&gt;% f . [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE . x %&gt;% f %&gt;% g(2) . [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE . x %&gt;% f %&gt;% g(2) %&gt;% g(3) . [1] TRUE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE . - 잘 되는것 같습니다. 이제 일반화해서 답을 구해보면 . x=rep(FALSE, 100) # x를 선언, FALSE의 의미는 문이 닫혀있다. x=f(x) # 1회 복도를 지나가면서 모든 문을 열어요 for (i in 2:100){ # 2회부터 100회까지 지나가면서 x=g(x,i) # (1) 2,3,4,5 ... , 100의 배수에 해당하는 문을 선택 (2) 문이 열려있으면 닫고, 닫혀있으면 열어요 } . - 결과는 아래와 같다. . x . [1] TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE [13] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [61] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [97] FALSE FALSE FALSE TRUE . sum(x) . [1] 10 . (풀이2) . x=rep(TRUE,100) for (i in 2:100) x[(1:100) %% i ==0] = !( x[(1:100) %% i ==0] ) sum(x) . [1] 10 . 시험제출용 코드입니다. 공부용은 아니에요 | 차근차근 디버깅을 하고 코드를 확인해가면서 혹시 모를 실수를 방지할 수 있는 풀이 1이 좋아요. | 코드 중간결과를 시각화해서 내가 잘 구현하고 있는지 끊임없이 확인해야 합니다. | 그 다음에 코드를 효율적으로 정리합니다. | . 8. &#47924;&#44417;&#54868; &#44867;&#51060; &#54588;&#50632;&#49845;&#45768;&#45796;. (25&#51216;) . 총 456명의 참가자가 &#39;무궁화 꽃이 피었습니다&#39; 게임에 참가한다. 기본적인 게임의 규칙은 아래와 같다. . 술래는 총 10회간 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39; 를 외친다. . | 참가자는 술래가 있는 곳 까지 이동해야 살 수 있다. . | 술래는 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39;를 외치다가 구호가 끝남과 동시에 뒤를 돌아본다. 이때 움직이는 사람은 죽는다 . | . 따라서 참가자는 술래가 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39;를 외치는 동안만 이동할 수 있다. 욕심을 부려 더 이동하고자 하면 죽을 수 있다. 반대로 죽는 것을 지나치게 두려워한 나머지 매턴마다 조금씩만 이동한다면 10회의 제한횟수 내에 술래에게 도달하지 못하여 죽는다. . 게임환경과 관련된 세부적인 설정은 아래와 같다. . 술래와 참가자의 거리는 35이다. . | 술래는 처음 벽을 보고 $x$초간 무궁화 꽃이 피었습니다를 외친다. . | 모든 참가자는 1초에 거리1이상 움직일 수 없다고 가정한다. (예를들어 2.4초 동안은 최대 2.4의 거리를 이동할 수 있다. 반면 이동을 원치않으면 0의 거리만큼 움직이므로 0~2.4사이의 거리를 움직일 수 있다) . | . 술래와 참가자에 대한 설정값은 아래와 같다. . 술래에 대한 설정값 . 처음에는 술래가 10초간 무궁화 꽃이 피었습니다를 외친다. . | 그 다음에는 술래가 9.5초간 무궁화 꽃이 피었습니다를 외친다. . | 그 다음에도 0.5초씩 구호를 외치는 시간을 줄인다. 이것을 10회 반복한다. . | . 참가자에 대한 설정값 . 처음에는 참가자가 &quot;본인의번호/100&quot;을 계산하여 나온 숫자만큼 움직인다. 즉 10번 참가자는 0.1의 거리를 움직이고 456번 참가자는 4.56의 거리를 움직인다. . | 그 다음은 처음에 본인이 이동했던 거리에 1씩 더하여 움직인다. 즉 10번 참가자는 1.1의 거리를 움직이고 456번 참가자는 5.56의 거리를 움직인다. . | . - 예시1 . 300번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 3 | 4 | 5 | 6 | 7 | 7.5 | . 참가자의 총 이동거리 | 3 | 7 | 12 | 18 | 25 | 32.5 | . 생존할 수 없다. (6회에서 32.5까지 이동후 사망) . - 예시2 . 350번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 3.5 | 4.5 | 5.5 | 6.5 | 7.5 | 7.5 | . 참가자의 총 이동거리 | 3.5 | 8 | 13.5 | 20 | 27.5 | 35 | . 생존 할 수 있다. (6회에서 정확하게 7.5초간 이동하고 살아남는다) . - 예시3 . 400번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 4 | 5 | 6 | 7 | 8 | 5 | . 참가자의 총 이동거리 | 4 | 9 | 15 | 22 | 30 | 35 | . 생존 할 수 있다. (6회에서 5초간만 이동하면 35만큼 이동하므로 살아남는다) . (a) 1&#48264;, 67&#48264;, 218&#48264;, 456&#48264; &#52280;&#44032;&#51088;&#51032; &#49373;&#51316;&#50668;&#48512;&#47484; &#54869;&#51064;&#54616;&#45716; &#54632;&#49688;&#47484; &#51089;&#49457;&#54616;&#46972;. . (b) &#51204;&#52404; &#49373;&#51316;&#51088;&#51473; &#47751;&#47749;&#51060; &#49332;&#50500;&#45224;&#45716;&#51648; &#44228;&#49328;&#54616;&#46972;. . (풀이) . - 전략: 각 플레이어별로 죽느냐 사느냐를 판단하는 로직을 구현하고 for문을 돌리면 된다. . - 죽느냐 사느냐를 판단하는 방법: 살아있는 동안 이동한 총거리 &gt;= 35 . - 살아있는 동안 이동한 총거리를 계산하는 방법: . 죽을위험이 없는 횟수에서 이동한 총거리 + 죽을위험이 있는 횟수에서 술래의 외침시간 동안 이동한 거리 | . - 죽을위험이 없는 횟수에서 이동한 총거리 . num=350 x= seq(10,5.5,by=-.5) ## 술래의 외침시간 steps = num/100 + 0:9 ## 참가자가 이동하려는 거리 . x&gt;=steps . [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE . sum(steps[x&gt;=steps]) . [1] 27.5 . - 죽을 위험이 있는 횟수에서 이동한 거리 . x[x&lt;steps][1] . [1] 7.5 . - 더하면? . sum(steps[x&gt;=steps]) + x[x&lt;steps][1] ## 총이동거리 . [1] 35 . - 총이동거리 &gt;= 35 이면 살아남을 수 있음 . sum(steps[x&gt;=steps]) + x[x&lt;steps][1] &gt;= 35 . [1] TRUE . - 정리하면 . x=seq(10,5.5,by= -0.5) surv&lt;-c() for (num in 1:456){ steps = num/100 + 0:9 surv[num] &lt;- sum(steps[x&gt;=steps]) + x[x&lt;steps][1] &gt;= 35 } sum(surv) . [1] 85 . 9. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#49884;&#44033;&#54868; &#54616;&#46972;. (15&#51216;) . 다음은 인터넷에서 어떠한 자료를 다운받아 매트릭스로 저장하는 코드이다. . df=read.csv(&quot;https://raw.githubusercontent.com/miruetoto/yechan/master/_notebooks/round2.csv&quot;) mat=as.matrix(df) . 매트릭스는 mat이라는 변수에 저장되어 있다. . df=read.csv(&quot;https://raw.githubusercontent.com/miruetoto/yechan/master/_notebooks/round2.csv&quot;) mat=as.matrix(df) . (a) mat&#51032; &#52395;&#48264;&#51704; &#50676;&#51012; $x$, &#46160;&#48264;&#51704;&#50676;&#51012; $y$&#47196; &#49373;&#44033;&#54616;&#44256; plot&#54632;&#49688;&#47484; &#53685;&#54616;&#50668; &#50500;&#47000;&#50752; &#44057;&#51008; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. . plot(mat[,1],mat[,2]) . plot(mat) . R은 알아서 해석해서 해주는 것이 좀 많아요.. | 이것은 프로그램 만든 사람이 편의성을 위해 &quot;만들어준&quot; 기능입니다. | 이러한 기능을 이용한 풀이는 좋은 풀이가 아닌데 그 이유는 프로그램을 만든 사람의 마음에 따라서 시각화가 가능하기도 하고 불가능하기도 합니다. | . (b) &#47588;&#53944;&#47533;&#49828;&#51032; &#52395;&#48264;&#51704; &#54665;(first row)&#47484; &#52636;&#47141;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . - 힌트: 출력결과는 (12,313)이 나와야 한다. . mat[1,] . x y 12 313 . (c) (b)&#51032; &#44208;&#44284;&#50640; &#50500;&#47000;&#51032; &#50672;&#49328;&#51012; &#49688;&#54665;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . $$ begin{bmatrix} 0 &amp; -1 -1 &amp; 0 end{bmatrix} begin{bmatrix} 12 313 end{bmatrix} $$ f = function(X){ dim(X)=c(2,1) X } . rbind(c(0,-1),c(-1,0)) %*% f(mat[1,]) . [,1] [1,] -313 [2,] -12 . (d) (b)-(c) &#44284;&#51221;&#51012; mat&#51032; &#47784;&#46304;&#54665;&#50640; &#48152;&#48373;&#54616;&#50668; &#49352;&#47196;&#50868; &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46308;&#50612;&#46972;. . - 힌트: 아래의 과정을 따른다. . (i) mat와 동일한 dim을 가진 mat2를 만든다. | (ii) mat의 첫번째 행에 (b)-(c)의 과정을 적용하여 길이가 2인 벡터를 얻는다. | (iii) (ii)의 과정에서 얻은 벡터를 새로운 매트릭스의 첫번째 행에 넣는다. | (iv) mat의 두번째 행에 대하여 (ii)-(iii)의 과정을 반복한다. 이후 세번째, 네번째 행에 대하여 (ii)-(iii)의 과정을 반복한다. | . g = function(X){ dim(X)=c(1,2) X } . dim(mat2) . [1] 5513 2 . mat2 = mat*0 for (i in 1:5513) mat2[i,] = rbind(c(0,-1),c(-1,0)) %*% f(mat[i,]) %&gt;% g . (e) (d)&#51032; &#44208;&#44284;&#47196; &#49373;&#49457;&#46104; &#47588;&#53944;&#47533;&#49828;&#51032; &#52395;&#48264;&#51704; &#50676;&#51012; x, &#46160;&#48264;&#51704; &#50676;&#51012; y&#47196; &#54616;&#44256; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. (&#51216;&#51032; &#49353;&#51008; &#48521;&#51008;&#49353;&#51004;&#47196; &#54616;&#46972;) . - 힌트: 아래와 같은 그림이 나와야 한다. . plot(mat2[,1],mat2[,2],col=&#39;red&#39;) . (풀이) . - 사실 아래는 같음 . rbind(c(0,-1),c(-1,0)) %*% c(12,312) ## c(12,313) 벡터 . [,1] [1,] -312 [2,] -12 . rbind(c(0,-1),c(-1,0)) %*% matrix(c(12,312),nrow=2) . [,1] [1,] -312 [2,] -12 . - 그리고 아래도 같음 . c(12,313) %*% rbind(c(0,-1),c(-1,0)) . [,1] [,2] [1,] -313 -12 . matrix(c(12,313),nrow=1) %*% rbind(c(0,-1),c(-1,0)) . [,1] [,2] [1,] -313 -12 . - c(12,313)이 때로는 벡터로, 때로는 $n times 1$인 매트릭스로 생각할 수 있고, 때로는 $1 times n$ 매트릭스로 해석할 수도 있음. . - 따라서 아래와 같이 풀어도 가능함. . mat2 = mat*0 for (i in 1:5513) mat2[i,] = rbind(c(0,-1),c(-1,0)) %*% mat[i,] . plot(mat2,col=&#39;red&#39;) . (풀이3) . - 매트릭스의 곱셈을 잘 이해했다면? . head(mat) . x y [1,] 12 313 [2,] 12 314 [3,] 13 279 [4,] 13 311 [5,] 13 312 [6,] 13 313 . rbind(c(0,-1),c(-1,0)) %*% c(12,313) . [,1] [1,] -313 [2,] -12 . rbind(c(0,-1),c(-1,0)) %*% c(12,314) . [,1] [1,] -314 [2,] -12 . cbind(c(12,313),c(12,314)) . [,1] [,2] [1,] 12 12 [2,] 313 314 . rbind(c(0,-1),c(-1,0)) %*% cbind(c(12,313),c(12,314)) . [,1] [,2] [1,] -313 -314 [2,] -12 -12 . - 응용하면 . rbind(c(0,-1),c(-1,0)) %*% t(mat) %&gt;% t %&gt;% plot(col=&#39;red&#39;) . - 매트릭스 A,B의 곱에서 뒷부분을 임의의 칼럼으로 쪼개서 각각 연산한뒤 합쳐도 성립한다. . - 매트릭스 A,B의 곱에서 앞부분을 임의의 로우로 쪼개서 각각 연산한뒤 합쳐도 성립한다. .",
            "url": "https://guebin.github.io/2021IR/2021/11/11/2021%EB%85%84-1%ED%95%99%EA%B8%B0-R%EC%9E%85%EB%AC%B8%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%ED%92%80%EC%9D%B4.html",
            "relUrl": "/2021/11/11/2021%EB%85%84-1%ED%95%99%EA%B8%B0-R%EC%9E%85%EB%AC%B8%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%ED%92%80%EC%9D%B4.html",
            "date": " • Nov 11, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "2021년 1학기 R입문 중간고사",
            "content": "1. R&#51012; &#51060;&#50857;&#54616;&#50668; &#45796;&#51020;&#51012; &#44228;&#49328;&#54616;&#50668;&#46972;. (3&#51216;) . (a) $2^{-5}+2^{3}$ . (b) $ sqrt{33}$ . (c) $ sum_{k=1}^{100} frac{1}{k^2+2k+1}$ . 2. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (2&#51216;) . (a) &#50500;&#47000;&#50752; &#44057;&#51008; &#49688;&#50676;&#51012; &#49373;&#49457;&#54616;&#46972;. . $$x=(-10,-9.5,-9.0,...,9.0,9.5,10)$$ . (b) &#49373;&#49457;&#46108; &#49688;&#50676;&#50640; &#45824;&#54616;&#50668; &#50500;&#47000;&#47484; &#47564;&#51313;&#54616;&#45716; $y$&#47484; &#44228;&#49328;&#54616;&#46972;. . $$y= begin{cases} x &amp; |x|&gt;5 0 &amp; |x| leq 2 5 &amp; o.w. end{cases}$$ 3. $x=(-10,-9,-8, dots,8,9,10)$&#50640; &#45824;&#54616;&#50668; $h(g(f(x)))$&#51032; &#44228;&#49328;&#44208;&#44284;&#47484; &#44396;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. (10&#51216;) . 단, $f(x)$,$g(x)$, $h(x)$의 정의는 각각 아래와 같다. . $f(x)=2x+3 $ | $g(x)= frac{e^x}{1+e^x}$ | $h(x)=max(x,0)$ | . 4. &#50500;&#47000;&#51473; &#50739;&#51008;&#44163;&#51008;? (O / X &#47196; &#45813;&#50504;&#51648;&#47484; &#50416;&#44256; &#45813;&#51032; &#44540;&#44144;&#44032; &#46104;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54624;&#44163;) (10&#51216;) . (a) $1= frac{1}{2}+ frac{1}{4} + frac{1}{8} dots $ . (b) $e^x= 1+x+x^2+x^3+ dots $ . 5. &#45796;&#51020;&#51012; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (10&#51216;) . 다음은 어느 회사의 연봉에 대한 규정이다. . (가) 입사 첫째 해 연봉은 $a$원이고, 입사 19년째 해까지의 연봉은 해마다 직전 연봉에서 8%씩 인상된다. . (나) 입사 20년째 해부터의 연봉은 입사 19년째 해 연봉의 75%로 한다. . 이 회사에 입사한 사람이 28년동안 근무하여 받는 연봉의 총합은? . 6. &#45796;&#51020; &#47928;&#51109;&#51012; &#51069;&#44256; &#52280;&#44144;&#51667;&#51012; &#54032;&#45800;&#54616;&#49884;&#50724;. (10&#51216;) . (a) _a&#45716; &#48320;&#49688;&#51060;&#47492;&#51004;&#47196; &#44032;&#45733;&#54616;&#45796;. . (b) &#48289;&#53552;&#51032; &#50896;&#49548;&#45716; &#49688;&#52824;&#54805;(numeric)&#47564; &#44032;&#45733;&#54616;&#45796;. . (c) &#45436;&#47532;&#54805;(logical)&#48320;&#49688;&#45716; &#49688;&#52824;&#54805; &#48320;&#49688;&#47196; &#48320;&#54872;&#54624; &#49688; &#50630;&#45796;. . (d) R&#50640;&#49436; {}&#45716; ()&#47196; &#48148;&#44992; &#49688; &#51080;&#45796;. . 7. 100&#44060;&#51032; &#46972;&#52964; (15&#51216;) . 복도에 100개의 라커가 있다. 복도를 어떤 남자가 100개의 라커 문을 전부 연다. 그리고 나서 짝수 번호의 라커를 전부 닫는다. 그 다음에는 번호가 3의 배수인 라커를 순서대로 찾아다니며 열려 있으면 닫고, 닫혀 있으면 연다. 그 다음에는 번호가 4의 배수인 라커를 순서대로 찾아다니며 열려있으면 닫고, 닫혀있으면 연다. 이후에 5의 배수, 6의 배수 .. 인 라커를 순서대로 찾아다니며 행동을 반복한다. 이런식으로 복도를 100번 지나가면 열린 라커의 문은 몇개가 되겠는가? . 8. &#47924;&#44417;&#54868; &#44867;&#51060; &#54588;&#50632;&#49845;&#45768;&#45796;. (25&#51216;) . 총 456명의 참가자가 &#39;무궁화 꽃이 피었습니다&#39; 게임에 참가한다. 기본적인 게임의 규칙은 아래와 같다. . 술래는 총 10회간 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39; 를 외친다. . | 참가자는 술래가 있는 곳 까지 이동해야 살 수 있다. . | 술래는 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39;를 외치다가 구호가 끝남과 동시에 뒤를 돌아본다. 이때 움직이는 사람은 죽는다 . | . 따라서 참가자는 술래가 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39;를 외치는 동안만 이동할 수 있다. 욕심을 부려 더 이동하고자 하면 죽을 수 있다. 반대로 죽는 것을 지나치게 두려워한 나머지 매턴마다 조금씩만 이동한다면 10회의 제한횟수 내에 술래에게 도달하지 못하여 죽는다. . 게임환경과 관련된 세부적인 설정은 아래와 같다. . 술래와 참가자의 거리는 35이다. . | 술래는 처음 벽을 보고 $x$초간 무궁화 꽃이 피었습니다를 외친다. . | 모든 참가자는 1초에 거리1이상 움직일 수 없다고 가정한다. (예를들어 2.4초 동안은 최대 2.4의 거리를 이동할 수 있다. 반면 이동을 원치않으면 0의 거리만큼 움직이므로 0~2.4사이의 거리를 움직일 수 있다) . | . 술래와 참가자에 대한 설정값은 아래와 같다. . 술래에 대한 설정값 . 처음에는 술래가 10초간 무궁화 꽃이 피었습니다를 외친다. . | 그 다음에는 술래가 9.5초간 무궁화 꽃이 피었습니다를 외친다. . | 그 다음에도 0.5초씩 구호를 외치는 시간을 줄인다. 이것을 10회 반복한다. . | . 참가자에 대한 설정값 . 처음에는 참가자가 &quot;본인의번호/100&quot;을 계산하여 나온 숫자만큼 움직인다. 즉 10번 참가자는 0.1의 거리를 움직이고 456번 참가자는 4.56의 거리를 움직인다. . | 그 다음은 처음에 본인이 이동했던 거리에 1씩 더하여 움직인다. 즉 10번 참가자는 1.1의 거리를 움직이고 456번 참가자는 5.56의 거리를 움직인다. . | . - 예시2 . 300번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 3 | 4 | 5 | 6 | 7 | 7.5 | . 참가자의 총 이동거리 | 3 | 7 | 12 | 18 | 25 | 32.5 | . 생존할 수 없다. (6회에서 32.5까지 이동후 사망) . - 예시2 . 350번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 3.5 | 4.5 | 5.5 | 6.5 | 7.5 | 7.5 | . 참가자의 총 이동거리 | 3.5 | 8 | 13.5 | 20 | 27.5 | 35 | . 생존 할 수 있다. (6회에서 정확하게 7.5초간 이동하고 살아남는다) . - 예시3 . 400번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 4 | 5 | 6 | 7 | 8 | 5 | . 참가자의 총 이동거리 | 4 | 9 | 15 | 22 | 30 | 35 | . 생존 할 수 있다. (6회에서 5초간만 이동하면 35만큼 이동하므로 살아남는다) . (a) 1&#48264;, 67&#48264;, 218&#48264;, 456&#48264; &#52280;&#44032;&#51088;&#51032; &#49373;&#51316;&#50668;&#48512;&#47484; &#54869;&#51064;&#54616;&#45716; &#54632;&#49688;&#47484; &#51089;&#49457;&#54616;&#46972;. . (b) &#51204;&#52404; &#49373;&#51316;&#51088;&#51473; &#47751;&#47749;&#51060; &#49332;&#50500;&#45224;&#45716;&#51648; &#44228;&#49328;&#54616;&#46972;. . 9. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#49884;&#44033;&#54868; &#54616;&#46972;. (15&#51216;) . 다음은 인터넷에서 어떠한 자료를 다운받아 매트릭스로 저장하는 코드이다. . df=read.csv(&quot;https://raw.githubusercontent.com/miruetoto/yechan/master/_notebooks/round2.csv&quot;) mat=as.matrix(df) . 매트릭스는 mat이라는 변수에 저장되어 있다. . (a) mat&#51032; &#52395;&#48264;&#51704; &#50676;&#51012; $x$, &#46160;&#48264;&#51704;&#50676;&#51012; $y$&#47196; &#49373;&#44033;&#54616;&#44256; plot&#54632;&#49688;&#47484; &#53685;&#54616;&#50668; &#50500;&#47000;&#50752; &#44057;&#51008; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. . . (b) &#47588;&#53944;&#47533;&#49828;&#51032; &#52395;&#48264;&#51704; &#54665;(first row)&#47484; &#52636;&#47141;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . - 힌트: 출력결과는 (12,313)이 나와야 한다. . (c) (b)&#51032; &#44208;&#44284;&#50640; &#50500;&#47000;&#51032; &#50672;&#49328;&#51012; &#49688;&#54665;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . $$ begin{bmatrix} 0 &amp; -1 -1 &amp; 0 end{bmatrix} begin{bmatrix} 12 313 end{bmatrix} $$ (d) (b)-(c) &#44284;&#51221;&#51012; mat&#51032; &#47784;&#46321;&#54665;&#50640; &#48152;&#48373;&#54616;&#50668; &#49352;&#47196;&#50868; &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46308;&#50612;&#46972;. . - 힌트: 아래의 과정을 따른다. . (i) mat와 동일한 dim을 가진 mat2를 만든다. | (ii) mat의 첫번째 행에 (b)-(c)의 과정을 적용하여 길이가 2인 벡터를 얻는다. | (iii) (ii)의 과정에서 얻은 벡터를 새로운 매트릭스의 첫번째 행에 넣는다. | (iv) mat의 두번째 행에 대하여 (ii)-(iii)의 과정을 반복한다. 이후 세번째, 네번째 행에 대하여 (ii)-(iii)의 과정을 반복한다. | . (e) (d)&#51032; &#44208;&#44284;&#47196; &#49373;&#49457;&#46104; &#47588;&#53944;&#47533;&#49828;&#51032; &#52395;&#48264;&#51704; &#50676;&#51012; x, &#46160;&#48264;&#51704; &#50676;&#51012; y&#47196; &#54616;&#44256; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. (&#51216;&#51032; &#49353;&#51008; &#48521;&#51008;&#49353;&#51004;&#47196; &#54616;&#46972;) . - 힌트: 아래와 같은 그림이 나와야 한다. . .",
            "url": "https://guebin.github.io/2021IR/2021/11/09/2021%EB%85%84-1%ED%95%99%EA%B8%B0-R%EC%9E%85%EB%AC%B8%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC.html",
            "relUrl": "/2021/11/09/2021%EB%85%84-1%ED%95%99%EA%B8%B0-R%EC%9E%85%EB%AC%B8%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC.html",
            "date": " • Nov 9, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "시험관련 안내사항",
            "content": "&#49884;&#54744;&#50976;&#54805; . - 오픈북: 강의노트, 본인이 정리한 노트, 인터넷 검색 가능 . - 비대면: Zoom을 활용하여 응시 . &#49884;&#54744;&#49884;&#44036; . - 일시: LMS를 통해 공지한 날의 수업시간 . - 시험시간 중 처음 30분은 장비점검시간으로 활용함 (단, 모든 사람이 준비될 경우 30분을 기다리지 않고 시작) . . Note: 따라서 2시간 수업일 경우 실질적으로 문제를 풀고 답안을 제출할때 까지 쓸 수 있는 시간은 1시간30분입니다. . &#49884;&#54744;&#49892; &#51077;&#51109; . - LMS $ to$ 강의대화 $ to$ Zoom 화상강의 바로 가기로 입장 . &#49884;&#54744;&#47928;&#51228; &#44277;&#44060;&#48169;&#49885; . - LMS 공지사항을 통하여 시험문제의 URL을 공개 . &#51228;&#52636;&#48169;&#49885; . - LMS의 레포트 메뉴를 활용하여 답안지를 제출 (종료시간 이전에 미리 제출가능) . &#51456;&#48708;&#47932; . - 컴퓨터 및 노트북: 시험지 확인 및 문제풀이 용도 . - 핸드폰: Zoom을 통하여 주변상황을 및 컴퓨터 화면을 촬영하는 용도 . . Note: 중간에 핸드폰 및 노트북이 꺼지지 않도록 배터리 충전기를 준비한다. . &#49884;&#54744;&#51204; &#51456;&#48708;&#49324;&#54637; . - 시험준비시간 동안 핸드폰을 아래와 같이 배치하여 학생의 컴퓨터 화면 및 주변상황이 보이도록 함 . . Note: 적절한 각도를 설정하기 어려운 경우 주변환경보다 컴퓨터의 화면이 잘 보이도록 설정할 것 . - 학생증을 준비하여 시험 시작 직전에 본인의 얼굴과 학생증을 함께 촬영한다. (5초간) . &#50976;&#51032;&#49324;&#54637; . - 줌의 대화명은 이름과 학번을 모두 적는다. (예시: 최규빈_202143052) . . Note: 동명이인이 있을 수 있으므로 학번을 같이 적으세요 . - 질문은 카카오톡 채널 혹은 줌의 채팅기능을 이용한다. . - Zoom에서 스피커 음소거를 하지 않는다. (전체 공지사항등이 있을때 음성으로 공지함) . - 핸드폰으로 Zoom참가 중 전화가 오면 거절하고 받지 않는다. (전화통화시 Zoom연결이 종료되므로 부정행위로 의심할 수 있음) . &#44592;&#53440; &#52280;&#44256;&#49324;&#54637; . - 핸드폰과 피씨를 이용하여 줌에 동시접속할 경우 . 최규빈_202143052_핸드폰 | 최규빈_202143052_컴퓨터 | . 와 같이 기기를 분리하여 적는다. . - 시험문제는 코랩으로 풀어도 무방하며 시험문제를 다운받아 개인 주피터노트북 등으로 풀어도 무방하다. . - 제출형식은 주피터 노트북파일을 권장한다. 하지만 풀이 및 코드를 알아볼 수 있는 어떠한 형식으로 제출하여도 무방하다. (ex: txt, hwp, pdf..) .",
            "url": "https://guebin.github.io/2021IR/2021/11/02/%EC%8B%9C%ED%97%98%EA%B4%80%EB%A0%A8-%EC%95%88%EB%82%B4%EC%82%AC%ED%95%AD.html",
            "relUrl": "/2021/11/02/%EC%8B%9C%ED%97%98%EA%B4%80%EB%A0%A8-%EC%95%88%EB%82%B4%EC%82%AC%ED%95%AD.html",
            "date": " • Nov 2, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "(A3) 중간고사 대비문제",
            "content": "#. R&#51012; &#51060;&#50857;&#54616;&#50668; &#45796;&#51020;&#51012; &#44228;&#49328;&#54616;&#50668;&#46972;. . $2^{-5}+2^{3}$ | . $ sqrt{33}$ | . $ sum_{k=1}^{100} frac{1}{k^2+2k+1}$ | . ... | . #. &#50500;&#47000;&#50752; &#44057;&#51008; &#49688;&#50676;&#51012; &#47564;&#46308;&#50612;&#46972;. . $(1,3,5,...,101)$ | . ... | . #. &#50500;&#47000;&#50752; &#44057;&#51008; &#54632;&#49688;&#47484; &#49440;&#50616;&#54616;&#46972;. $x=1,2,3$ &#50640; &#45824;&#54616;&#50668; &#51452;&#50612;&#51652; &#54632;&#49688;&#51032; &#44208;&#44284;&#44050;&#51012; &#52636;&#47141;&#54616;&#46972;. . $f(x)=x^2$ | . #. &#50500;&#47000;&#51473; &#50739;&#51008;&#44163;&#51008;? . (a) $e^x= sum_{n=0}^{ infty} frac{x^n}{n!}$ . (b) $e^x= 1+x+x^2+x^3+ dots $ . (c) $e^x= 1-(x-1)+(x-1)^2-(x-1)^3+ dots $ . (풀이) . f&lt;-function(x,N){ a&lt;-c() a[1]=x for(n in 2:N) a[n]=a[n-1]*x/n sum(a)+1 } . g&lt;-function(x,N){ a&lt;-c() a[1]=x for(n in 2:N) a[n]=a[n-1]*x sum(a)+1 } . h&lt;-function(x,N){ a&lt;-c() a[1]= -(x-1) for(n in 2:N) a[n]=a[n-1]*(1-x) sum(a)+1 } . x=2 for (k in 5:20) print(c(exp(x)-f(x,k) , exp(x)-g(x,k), exp(x)-h(x,k))) . [1] 0.1223894 -55.6109439 7.3890561 [1] 0.03350054 -119.61094390 6.38905610 [1] 8.103718e-03 -2.476109e+02 7.389056e+00 [1] 1.754512e-03 -5.036109e+02 6.389056e+00 [1] 3.435769e-04 -1.015611e+03 7.389056e+00 [1] 6.138994e-05 -2.039611e+03 6.389056e+00 [1] 1.008322e-05 -4.087611e+03 7.389056e+00 [1] 1.532098e-06 -8.183611e+03 6.389056e+00 [1] 2.165414e-07 -1.637561e+04 7.389056e+00 [1] 2.860474e-08 -3.275961e+04 6.389056e+00 [1] 3.546512e-09 -6.552761e+04 7.389056e+00 [1] 4.142349e-10 -1.310636e+05 6.389056e+00 [1] 4.573142e-11 -2.621356e+05 7.389056e+00 [1] 4.786394e-12 -5.242796e+05 6.389056e+00 [1] 4.760636e-13 -1.048568e+06 7.389056e+00 [1] 4.529710e-14 -2.097144e+06 6.389056e+00 . $x=2$일때: $k$가 커질수록 $exp(x) approx f(x,k)$ 이지만 다른것은 그렇지 않음 | . x=3 for (k in 5:20) print(c(exp(x)-f(x,k) , exp(x)-g(x,k), exp(x)-h(x,k))) . [1] 1.685537 -343.914463 41.085537 [1] 0.6730369 -1072.9144631 -22.9144631 [1] 0.2391084 -3259.9144631 105.0855369 [1] 7.638514e-02 -9.820914e+03 -1.509145e+02 [1] 2.214407e-02 -2.950391e+04 3.610855e+02 [1] 5.871745e-03 -8.855291e+04 -6.629145e+02 [1] 1.433839e-03 -2.656999e+05 1.385086e+03 [1] 3.243623e-04 -7.971409e+05 -2.710914e+03 [1] 6.832928e-05 -2.391464e+06 5.481086e+03 [1] 1.346506e-05 -7.174433e+06 -1.090291e+04 [1] 2.492217e-06 -2.152334e+07 2.186509e+04 [1] 4.348086e-07 -6.457006e+07 -4.367091e+04 [1] 7.173653e-08 -1.937102e+08 8.740109e+04 [1] 1.122453e-08 -5.811307e+08 -1.747429e+05 [1] 1.669996e-09 -1.743392e+09 3.495451e+05 [1] 2.368168e-10 -5.230177e+09 -6.990309e+05 . x=10 for (k in 5:50) print(c(exp(x)-f(x,k) , exp(x)-g(x,k), exp(x)-h(x,k))) . [1] 20548.80 -89084.53 75170.47 [1] 19159.91 -1089084.53 -456270.53 [1] 17175.78 -11089084.53 4326698.47 [1] 14695.62 -111089084.53 -38720022.53 [1] 1.193989e+04 -1.111089e+09 3.487005e+08 [1] 9.184161e+03 -1.111109e+10 -3.138084e+09 [1] 6.678950e+03 -1.111111e+11 2.824298e+10 [1] 4.591274e+03 -1.111111e+12 -2.541866e+11 [1] 2.985370e+03 -1.111111e+13 2.287679e+12 [1] 1.838295e+03 -1.111111e+14 -2.058911e+13 [1] 1.073579e+03 -1.111111e+15 1.853020e+14 [1] 5.956311e+02 -1.111111e+16 -1.667718e+15 [1] 3.144854e+02 -1.111111e+17 1.500946e+16 [1] 1.582933e+02 -1.111111e+18 -1.350852e+17 [1] 7.608695e+01 -1.111111e+19 1.215767e+18 [1] 3.498377e+01 -1.111111e+20 -1.094190e+19 [1] 1.541083e+01 -1.111111e+21 9.847709e+19 [1] 6.514037e+00 -1.111111e+22 -8.862938e+20 [1] 2.645867e+00 -1.111111e+23 7.976644e+21 [1] 1.034129e+00 -1.111111e+24 -7.178980e+22 [1] 3.894339e-01 -1.111111e+25 6.461082e+23 [1] 1.414743e-01 -1.111111e+26 -5.814974e+24 [1] 4.963739e-02 -1.111111e+27 5.233476e+25 [1] 1.683850e-02 -1.111111e+28 -4.710129e+26 [1] 5.528535e-03 -1.111111e+29 4.239116e+27 [1] 1.758548e-03 -1.111111e+30 -3.815204e+28 [1] 5.424228e-04 -1.111111e+31 3.433684e+29 [1] 1.623837e-04 -1.111111e+32 -3.090315e+30 [1] 4.722033e-05 -1.111111e+33 2.781284e+31 [1] 1.334876e-05 -1.111111e+34 -2.503156e+32 [1] 3.671161e-06 -1.111111e+35 2.252840e+33 [1] 9.829419e-07 -1.111111e+36 -2.027556e+34 [1] 2.563938e-07 -1.111111e+37 1.824800e+35 [1] 6.519986e-08 -1.111111e+38 -1.642320e+36 [1] 1.617445e-08 -1.111111e+39 1.478088e+37 [1] 3.918103e-09 -1.111111e+40 -1.330279e+38 [1] 9.276846e-10 -1.111111e+41 1.197252e+39 [1] 2.182787e-10 -1.111111e+42 -1.077526e+40 [1] 5.093170e-11 -1.111111e+43 9.697737e+40 [1] 1.455192e-11 -1.111111e+44 -8.727964e+41 [1] 3.637979e-12 -1.111111e+45 7.855167e+42 [1] 3.637979e-12 -1.111111e+46 -7.069650e+43 [1] 3.637979e-12 -1.111111e+47 6.362685e+44 [1] 3.637979e-12 -1.111111e+48 -5.726417e+45 [1] 3.637979e-12 -1.111111e+49 5.153775e+46 [1] 3.637979e-12 -1.111111e+50 -4.638398e+47 . 답: (a) . #. &#45796;&#51020;&#51012; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. . 다음은 어느 회사의 연봉에 대한 규정이다. . (가) 입사 첫째 해 연봉은 $a$원이고, 입사 19년째 해까지의 연봉은 해마다 직전 연봉에서 8%씩 인상된다. . (나) 입사 20년째 해부터의 연봉은 입사 19년째 해 연봉의 2/3로 한다. . 이 회사에 입사한 사람이 28년동안 근무하여 받는 연봉의 총합은? . #. &#45796;&#51020; &#47928;&#51109;&#51012; &#51069;&#44256; &#52280;&#44144;&#51667;&#51012; &#54032;&#45800;&#54616;&#49884;&#50724;. . _a는 변수이름으로 가능하다. | . ... | . # &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#49884;&#44033;&#54868; &#54616;&#46972;. . 두점 $(1,2)$, $(1.1,2.1)$를 붉은 점으로 각각 시각화 하라. . | 동일한 플랏에 $(-1,-2)$, $(-1.1,-2.1)$을 푸른점으로 각각 시각화 하라. . | . 출력예시 . # &#48380;&#47553;&#44277;&#51032; &#49440;&#53469; . A,B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 합니다. 볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다. 또한 같은 무게의 공이 여러개 있을 수 있지만, 서로 다른 공으로 간주합니다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다. 예를들어 N이 5이고, M이 3이며 각각의 무게가 차례대로 1,3,2,3,2일 때 각 공의 번호가 차례대로 1번부터 5번까지 부여됩니다. 이때 두 사람이 고를 수 있는 볼링공 번호의 조합을 구하면 다음과 같습니다. . (1번,2번), (1번,3번), (1번,4번), (1번,5번), (2번,3번), (2번,5번), (3번,4번), (4번,5번) . 결과적으로 두 사람이 공을 고르는 경우의 수는 8가지입니다. N개의 공의 무게가 각각 주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요. . - 입력예시 . 입력 5 3 1 3 2 3 2 출력 8 .",
            "url": "https://guebin.github.io/2021IR/2021/11/02/(A3)-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%EB%8C%80%EB%B9%84%EB%AC%B8%EC%A0%9C.html",
            "relUrl": "/2021/11/02/(A3)-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%EB%8C%80%EB%B9%84%EB%AC%B8%EC%A0%9C.html",
            "date": " • Nov 2, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "(8주차) 11월2일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) 중간고사 대비 설명 (1) . - (2/4) 중간고사 대비 설명 (2) . - (3/4) 백터/매트릭스의 결합 . - (4/4) 매트릭스 원소선택, 벡터관련 연산, 매트릭스 관련연산, 티블(데이터프레임) . %&gt;% . - tidyverse중 하나의 dplyr의 기능 . library(dplyr) . - 예시1 . f&lt;-function(x) x+2 . f(2) . [1] 4 . 2 %&gt;% f . [1] 4 . - 예시2 . f&lt;-function(x,y) x**2+y . f(2,3) . [1] 7 . 2 %&gt;% f(3) . [1] 7 . 3 %&gt;% f(2) . [1] 11 . - 포인트: 함수의 첫번째 입력이 %&gt;% 의 왼쪽의 결과로 생각한다. . 하나의 입력만 받는 함수라면 함수이름만 쓸 수 있다! | 첫입력을 생략한다는 것이 포인트! | . &#46160; &#44060; &#51060;&#49345;&#51032; &#48289;&#53552;, &#54665;&#47148;&#51012; &#44208;&#54633; . &#48289;&#53552;&#51032; &#44208;&#54633; . - 예제1 . x&lt;-c(1,2,3) y&lt;-c(1,2,3,4) . x . [1] 1 2 3 . y . [1] 1 2 3 4 . c(x,y) . [1] 1 2 3 1 2 3 4 . c(y,x) . [1] 1 2 3 4 1 2 3 . c(x,2,2,2,y) . [1] 1 2 3 2 2 2 1 2 3 4 . c는 사실 결합하라라는 의미를 가짐 | . - 예제2 . x&lt;-c(1,2,3) y&lt;-c(4,4,4) . cbind(x,y) . x y [1,] 1 4 [2,] 2 4 [3,] 3 4 . - 예제2-1 . x&lt;-c(1,2,3,4) y&lt;-c(1,2) cbind(x,y) . x y [1,] 1 1 [2,] 2 2 [3,] 3 1 [4,] 4 2 . - 예제2-2 . x&lt;-c(1,2,3,4) cbind(1,x) . x [1,] 1 1 [2,] 1 2 [3,] 1 3 [4,] 1 4 . - 예제3 . x&lt;-c(1,2,3,4) y&lt;-c(1,2) rbind(x,y) . [,1] [,2] [,3] [,4] x 1 2 3 4 y 1 2 1 2 . - 예제4 . x&lt;-c(1,2,3) y&lt;-c(4,5) . cbind(1,c(x,y)) . [,1] [,2] [1,] 1 1 [2,] 1 2 [3,] 1 3 [4,] 1 4 [5,] 1 5 . &#47588;&#53944;&#47533;&#49828;&#51032; &#44208;&#54633; . - 예제1 . X&lt;-rbind(1:5,6:10) y&lt;-c(1,2) . X . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 . y . [1] 1 2 . cbind(X,y,y,X) . y y [1,] 1 2 3 4 5 1 1 1 2 3 4 5 [2,] 6 7 8 9 10 2 2 6 7 8 9 10 . * 이름을 지우기 위해서는 아래와 같이 하면 된다. . XyyX= cbind(X,y,y,X) colnames(XyyX)= NULL XyyX . [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [1,] 1 2 3 4 5 1 1 1 2 3 4 5 [2,] 6 7 8 9 10 2 2 6 7 8 9 10 . - 예제2 . X&lt;-rbind(1:5,6:10) rbind(X,1) . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 [3,] 1 1 1 1 1 . - 예제3 . X &lt;- rbind(1:5,6:10,1:5) Y &lt;- cbind(1:3,4:6,7:9) . X . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 [3,] 1 2 3 4 5 . Y . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . cbind(X,Y) . [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [1,] 1 2 3 4 5 1 4 7 [2,] 6 7 8 9 10 2 5 8 [3,] 1 2 3 4 5 3 6 9 . rbind(X,Y) . Error in rbind(X, Y): number of columns of matrices must match (see arg 2) Traceback: 1. rbind(X, Y) . 드디어 에러!! | . &#47588;&#53944;&#47533;&#49828; &#50896;&#49548; &#49440;&#53469; . X&lt;-rbind(1:5,6:10,1:5) X . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 [3,] 1 2 3 4 5 . - 예제1 . X[,1] . [1] 1 6 1 . 선택된 것은 자동으로 벡터화 된다. | . x=X[,1] . x . [1] 1 6 1 . dim(x) . NULL . dim(x)&lt;-c(3,1) . x . [,1] [1,] 1 [2,] 6 [3,] 1 . - 예제2 . X[,1:2] . [,1] [,2] [1,] 1 2 [2,] 6 7 [3,] 1 2 . - 예제3 . X[,-1] . [,1] [,2] [,3] [,4] [1,] 2 3 4 5 [2,] 7 8 9 10 [3,] 2 3 4 5 . - 예제4 . X[,-(1:2)] . [,1] [,2] [,3] [1,] 3 4 5 [2,] 8 9 10 [3,] 3 4 5 . - 예제5 . X[1:2,] . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 . - 예제6 . X[1:2,1:3] . [,1] [,2] [,3] [1,] 1 2 3 [2,] 6 7 8 . - 예제7 . X[1:2, -1] . [,1] [,2] [,3] [,4] [1,] 2 3 4 5 [2,] 7 8 9 10 . &#48289;&#53552;&#44288;&#47144; &#50672;&#49328; . - 예제1 . c(1,2,5) %in% c(1,2,3,4) . [1] TRUE TRUE FALSE . - 예제2 . union(c(1,1,2,2),c(2,3,4)) . [1] 1 2 3 4 . - 예제3 . intersect(1:5,2:6) . [1] 2 3 4 5 . - 예제4 . x=1:5 . x %*% x . [,1] [1,] 55 . - 예제5 . x=1:5 . x %o% x . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 2 4 6 8 10 [3,] 3 6 9 12 15 [4,] 4 8 12 16 20 [5,] 5 10 15 20 25 . &#47588;&#53944;&#47533;&#49828; &#44288;&#47144;&#50672;&#49328; . - 예제1: 트랜스포즈 . A=cbind(c(1,2,3),c(4,5,6),c(7,8,9)) . A . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . t(A) . [,1] [,2] [,3] [1,] 1 2 3 [2,] 4 5 6 [3,] 7 8 9 . - 예제2: 상수 곱하기 . A=cbind(c(1,2,3),c(4,5,6),c(7,8,9)) A . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . -A . [,1] [,2] [,3] [1,] -1 -4 -7 [2,] -2 -5 -8 [3,] -3 -6 -9 . A*2 . [,1] [,2] [,3] [1,] 2 8 14 [2,] 4 10 16 [3,] 6 12 18 . - 예제3: 덧셈, 뺄셈 . A=cbind(c(1,2,3),c(4,5,6),c(7,8,9)) B=cbind(1:3,1:3,2:4) . A . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . B . [,1] [,2] [,3] [1,] 1 1 2 [2,] 2 2 3 [3,] 3 3 4 . A+B . [,1] [,2] [,3] [1,] 2 5 9 [2,] 4 7 11 [3,] 6 9 13 . - 예제4: 행렬곱셈 . A=cbind(1:2,2:3) A . [,1] [,2] [1,] 1 2 [2,] 2 3 . A %*% A . [,1] [,2] [1,] 5 8 [2,] 8 13 . - 예제5: 역행렬 . A=rbind(c(0,1),c(2,0)) A . [,1] [,2] [1,] 0 1 [2,] 2 0 . solve(A) . [,1] [,2] [1,] 0 0.5 [2,] 1 0.0 . A %*% solve(A) . [,1] [,2] [1,] 1 0 [2,] 0 1 . &#54000;&#48660; &#47564;&#46300;&#45716; &#48169;&#48277; . - 보통 초보단계에서는 일부러 만들기보다 만들어져 있는 경우가 많아요 . - 벡터로 만들기 . x&lt;-c(1,2,3) y&lt;-c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) . tb=tibble(x=x,y=y) . tb . x y 1 1 a 2 2 b 3 3 c . tb$x . [1] 1 2 3 . tb$y . [1] &#34;a&#34; &#34;b&#34; &#34;c&#34; . - 매트릭스로 만들기 . X=cbind(1:10,31:40) X . [,1] [,2] [1,] 1 31 [2,] 2 32 [3,] 3 33 [4,] 4 34 [5,] 5 35 [6,] 6 36 [7,] 7 37 [8,] 8 38 [9,] 9 39 [10,] 10 40 . tb=as_tibble(X) . tb . V1 V2 1 1 31 2 2 32 3 3 33 4 4 34 5 5 35 6 6 36 7 7 37 8 8 38 9 9 39 10 10 40 . &#54000;&#48660;&#51012; &#50416;&#45716; &#51060;&#50976;? . mutate . tb %&gt;% mutate(V3=V1**2+V2,V4=-V3, V5=V4-1) . V1 V2 V3 V4 V5 1 1 31 32 -32 -33 2 2 32 36 -36 -37 3 3 33 42 -42 -43 4 4 34 50 -50 -51 5 5 35 60 -60 -61 6 6 36 72 -72 -73 7 7 37 86 -86 -87 8 8 38 102 -102 -103 9 9 39 120 -120 -121 10 10 40 140 -140 -141 . 열간의 결합으로 새로운 열을 만들기 편리함 | . tb . V1 V2 1 1 31 2 2 32 3 3 33 4 4 34 5 5 35 6 6 36 7 7 37 8 8 38 9 9 39 10 10 40 . 연산을 해도 원래 데이터 프레임은 변화하지 않음. 변화를 위해서는 아래를 해야함. | . tb &lt;- tb %&gt;% mutate(V3=V1**2+V2,V4=-V3, V5=V4-1) . - 아래와 같은코드임 . mutate(tb, V3=V1**2+V2,V4=-V3, V5=V4-1) . V1 V2 V3 V4 V5 1 1 31 32 -32 -33 2 2 32 36 -36 -37 3 3 33 42 -42 -43 4 4 34 50 -50 -51 5 5 35 60 -60 -61 6 6 36 72 -72 -73 7 7 37 86 -86 -87 8 8 38 102 -102 -103 9 9 39 120 -120 -121 10 10 40 140 -140 -141 . filter . tb2 &lt;- tb %&gt;% mutate(V3=V1**2+V2,V4=-V3, V5=V4-1) . tb2 . V1 V2 V3 V4 V5 1 1 31 32 -32 -33 2 2 32 36 -36 -37 3 3 33 42 -42 -43 4 4 34 50 -50 -51 5 5 35 60 -60 -61 6 6 36 72 -72 -73 7 7 37 86 -86 -87 8 8 38 102 -102 -103 9 9 39 120 -120 -121 10 10 40 140 -140 -141 . tb2 %&gt;% filter(V1&gt;5, V3&lt;100) . V1 V2 V3 V4 V5 1 6 36 72 -72 -73 2 7 37 86 -86 -87 . mutate + filter &#44032;&#45733; . tb . V1 V2 1 1 31 2 2 32 3 3 33 4 4 34 5 5 35 6 6 36 7 7 37 8 8 38 9 9 39 10 10 40 . tb %&gt;% mutate(V3=(V1-mean(V1))/sd(V1)) . V1 V2 V3 1 1 31 -1.4863011 2 2 32 -1.1560120 3 3 33 -0.8257228 4 4 34 -0.4954337 5 5 35 -0.1651446 6 6 36 0.1651446 7 7 37 0.4954337 8 8 38 0.8257228 9 9 39 1.1560120 10 10 40 1.4863011 . tb %&gt;% mutate(V3=(V1-mean(V1))/sd(V1)) %&gt;% filter(V3&gt;0.5) . V1 V2 V3 1 8 38 0.8257228 2 9 39 1.1560120 3 10 40 1.4863011 .",
            "url": "https://guebin.github.io/2021IR/2021/11/02/(8%EC%A3%BC%EC%B0%A8)-11%EC%9B%942%EC%9D%BC.html",
            "relUrl": "/2021/11/02/(8%EC%A3%BC%EC%B0%A8)-11%EC%9B%942%EC%9D%BC.html",
            "date": " • Nov 2, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "(A2) 매트릭스",
            "content": "&#44053;&#51032;&#50689;&#49345; . . &#54665;&#47148;&#44284; &#50672;&#47549;&#51068;&#52264;&#48169;&#51221;&#49885; . - 예를들어 아래와 같은 문제가 있다고 하자. . $ begin{cases} w+2x+3y+4z=1 2w+2x+y=9 x-y=4 3w+x-y+3y=7 end{cases}$ . - 매트릭스 형태로 위의 식을 표현하면 아래와 같다. . $ begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix} begin{bmatrix} w x y z end{bmatrix}= begin{bmatrix} 1 9 4 7 end{bmatrix}$ . - 양변에 . $ begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix}$ . 의 역행렬을 취하면 . $ begin{bmatrix} w x y z end{bmatrix}= begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix}^{-1} begin{bmatrix} 1 9 4 7 end{bmatrix}$ . R&#47196; &#44396;&#54788; . - 방법1 . A=rbind(c(1,2,3,4),c(2,2,1,0),c(0,1,-1,0),c(3,1,-1,3)) A . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 2 2 1 0 [3,] 0 1 -1 0 [4,] 3 1 -1 3 . b=c(1,9,4,7) dim(b)=c(4,1) b . [,1] [1,] 1 [2,] 9 [3,] 4 [4,] 7 . solve(A) %*% b . [,1] [1,] 2 [2,] 3 [3,] -1 [4,] -1 . solve(A): $A^{-1}$ | %*% : 매트릭스의 곱셈을 해주는 연산자. | . 따라서 $(w,x,y,z)=(2,3,-1,-1)$ 이다. . - 방법2 . A=rbind(c(1,2,3,4),c(2,2,1,0),c(0,1,-1,0),c(3,1,-1,3)) A . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 2 2 1 0 [3,] 0 1 -1 0 [4,] 3 1 -1 3 . b=c(1,9,4,7) b . [1] 1 9 4 7 . solve(A)%*%b . [,1] [1,] 2 [2,] 3 [3,] -1 [4,] -1 .",
            "url": "https://guebin.github.io/2021IR/2021/10/29/(A2)-%EB%A7%A4%ED%8A%B8%EB%A6%AD%EC%8A%A4.html",
            "relUrl": "/2021/10/29/(A2)-%EB%A7%A4%ED%8A%B8%EB%A6%AD%EC%8A%A4.html",
            "date": " • Oct 29, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "(8주차) 10월28일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/6) 볼링공 문제풀이 (1) . - (2/6) 볼링공 문제풀이 (2) . - (3/6) 자료형 . - (4/6) 형변환 . - (5/6) 벡터, 매트릭스(1) . - (6/6) 매트릭스 (2) . &#48380;&#47553;&#44277;&#47928;&#51228; (2019 SW&#47560;&#50640;&#49828;&#53944;&#47196; &#51077;&#54617; &#53580;&#49828;&#53944;) . A,B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 합니다. 볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다. 또한 같은 무게의 공이 여러개 있을 수 있지만, 서로 다른 공으로 간주합니다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다. . 예를들어 N이 5이고, M이 3이며 각각의 무게가 차례대로 1,3,2,3,2일 때 각 공의 번호가 차례대로 1번부터 5번까지 부여됩니다. 이때 두 사람이 고를 수 있는 볼링공 번호의 조합을 구하면 다음과 같습니다. . (1번,2번), (1번,3번), (1번,4번), (1번,5번), (2번,3번), (2번,5번), (3번,4번), (4번,5번) . 결과적으로 두 사람이 공을 고르는 경우의 수는 8가지입니다. N개의 공의 무게가 각각 주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요. . 입력예시 | . 입력 5 3 1 3 2 3 2 출력 8 . &#47928;&#51228;&#51032; &#49688;&#54617;&#51201;&#54364;&#54788; . $N$개의 볼링공의 무게를 각각 $x_1, dots,x_N$ 이라고 하자. (단, $x_1, dots, x_N$은 $ {1, dots, M }$사의 자연수의 값을 가지며 서로 같은 값을 가질 수 있다) . 예시 $(a_1, dots, a_5)=(1,3,2,3,2)$ 일 경우 가능한 조합의 집합은 아래와 같다. $(a_1,a_2), (a_1,a_3), (a_1,a_4), (a_1,a_5), (a_2,a_3), (a_2,a_5), (a_3,a_4), (a_4,a_5)$ . &#54400;&#51060;7 . a&lt;-c(1,3,2,3,2) . a1&lt;-a a2&lt;-a . dim(a1)&lt;-c(5,1) dim(a2)&lt;-c(1,5) . a1 . [,1] [1,] 1 [2,] 3 [3,] 2 [4,] 3 [5,] 2 . a2 . [,1] [,2] [,3] [,4] [,5] [1,] 1 3 2 3 2 . a1 %*% a2 . [,1] [,2] [,3] [,4] [,5] [1,] 1 3 2 3 2 [2,] 3 9 6 9 6 [3,] 2 6 4 6 4 [4,] 3 9 6 9 6 [5,] 2 6 4 6 4 . %*% 연산자: 매트릭스의 곱셈을 가능하게 해준다. (중요함) | . A = a1 %*% a2 . A . [,1] [,2] [,3] [,4] [,5] [1,] 1 3 2 3 2 [2,] 3 9 6 9 6 [3,] 2 6 4 6 4 [4,] 3 9 6 9 6 [5,] 2 6 4 6 4 . upper.tri(A) . [,1] [,2] [,3] [,4] [,5] [1,] FALSE TRUE TRUE TRUE TRUE [2,] FALSE FALSE TRUE TRUE TRUE [3,] FALSE FALSE FALSE TRUE TRUE [4,] FALSE FALSE FALSE FALSE TRUE [5,] FALSE FALSE FALSE FALSE FALSE . upper.tri(): 그렇게 중요하진 않음 | . A[upper.tri(A)] . [1] 3 2 6 3 9 6 2 6 4 6 . 매트릭스 인덱싱: 중요함 | . A[upper.tri(A)] %in% c(4,9) . [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE . %in%연산자: 중요함 | . sum(!(A[upper.tri(A)] %in% c(4,9))) . [1] 8 . -- . 보총학습 %in% 연산자 . a_ = c(1,2,3,4,4,4,5,6,7,8,9,9,9) a_ %in% c(4,5,9) # _a의 모든원소를 조사하여, 그 원소가 4 혹은 9 이면 True, 아니면 False . [1] FALSE FALSE FALSE TRUE TRUE TRUE TRUE FALSE FALSE FALSE TRUE TRUE [13] TRUE . &#54400;&#51060;8 . a&lt;-c(1,3,2,3,2) . A=outer(a,a) A . [,1] [,2] [,3] [,4] [,5] [1,] 1 3 2 3 2 [2,] 3 9 6 9 6 [3,] 2 6 4 6 4 [4,] 3 9 6 9 6 [5,] 2 6 4 6 4 . sum(!(A[upper.tri(A)] %in% c(4,9) )) . [1] 8 . sum(!(outer(a,a)[upper.tri(outer(a,a))] %in% a**2 )) . [1] 32 . &#54400;&#51060; 6,7,8 . - 풀이6: 데이터프레임 활용 $ to$ 사용하기 쉽고 확장성이 좋음 . - 풀이7,8: 코드가 간결함 / 에러가 발생할 수 있음 . &#45936;&#51060;&#53552;&#54805; . - R에서 데이터를 구성하는 세가지 기본형 . - 수치형(numeric): 정수, 실수, 지수등을 나타내며 실수가 기본형 . a=345 mode(a) . [1] &#34;numeric&#34; . a=34.4455 mode(a) . [1] &#34;numeric&#34; . - 논리형(logical): 논리적 참과 거짓을 나타낸다. . a=T mode(a) . [1] &#34;logical&#34; . a=TRUE mode(a) . [1] &#34;logical&#34; . a=F mode(a) . [1] &#34;logical&#34; . a=FALSE mode(a) . [1] &#34;logical&#34; . - 문자형 . a=&#39;asdf&#39; mode(a) . [1] &#34;character&#34; . a=&#39;TRUE&#39; mode(a) . [1] &#34;character&#34; . a=&#39;1&#39; mode(a) . [1] &#34;character&#34; . - 참고: storgae.mode() . a=pi a . [1] 3.141593 . mode(a) . [1] &#34;numeric&#34; . storage.mode(a) . [1] &#34;double&#34; . a=1:2 a . [1] 1 2 . storage.mode(a) . [1] &#34;integer&#34; . &#54805; &#48320;&#54872; . &#48169;&#48277;1 . a=&quot;331&quot; mode(a) . [1] &#34;character&#34; . - 이것을 수치형으로 바꾸고 싶다. . mode(a) . [1] &#34;character&#34; . 결과가 &quot;character&quot;이 아니라 &quot;numeric&quot;으로 나오면 좋겠다. . mode(a)&lt;-&quot;numeric&quot; . mode(a) . [1] &#34;numeric&#34; . a . [1] 331 . &#48169;&#48277;2 . a=&quot;331&quot; mode(a) . [1] &#34;character&#34; . a . [1] 331 . as.numeric(a) . [1] 331 . a=as.numeric(a) a . [1] 331 . &#50696;&#51228;1: logical -&gt; numeric . a=F . as.numeric(a) . [1] 0 . &#50696;&#51228;2: numeric -&gt; logical . a=1 as.logical(a) . [1] TRUE . a=0 as.logical(a) . [1] FALSE . - 그런데 0,1 이외의 숫자를 바꾸면 어떻게 되는가? . a= -1 as.logical(a) . [1] TRUE . a= 2 as.logical(a) . [1] TRUE . a= 2.222 as.logical(a) . [1] TRUE . &#50696;&#51228;3 . a=&#39;asdfasdfasdf&#39; a=as.numeric(a) . Warning message in eval(expr, envir, enclos): “NAs introduced by coercion” . mode(a) . [1] &#34;numeric&#34; . a=&#39;asdfasdfasdf&#39; a=as.logical(a) . mode(a) . [1] &#34;logical&#34; . mode&#44032; &#49436;&#47196; &#45796;&#47480; &#50896;&#49548;&#47196; &#51060;&#47336;&#50612;&#51652; &#48289;&#53552;&#44032; &#51080;&#45796;&#47732;, &#51060; &#48289;&#53552;&#51032; mode&#45716; &#47924;&#50631;&#51068;&#44620;? . - 예시1 . a&lt;-c(1,T,&#39;1&#39;) a . [1] &#34;1&#34; &#34;TRUE&#34; &#34;1&#34; . mode(a) . [1] &#34;character&#34; . - 예시2 . a&lt;-c(1,T) a . [1] 1 1 . mode(a) . [1] &#34;numeric&#34; . - 결국 mode가 서로 다른 원소로 이루어진 벡터는 없다. . - 서로 다른 기본형을 가지는 원소로 벡터를 만들게 된다면 한가지 형으로 자동 형 변환이 된다. . &#54665;&#47148; . - 행렬도 벡터와 같이 동일한 형의 원소로 구성된다. . - 행렬의 속성 . A=cbind(c(1,2,3,4),c(4,5,6,7),c(2,3,4,1)) A . [,1] [,2] [,3] [1,] 1 4 2 [2,] 2 5 3 [3,] 3 6 4 [4,] 4 7 1 . length(A) . [1] 12 . mode(A) . [1] &#34;numeric&#34; . dim(A) . [1] 4 3 . dimnames(A) . NULL . - 지금은 이름이 없지만 아래와 같이 이름이 있는 경우도 있다. . x=c(1,2,3,4) y=c(2,2,3,4) z=c(3,2,3,4) A=cbind(x,y,z) A . x y z [1,] 1 2 3 [2,] 2 2 2 [3,] 3 3 3 [4,] 4 4 4 . a=T mode(a)&lt;-&quot;character&quot; . dimnames(A) . [[1]] NULL [[2]] [1] &#34;x&#34; &#34;y&#34; &#34;z&#34; . A=rbind(x,y,z) A . [,1] [,2] [,3] [,4] x 1 2 3 4 y 2 2 3 4 z 3 2 3 4 . dimnames(A) . [[1]] [1] &#34;x&#34; &#34;y&#34; &#34;z&#34; [[2]] NULL . &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46300;&#45716; &#48169;&#48277;1: matrix &#54632;&#49688;&#47484; &#51060;&#50857;&#54616;&#45716; &#48169;&#48277; . - 예제1 . matrix(1:12,ncol=2) . [,1] [,2] [1,] 1 7 [2,] 2 8 [3,] 3 9 [4,] 4 10 [5,] 5 11 [6,] 6 12 . - 예제2 . matrix(1:12,ncol=3) . [,1] [,2] [,3] [1,] 1 5 9 [2,] 2 6 10 [3,] 3 7 11 [4,] 4 8 12 . - 예제3 . matrix(1:12,nrow=1) . [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [1,] 1 2 3 4 5 6 7 8 9 10 11 12 . - 예제4 . matrix(1:12,nrow=2) . [,1] [,2] [,3] [,4] [,5] [,6] [1,] 1 3 5 7 9 11 [2,] 2 4 6 8 10 12 . - 예제5 . matrix(1:12,ncol=2,byrow=T) . [,1] [,2] [1,] 1 2 [2,] 3 4 [3,] 5 6 [4,] 7 8 [5,] 9 10 [6,] 11 12 . - 예제6 . matrix(1:12) . [,1] [1,] 1 [2,] 2 [3,] 3 [4,] 4 [5,] 5 [6,] 6 [7,] 7 [8,] 8 [9,] 9 [10,] 10 [11,] 11 [12,] 12 . &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46300;&#45716; &#48169;&#48277;2: rbind &#54632;&#49688;&#47484; &#51060;&#50857;&#54616;&#45716; &#48169;&#48277; . - 예제1 . rbind(1:6,rep(c(1,2),3)) . [,1] [,2] [,3] [,4] [,5] [,6] [1,] 1 2 3 4 5 6 [2,] 1 2 1 2 1 2 . - 예제2 . rbind(1:5,5:1,1:3) . Warning message in rbind(1:5, 5:1, 1:3): “number of columns of result is not a multiple of vector length (arg 3)” . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 5 4 3 2 1 [3,] 1 2 3 1 2 . - 예제3 . rbind(1:4,4:1,1:2) . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 4 3 2 1 [3,] 1 2 1 2 . - 예제4 . rbind(&quot;row1&quot;=1:4,&quot;row2&quot;=4:1,&quot;row3&quot;=1:2) . [,1] [,2] [,3] [,4] row1 1 2 3 4 row2 4 3 2 1 row3 1 2 1 2 . &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46300;&#45716; &#48169;&#48277;3: cbind &#54632;&#49688;&#47484; &#51060;&#50857;&#54616;&#45716; &#48169;&#48277; . - 예제1 . cbind(1:5,5:1,1:3) . Warning message in cbind(1:5, 5:1, 1:3): “number of rows of result is not a multiple of vector length (arg 3)” . [,1] [,2] [,3] [1,] 1 5 1 [2,] 2 4 2 [3,] 3 3 3 [4,] 4 2 1 [5,] 5 1 2 . - 예제2 . cbind(&quot;col1&quot;=1:6,&quot;col2&quot;=6:1,&quot;col3&quot;=1:3) . col1 col2 col3 [1,] 1 6 1 [2,] 2 5 2 [3,] 3 4 3 [4,] 4 3 1 [5,] 5 2 2 [6,] 6 1 3 . &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46300;&#45716; &#48169;&#48277;4: dim &#54632;&#49688;&#47484; &#51060;&#50857;&#54616;&#45716; &#48169;&#48277; . - 예시1 . mat= 1:6 . dim(mat) . NULL . dim(mat)&lt;-c(2,3) . dim(mat) . [1] 2 3 . mat . [,1] [,2] [,3] [1,] 1 3 5 [2,] 2 4 6 . - 참고: 동일한 문법논리를 사용해서 이미 만들어진 매트릭스를 벡터로 바꾸는 것도 가능하다. . dim(mat)&lt;- NULL . dim(mat) . NULL . mat . [1] 1 2 3 4 5 6 . &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46300;&#45716; &#48169;&#48277;5: array&#54632;&#49688;&#47484; &#51060;&#50857;&#54616;&#45716; &#48169;&#48277; . - 예시1 . array(1:12,dim=c(6,2)) . [,1] [,2] [1,] 1 7 [2,] 2 8 [3,] 3 9 [4,] 4 10 [5,] 5 11 [6,] 6 12 . - 예시2 . array(1:12,dim=c(3,4)) . [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 . - 예시3 . array(1:2,dim=c(3,4)) . [,1] [,2] [,3] [,4] [1,] 1 2 1 2 [2,] 2 1 2 1 [3,] 1 2 1 2 . - 예시4 (이건 매트릭스가 아니다!) . array(1:2,dim=c(3,4,2)) . , , 1 [,1] [,2] [,3] [,4] [1,] 1 2 1 2 [2,] 2 1 2 1 [3,] 1 2 1 2 , , 2 [,1] [,2] [,3] [,4] [1,] 1 2 1 2 [2,] 2 1 2 1 [3,] 1 2 1 2 . - 예시5 (이건 매트릭스가 아니다!) . array(1:2,dim=6) . [1] 1 2 1 2 1 2 . &#48176;&#50676; (array) . - 배열은 동일한 형의 원소를 p개의 차원으로 구성한 데이터 객체이다. . - 행렬은 2차원배열의 일종이다. $p=2$ . - 배열을 선언하는 예시 . array(1:2,dim=c(3,4,2)) . , , 1 [,1] [,2] [,3] [,4] [1,] 1 2 1 2 [2,] 2 1 2 1 [3,] 1 2 1 2 , , 2 [,1] [,2] [,3] [,4] [1,] 1 2 1 2 [2,] 2 1 2 1 [3,] 1 2 1 2 . &#49689;&#51228; . 아래와 같은 메트릭스를 만들고 . $A= begin{bmatrix} 1 &amp; 2 &amp; 3 4 &amp; 5 &amp; 6 7 &amp; 8&amp; 9 end{bmatrix}$ . $B= begin{bmatrix} -1 &amp; -2 &amp; -3 -4 &amp; -5 &amp; -6 -7 &amp; -8 &amp; -10 end{bmatrix}$ . $A+B$를 계산하라. . A=asdf B=asdf A+B .",
            "url": "https://guebin.github.io/2021IR/2021/10/28/(8%EC%A3%BC%EC%B0%A8)-10%EC%9B%9428%EC%9D%BC.html",
            "relUrl": "/2021/10/28/(8%EC%A3%BC%EC%B0%A8)-10%EC%9B%9428%EC%9D%BC.html",
            "date": " • Oct 28, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "(7주차) 10월26일",
            "content": ". - (1/5) 볼링공 문제풀이 (1) . - (2/5) 볼링공 문제풀이 (2) . - (3/5) 볼링공 문제풀이 (3) . - (4/5) 볼링공 문제풀이 (4) . - (5/5) 과제설명 . &#48380;&#47553;&#44277;&#47928;&#51228; (2019 SW&#47560;&#50640;&#49828;&#53944;&#47196; &#51077;&#54617; &#53580;&#49828;&#53944;) . A,B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 합니다. 볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다. 또한 같은 무게의 공이 여러개 있을 수 있지만, 서로 다른 공으로 간주합니다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다. . 예를들어 N이 5이고, M이 3이며 각각의 무게가 차례대로 1,3,2,3,2일 때 각 공의 번호가 차례대로 1번부터 5번까지 부여됩니다. 이때 두 사람이 고를 수 있는 볼링공 번호의 조합을 구하면 다음과 같습니다. . (1번,2번), (1번,3번), (1번,4번), (1번,5번), (2번,3번), (2번,5번), (3번,4번), (4번,5번) . 결과적으로 두 사람이 공을 고르는 경우의 수는 8가지입니다. N개의 공의 무게가 각각 주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요. . 입력예시 | . 입력 5 3 1 3 2 3 2 출력 8 . &#47928;&#51228;&#51032; &#49688;&#54617;&#51201;&#54364;&#54788; . $N$개의 볼링공의 무게를 각각 $x_1, dots,x_N$ 이라고 하자. (단, $x_1, dots, x_N$은 $ {1, dots, M }$사의 자연수의 값을 가지며 서로 같은 값을 가질 수 있다) . 예시 $(a_1, dots, a_5)=(1,3,2,3,2)$ 일 경우 가능한 조합의 집합은 아래와 같다. $(a_1,a_2), (a_1,a_3), (a_1,a_4), (a_1,a_5), (a_2,a_3), (a_2,a_5), (a_3,a_4), (a_4,a_5)$ . &#54400;&#51060;1 . a=c(1,3,2,3,2) . a . [1] 1 3 2 3 2 . count=0 for (i in 1:5){ for (j in 1:5){ if(a[i]!=a[j]) count=count+1 } } count . [1] 16 . 중복이 계산이 되어서 16이라는 값이 나왔다. (원래는 8이 나와야 한다.) | . - 아래와 같이 수정하면 된다. . count=0 for (i in 1:5){ for (j in 1:5){ if ((a[i]!=a[j]) &amp; (j&gt;i)) count=count+1 } } count . [1] 8 . &#54400;&#51060;2 . - ((a[i]!=a[j]) &amp; (j&gt;i)) 에서 (j&gt;i) 는 for문 선언부에서 처리할 수 있다. . count=0 for (i in 1:5){ for (j in i:5){ if (a[i]!=a[j]) count=count+1 } } count . [1] 8 . &#54400;&#51060;3 . a=c(1,3,2,3,2) A=rep(0,25*2) dim(A)=c(25,2) A . [,1] [,2] [1,] 0 0 [2,] 0 0 [3,] 0 0 [4,] 0 0 [5,] 0 0 [6,] 0 0 [7,] 0 0 [8,] 0 0 [9,] 0 0 [10,] 0 0 [11,] 0 0 [12,] 0 0 [13,] 0 0 [14,] 0 0 [15,] 0 0 [16,] 0 0 [17,] 0 0 [18,] 0 0 [19,] 0 0 [20,] 0 0 [21,] 0 0 [22,] 0 0 [23,] 0 0 [24,] 0 0 [25,] 0 0 . k=1 for (i in 1:5){ for (j in 1:5){ A[k,]&lt;- c(a[i],a[j]) k=k+1 } } . A . [,1] [,2] [1,] 1 1 [2,] 1 3 [3,] 1 2 [4,] 1 3 [5,] 1 2 [6,] 3 1 [7,] 3 3 [8,] 3 2 [9,] 3 3 [10,] 3 2 [11,] 2 1 [12,] 2 3 [13,] 2 2 [14,] 2 3 [15,] 2 2 [16,] 3 1 [17,] 3 3 [18,] 3 2 [19,] 3 3 [20,] 3 2 [21,] 2 1 [22,] 2 3 [23,] 2 2 [24,] 2 3 [25,] 2 2 . - (1) 무게가 같은 것을 뽑지 않고 (2) 중복되는 경우를 제외 . 중복되는 경우를 제외한다는 말은 1번공-2번공 뽑는 경우와 2번공-1번공을 뽑는경우중 하나만 고려한다는 것을 의미 | . vec1&lt;-c() vec2&lt;-c() for(i in 1:25){ vec1[i] &lt;- A[i,1] != A[i,2] vec2[i] &lt;- A[i,1] &gt; A[i,2] } . vec1 . [1] FALSE TRUE TRUE TRUE TRUE TRUE FALSE TRUE FALSE TRUE TRUE TRUE [13] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE TRUE TRUE FALSE TRUE [25] FALSE . vec2 . [1] FALSE FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE TRUE TRUE FALSE [13] FALSE FALSE FALSE TRUE FALSE TRUE FALSE TRUE TRUE FALSE FALSE FALSE [25] FALSE . sum(vec1 &amp; vec2) . [1] 8 . &#54400;&#51060;4 . - vec1, vec2를 굳이 for문으로 구할필요가 없을것 같다. . a=c(1,3,2,3,2) A=rep(0,25*2) dim(A)=c(25,2) k=1 for (i in 1:5){ for (j in 1:5){ A[k,]&lt;- c(a[i],a[j]) k=k+1 } } . A . [,1] [,2] [1,] 1 1 [2,] 1 3 [3,] 1 2 [4,] 1 3 [5,] 1 2 [6,] 3 1 [7,] 3 3 [8,] 3 2 [9,] 3 3 [10,] 3 2 [11,] 2 1 [12,] 2 3 [13,] 2 2 [14,] 2 3 [15,] 2 2 [16,] 3 1 [17,] 3 3 [18,] 3 2 [19,] 3 3 [20,] 3 2 [21,] 2 1 [22,] 2 3 [23,] 2 2 [24,] 2 3 [25,] 2 2 . vec1&lt;- A[,1]!=A[,2] . vec2&lt;- A[,1]&gt;A[,2] . sum(vec1&amp;vec2) . [1] 8 . &#54400;&#51060;5 . - 생각해보니까 단순히 첫번째 열이 두번쨰 열보다 큰지만 체크해도 된다. . a=c(1,3,2,3,2) A=rep(0,25*2) dim(A)=c(25,2) k=1 for (i in 1:5){ for (j in 1:5){ A[k,]&lt;- c(a[i],a[j]) k=k+1 } } . sum(A[,1]&gt;A[,2]) . [1] 8 . &#54788;&#51116;&#44620;&#51648;&#51032; &#54400;&#51060;&#51221;&#47532; . - 풀이1-2: 매트릭스를 사용하지 않음. . - 풀이3-5: 매트릭스를 사용함. . - 현재까지는 풀이2가 가장 간결하고 루프도 적게돌아간다. 하지만 가장 중요한 일은 틀리지 않는 것인데 풀이2는 틀리기 쉬움 . - 하지만 풀이2와 같은 접근법은 디버깅이 어렵다. $ to$ 예외사항을 처리하기 어려움. . - 특히 삼성에서 실시하는 코딩테스트 문제의 경우 예외사항을 잘 처리해야 하는 문제가 주로 출제된다고 한다. . &#54400;&#51060;6 . - 사실 A를 구해주는 함수가 R에 존재함. . a=c(1,3,2,3,2) A=expand.grid(a,a) A . Var1 Var2 1 1 1 2 3 1 3 2 1 4 3 1 5 2 1 6 1 3 7 3 3 8 2 3 9 3 3 10 2 3 11 1 2 12 3 2 13 2 2 14 3 2 15 2 2 16 1 3 17 3 3 18 2 3 19 3 3 20 2 3 21 1 2 22 3 2 23 2 2 24 3 2 25 2 2 . expand.grid(): 벡터를 입렵으로 받아서 그 벡터의 원소가 만들어내는 순서쌍 조합을 데이터프레임 형태로 리턴함 | 데이터프레임 | . library(tidyverse) . ── Attaching packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse 1.3.1 ── ✔ ggplot2 3.3.5 ✔ purrr 0.3.4 ✔ tibble 3.1.5 ✔ dplyr 1.0.7 ✔ tidyr 1.1.4 ✔ stringr 1.4.0 ✔ readr 2.0.2 ✔ forcats 0.5.1 ── Conflicts ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ✖ dplyr::filter() masks stats::filter() ✖ dplyr::lag() masks stats::lag() . A %&gt;% mutate(C= Var1&gt; Var2) . Var1 Var2 C 1 1 1 FALSE 2 3 1 TRUE 3 2 1 TRUE 4 3 1 TRUE 5 2 1 TRUE 6 1 3 FALSE 7 3 3 FALSE 8 2 3 FALSE 9 3 3 FALSE 10 2 3 FALSE 11 1 2 FALSE 12 3 2 TRUE 13 2 2 FALSE 14 3 2 TRUE 15 2 2 FALSE 16 1 3 FALSE 17 3 3 FALSE 18 2 3 FALSE 19 3 3 FALSE 20 2 3 FALSE 21 1 2 FALSE 22 3 2 TRUE 23 2 2 FALSE 24 3 2 TRUE 25 2 2 FALSE . mutate(): 데이터프레임에서 새로운 column을 추가하는 기능 (기존의 컬럼을 활용하여 새로운 파생되는 칼럼을 쉽게 만들 수 있다) | . A %&gt;% mutate(C= Var1&gt; Var2) %&gt;% filter(C == TRUE) . Var1 Var2 C 1 3 1 TRUE 2 2 1 TRUE 3 3 1 TRUE 4 2 1 TRUE 5 3 2 TRUE 6 3 2 TRUE 7 3 2 TRUE 8 3 2 TRUE . filter(): 데이터프레임에서 특정조건을 만족하는 행을 필터링 하는 기능 | . A %&gt;% mutate(C= Var1&gt; Var2) %&gt;% filter(C == TRUE) %&gt;% count . n 1 8 . count(): 데이터프레임의 행의 숫자를 세어주는 기능 | . - 결과가 데이터프레임으로 나옴 $ to$ 숫자가 하나인데 굳이 데이터프레임이 자료형일 이유는 없음 (다루기 불편) . A %&gt;% mutate(C= Var1&gt; Var2) %&gt;% filter(C == TRUE) %&gt;% count -&gt; rslt . rslt+20 . n 1 28 . 1:8 . [1] 1 2 3 4 5 6 7 8 . 1:rslt . Error in 1:rslt: NA/NaN argument Traceback: . - 숫자로 만들기 위해서 as.numeric() 함수를 사용하면 된다. . as.numeric(rslt) . [1] 8 . A %&gt;% mutate(C= Var1&gt; Var2) %&gt;% filter(C == TRUE) %&gt;% count %&gt;% as.numeric . [1] 8 . &#49689;&#51228; . A %&gt;% mutate(C= Var1 -Var2) . Var1 Var2 C 1 1 1 0 2 3 1 2 3 2 1 1 4 3 1 2 5 2 1 1 6 1 3 -2 7 3 3 0 8 2 3 -1 9 3 3 0 10 2 3 -1 11 1 2 -1 12 3 2 1 13 2 2 0 14 3 2 1 15 2 2 0 16 1 3 -2 17 3 3 0 18 2 3 -1 19 3 3 0 20 2 3 -1 21 1 2 -1 22 3 2 1 23 2 2 0 24 3 2 1 25 2 2 0 .",
            "url": "https://guebin.github.io/2021IR/2021/10/26/(7%EC%A3%BC%EC%B0%A8)-10%EC%9B%9426%EC%9D%BC.html",
            "relUrl": "/2021/10/26/(7%EC%A3%BC%EC%B0%A8)-10%EC%9B%9426%EC%9D%BC.html",
            "date": " • Oct 26, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "(7주차) 10월22일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) 프로그래밍의 중요성 . - (2/4) 숫자 카드 게임 apply함수를 이용한 풀이, 매트릭스 선언방법, 매트릭스에서 원소를 추출하는 방법 . - (3/4) 매트릭스를 사용할시 얻는 이점, apply함수 사용법 (1) . - (4/4) apply함수 사용법 (2), for와 apply코드시간비교, 과제설명 . &#49707;&#51088; &#52852;&#46300; &#44172;&#51076; (2019 &#44397;&#44032; &#44368;&#50977;&#44592;&#44288; &#53076;&#46377;&#53580;&#49828;&#53944;) . 숫자 카드 게임은 여러개의 숫자중에서 가장 높은 숫자가 쓰인 카드를 한장 뽑는 게임이다. . 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다. . 숫자가 쓰인 카드들이 N$ times$M 형태로 놓여 있다. | 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다. | 그 다음 선택된 행에 포함된 카드들 중에서 가장 숫자가 낮은 카드를 뽑아야 한다. | 따라서 처음에 카드를 골라낼 행을 선택할때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다. | . - 예시1 . 입력 3 1 2 4 1 4 2 2 2 출력 2 . - 예시2 . 입력 7 3 1 8 3 3 3 4 출력 3 . &#49689;&#51228; . 입력구조가 . 3 4 5 1 7 7 7 2 8 1 8 2 3 3 4 5 . 와 같을 때 출력을 구하는 코드를 작성하시오. . (숙제풀이) . library(tidyverse) . ── Attaching packages ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse 1.3.1 ── ✔ ggplot2 3.3.5 ✔ purrr 0.3.4 ✔ tibble 3.1.3 ✔ dplyr 1.0.7 ✔ tidyr 1.1.3 ✔ stringr 1.4.0 ✔ readr 1.4.0 ✔ forcats 0.5.1 ── Conflicts ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ✖ dplyr::filter() masks stats::filter() ✖ dplyr::lag() masks stats::lag() . A=rbind(c(3,4,5,1),c(7,7,7,2),c(8,1,8,2),c(3,3,4,5)) A . [,1] [,2] [,3] [,4] [1,] 3 4 5 1 [2,] 7 7 7 2 [3,] 8 1 8 2 [4,] 3 3 4 5 . step1 apply 함수를 사용하여 각 row의 min을 구한다. . apply(A,1,min) # A=입력매트릭스, 1=입력매트릭스의 각 row에 어떠한 함수를 적용 . [1] 1 2 1 3 . A %&gt;% apply(1,min) . [1] 1 2 1 3 . step2. step1의 결과에 max를 취한다. . max(apply(A,1,min)) . [1] 3 . A %&gt;% apply(1,min) %&gt;% max . [1] 3 . &#52852;&#46300;&#48977;&#44592; &#54400;&#51060;&#50640;&#49436; &#50864;&#47532;&#44032; &#50619;&#51012;&#47564;&#54620; &#54532;&#47196;&#44536;&#47000;&#48141; &#47928;&#48277;&#46308; . &#47588;&#53944;&#47533;&#49828;&#47484; &#49440;&#50616;&#54616;&#45716; &#48169;&#48277; . - 방법1: 벡터를 만들고, 그것을 row-vector로 해석한뒤 $ to$ bind . rbind(c(1,2,3,4),c(2,3,4,5)) . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 2 3 4 5 . - 방법2: 벡터를 만들고, 그것을 col-vector로 해석한뒤 $ to$ bind . cbind(c(1,2,3,4),c(2,2,3,4)) . [,1] [,2] [1,] 1 2 [2,] 2 2 [3,] 3 3 [4,] 4 4 . 참고: 만들어진 매트릭스의 차원을 살펴보는 방법 . A=rbind(c(1,2,3,4),c(2,3,4,5)) . dim(A) . [1] 2 4 . A=cbind(c(1,2,3,4),c(2,2,3,4)) . dim(A) . [1] 4 2 . - 방법3: 벡터를 선언하고 dim()을 이용하여 차원을 강제셋팅 . A = 1:8 . A . [1] 1 2 3 4 5 6 7 8 . dim(A) . NULL . dim(A) &lt;- c(2,4) . dim(A) . [1] 2 4 . A . [,1] [,2] [,3] [,4] [1,] 1 3 5 7 [2,] 2 4 6 8 . dim(A) &lt;- c(4,2) . A . [,1] [,2] [1,] 1 5 [2,] 2 6 [3,] 3 7 [4,] 4 8 . dim(A) &lt;- c(3,3) . Error in dim(A) &lt;- c(3, 3): dims [product 9] do not match the length of object [8] Traceback: . - 일단 이정도 까지만.. . &#47588;&#53944;&#47533;&#49828;&#51032; &#50896;&#49548;&#47484; &#48977;&#45716; &#48169;&#48277; . - 아래와 같은 매트릭스가 있다고 하자. . A=rbind(c(1,2,3,4),c(5,6,7,8),c(9,10,11,12)) A . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 [3,] 9 10 11 12 . - 1열을 뽑고싶다. . A[,1] . [1] 1 5 9 . - 1열,4열을 뽑고싶다. . A[,c(1,4)] . [,1] [,2] [1,] 1 4 [2,] 5 8 [3,] 9 12 . - 2행을 뽑고싶다. . A[2,] . [1] 5 6 7 8 . - 1행과 2행을 뽑고싶다. . A[c(1,2),] . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 . - 2행3열의 원소를 뽑고싶다. 즉 (2,3)의 위치에 있는 원소를 뽑고싶다. . A[2,3] . [1] 7 . - 일단 이정도만.. . &#47588;&#53944;&#47533;&#49828;&#47484; &#50780; &#50024;&#50556;&#54616;&#45716;&#44032;? . - 바둑판구조의 자료형을 표현하기 위해서 = 자료를 바둑판 구조로 저장하기 위해서 . - 자료를 바둑판(2d-array), 나아가 큐브형태(3d-array)로 저장하면 어떠한 이점이 있는가? . - 자료를 벡터(1d-array)로 저장하면 어떠한 이점이 있는가? 와 같은 질문 . 프로그래밍 구조상의 이점 | 계산상의 이점 | . (예시) 초항이 1이고 공차가 2인 등차수열을 100개 만들어라. . (풀이1) . a&lt;-c() for (n in 1:100) a[n] = 2*n-1 a . [1] 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 [19] 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 [37] 73 75 77 79 81 83 85 87 89 91 93 95 97 99 101 103 105 107 [55] 109 111 113 115 117 119 121 123 125 127 129 131 133 135 137 139 141 143 [73] 145 147 149 151 153 155 157 159 161 163 165 167 169 171 173 175 177 179 [91] 181 183 185 187 189 191 193 195 197 199 . 위와 같은 간단한 코드도 결국 벡터형태로 자료를 저장하고 관리하기 때문에 for를 쓸 수 있는것임 . (풀이2) . n=1:100 2*n-1 . [1] 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 [19] 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 [37] 73 75 77 79 81 83 85 87 89 91 93 95 97 99 101 103 105 107 [55] 109 111 113 115 117 119 121 123 125 127 129 131 133 135 137 139 141 143 [73] 145 147 149 151 153 155 157 159 161 163 165 167 169 171 173 175 177 179 [91] 181 183 185 187 189 191 193 195 197 199 . 이것역시 벡터의 개념이 있기 때문에 가능함 . - 자료를 벡터로 관리하면 어떠한 이점이 생기듯이 자료를 매트릭스로 관리해도 이점이 생긴다. . apply &#54632;&#49688; . - 우선 아래를 기억하자. . apply(매트릭스,1,특정함수) . 를 쓰면 어떠한 특정함수가 각각의 row에 적용되어서 결과가 array로 저장된다. . - 여기에서 특정함수는 &quot;벡터입력-스칼라출력&quot; 이라 생각하자. 즉 벡터입력-스칼라출력인 함수만 apply가 가능하다고 생각하자. (사실 그렇지는 않음) 예를들면 아래와 같다. . sum(c(1,2,3,4)) . [1] 10 . mean(c(1,2,3,4)) . [1] 2.5 . - 아래와 같은 함수는 벡터입력-벡터출력 이므로 조건에 해당하지 않는다. . sqrt(c(1,2,3,4)) . [1] 1.000000 1.414214 1.732051 2.000000 . - 이제 매트릭스 A에 다양한 함수를 적용해보자. . A . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 [3,] 9 10 11 12 . apply(A,1,sum) . [1] 10 26 42 . apply(A,1,mean) . [1] 2.5 6.5 10.5 . apply(A,1,min) . [1] 1 5 9 . apply(A,1,max) . [1] 4 8 12 . 사용자가 임의로 정의한 함수도 가능하다. . f = function(a) (min(a)+1)**2-3 . apply(A,1,f) . [1] 1 33 97 . - 숫자1을 2로 바꾸면 특정함수가 각각의 col에 적용되어서 결과가 array로 저장된다. . A . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 [3,] 9 10 11 12 . apply(A,2,sum) . [1] 15 18 21 24 . apply(A,2,mean) . [1] 5 6 7 8 . apply(A,2,min) . [1] 1 2 3 4 . apply(A,2,max) . [1] 9 10 11 12 . apply(A,2,f) . [1] 1 6 13 22 . %&gt;% &#50672;&#49328;&#51088; ($ star star star$) . . Note: 진짜 중요한 문법입니다. 너무편해요. . - 아래는 같은코드이다. . sum(1:10) . [1] 55 . 1:10 %&gt;% sum() . [1] 55 . 1:10 %&gt;% sum . [1] 55 . - 아래와 같이 2개의 입력을 받는 함수를 생각하자. . myfun = function(x,y) x**2+y . myfun(2,3) . [1] 7 . - 아래는 같은코드이다. . myfun(2,3) . [1] 7 . 2 %&gt;% myfun(3) . [1] 7 . - 동일한 논리로 아래도 같은코드이다. . myfun(3,2) . [1] 11 . 3 %&gt;% myfun(2) . [1] 11 . - 입력이 3개인 함수를 만들자. . myfun2= function(x,y,z) x**2 + y*z . - 아래는 같은코드이다. . myfun2(2,1,1) . [1] 5 . 2 %&gt;% myfun2(1,1) . [1] 5 . - 왜 이러한 일을 해야하는가? (합성함수 처리에 유리) . 2:5 %&gt;% log %&gt;% sqrt %&gt;% sum %&gt;% myfun2(1,1) %&gt;% sqrt . [1] 4.440805 . sqrt(myfun2(sum(sqrt(log(2:5))),1,1)) . [1] 4.440805 . 2:5 %&gt;% log %&gt;% myfun(3) %&gt;% sqrt %&gt;% sum %&gt;% myfun2(1,1) %&gt;% sqrt . [1] 8.558202 . sqrt(myfun2(sum(sqrt(myfun(log(2:5),3))),1,1)) . [1] 8.558202 . - 아래의 개념차이 . $g(h(f(x)))$ | $x to f to h to g$ | . &#49884;&#44036;&#48708;&#44368; . - 시간비교하는 방법 . t1=Sys.time() . t2=Sys.time() . t2-t1 . Time difference of 4.949846 secs . - 큰 매트릭스 만듬 . A=sample(1:9,size=100*2000000,replace=TRUE) . dim(A)&lt;-c(2000000,100) A . [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [1,] 4 5 1 3 4 3 7 9 2 3 ⋯ 2 7 [2,] 8 2 6 9 9 9 7 2 5 5 ⋯ 7 4 [3,] 6 9 2 6 5 8 2 3 6 7 ⋯ 7 4 [4,] 5 8 2 4 6 3 6 8 1 8 ⋯ 3 7 [5,] 5 2 6 2 1 6 5 8 9 5 ⋯ 1 7 [6,] 1 8 8 3 5 2 8 4 9 6 ⋯ 5 8 [7,] 2 9 2 9 8 4 5 2 9 4 ⋯ 6 1 [8,] 4 5 4 4 9 8 1 3 6 2 ⋯ 2 8 [9,] 2 6 3 9 7 1 6 7 1 4 ⋯ 7 1 [10,] 2 1 4 3 3 1 9 8 2 8 ⋯ 7 4 [11,] 7 7 3 1 1 3 7 9 6 2 ⋯ 5 6 [12,] 4 5 2 3 8 3 5 7 9 1 ⋯ 2 3 [13,] 3 9 5 9 2 5 2 7 2 8 ⋯ 9 3 [14,] 1 5 9 2 9 9 4 3 1 2 ⋯ 8 6 [15,] 8 5 1 9 9 2 1 1 2 7 ⋯ 8 5 [16,] 9 4 1 8 9 4 7 7 6 1 ⋯ 8 4 [17,] 1 4 1 1 2 7 6 4 2 1 ⋯ 7 9 [18,] 3 1 9 5 7 5 4 2 3 9 ⋯ 7 7 [19,] 7 3 4 1 2 9 8 1 6 6 ⋯ 1 2 [20,] 4 8 7 7 3 4 3 7 3 6 ⋯ 7 7 [21,] 9 5 6 2 8 4 7 8 7 1 ⋯ 4 4 [22,] 7 5 1 5 3 7 8 3 9 5 ⋯ 6 1 [23,] 4 8 7 7 4 3 1 5 9 4 ⋯ 9 5 [24,] 2 1 9 1 4 7 2 9 2 8 ⋯ 7 2 [25,] 5 2 9 8 5 3 5 7 2 7 ⋯ 7 7 [26,] 5 2 3 6 3 5 4 3 7 2 ⋯ 5 3 [27,] 1 9 5 2 6 3 8 3 2 6 ⋯ 6 6 [28,] 6 3 5 5 2 5 7 7 9 8 ⋯ 3 1 [29,] 8 8 7 5 2 2 7 3 1 7 ⋯ 5 5 [30,] 7 3 8 6 4 4 6 4 4 5 ⋯ 5 8 [31,] ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋱ ⋮ ⋮ [32,] 8 4 7 5 5 4 9 4 6 7 ⋯ 3 8 [33,] 5 5 5 1 9 7 9 1 2 4 ⋯ 7 1 [34,] 3 8 1 9 8 8 6 1 5 1 ⋯ 9 6 [35,] 3 8 2 6 6 6 4 5 1 2 ⋯ 9 7 [36,] 8 3 7 5 3 9 9 5 5 8 ⋯ 9 1 [37,] 3 3 8 3 4 9 1 4 8 9 ⋯ 3 1 [38,] 6 6 2 6 7 1 7 9 5 3 ⋯ 9 1 [39,] 8 6 2 2 7 6 3 1 9 2 ⋯ 2 9 [40,] 7 3 7 7 2 2 6 6 4 8 ⋯ 4 2 [41,] 9 1 1 9 7 1 5 3 5 2 ⋯ 9 1 [42,] 8 4 2 1 3 3 7 9 5 9 ⋯ 3 1 [43,] 9 6 7 1 4 8 5 4 9 8 ⋯ 5 6 [44,] 8 7 8 1 9 5 1 8 6 7 ⋯ 7 8 [45,] 3 3 4 8 6 1 6 9 3 1 ⋯ 5 3 [46,] 2 1 6 7 1 2 8 1 1 6 ⋯ 3 4 [47,] 5 2 1 7 7 1 7 6 3 1 ⋯ 6 8 [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [1,] 1 1 3 2 4 7 3 5 [2,] 4 8 7 7 8 1 2 5 [3,] 8 8 2 3 9 4 9 4 [4,] 1 7 9 3 9 9 6 8 [5,] 9 6 3 6 2 8 8 5 [6,] 9 2 9 7 7 9 2 2 [7,] 2 4 3 8 3 3 6 5 [8,] 7 3 8 6 8 4 4 1 [9,] 4 4 6 6 8 8 1 8 [10,] 3 7 6 9 2 2 8 3 [11,] 4 3 4 3 5 5 4 3 [12,] 2 1 4 5 1 3 2 4 [13,] 5 7 7 7 8 9 3 9 [14,] 8 9 6 2 3 2 6 2 [15,] 4 1 2 4 8 7 5 3 [16,] 4 1 9 4 1 1 3 5 [17,] 9 9 4 2 5 3 3 5 [18,] 7 8 5 5 4 1 6 4 [19,] 5 2 4 6 3 6 9 6 [20,] 2 8 1 2 5 7 6 8 [21,] 2 6 5 3 3 7 4 3 [22,] 9 9 8 1 6 2 2 6 [23,] 3 8 1 6 1 1 9 9 [24,] 1 2 1 3 9 9 3 8 [25,] 6 9 5 4 7 6 3 3 [26,] 6 3 9 9 8 4 3 5 [27,] 1 8 4 8 4 3 2 7 [28,] 9 7 2 2 7 2 9 6 [29,] 8 1 7 5 2 5 5 2 [30,] 1 3 8 2 5 9 4 7 [31,] ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ [32,] 8 9 6 2 6 8 4 3 [33,] 8 1 6 2 7 6 7 4 [34,] 4 8 9 8 9 8 8 1 [35,] 5 1 2 6 3 6 2 7 [36,] 1 9 4 6 1 6 5 6 [37,] 8 4 1 9 6 8 5 5 [38,] 1 3 8 6 8 9 1 9 [39,] 2 8 5 3 6 6 7 1 [40,] 7 1 6 2 3 1 6 8 [41,] 9 9 8 9 1 2 1 3 [42,] 6 3 5 3 8 3 6 7 [43,] 2 4 3 9 9 4 1 6 [44,] 7 9 9 2 6 2 2 9 [45,] 9 2 7 3 3 3 8 7 [46,] 5 2 4 7 6 4 2 3 [47,] 2 7 7 8 5 6 3 4 [ reached getOption(&#34;max.print&#34;) -- omitted 14 rows ] . t1=Sys.time() A %&gt;% apply(1,min) %&gt;% max t2=Sys.time() t2-t1 . [1] 2 . Time difference of 4.850609 secs . t1=Sys.time() vec&lt;-c() for(i in 1:(dim(A)[1])) vec[i]&lt;-min(A[i,]) max(vec) t2=Sys.time() t2-t1 . [1] 2 . Time difference of 3.032909 secs . - for문이 좀더 빠르지만 코드는 apply가 더 간결해보인다. . &#49689;&#51228; . - 아래의 코드를 실행하고 실행결과를 제출 . t1=Sys.time() A %&gt;% apply(1,min) %&gt;% max t2=Sys.time() t2-t1 . [1] 2 . Time difference of 4.850609 secs . t1=Sys.time() vec&lt;-c() for(i in 1:(dim(A)[1])) vec[i]&lt;-min(A[i,]) max(vec) t2=Sys.time() t2-t1 . [1] 2 . Time difference of 3.032909 secs .",
            "url": "https://guebin.github.io/2021IR/2021/10/21/(7%EC%A3%BC%EC%B0%A8)-10%EC%9B%9421%EC%9D%BC.html",
            "relUrl": "/2021/10/21/(7%EC%A3%BC%EC%B0%A8)-10%EC%9B%9421%EC%9D%BC.html",
            "date": " • Oct 21, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "(6주차) 10월19일",
            "content": "&#44053;&#51032;&#45432;&#53944; . . - (1/1) 숫자 카드 게임 . &#49707;&#51088; &#52852;&#46300; &#44172;&#51076; (2019 &#44397;&#44032; &#44368;&#50977;&#44592;&#44288; &#53076;&#46377;&#53580;&#49828;&#53944;) . 숫자 카드 게임은 여러개의 숫자중에서 가장 높은 숫자가 쓰인 카드를 한장 뽑는 게임이다. . 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다. . 숫자가 쓰인 카드들이 N $ times $M 형태로 놓여 있다. | 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다. | 그 다음 선택된 행에 포함된 카드들 중에서 가장 숫자가 낮은 카드를 뽑아야 한다. | 따라서 처음에 카드를 골라낼 행을 선택할때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다. | . - 예시1 . 입력 3 1 2 4 1 4 2 2 2 출력 2 . - 예시2 . 입력 7 3 1 8 3 3 3 4 출력 3 . (풀이) . (전략회의) . a1=c(3,1,2) a2=c(4,1,4) a3=c(2,2,2) . 우리는 일단 아래와 같은 모양을 만들어야함 . 3 1 2 4 1 4 2 2 2 . a1,a2,a3을 각각 row-vector 로 해석하고 bind 하면된다. . A = rbind(a1,a2,a3) . A . [,1] [,2] [,3] a1 3 1 2 a2 4 1 4 a3 2 2 2 . A= rbind(c(3,1,2),c(4,1,4),c(2,2,2)) . 입력이 A일경우 출력이 2가 나와야한다. . 전략: . A의 각 행(row)을 돌아가면서 가장 작은 숫자를 찾아 기록한다. | 기록한 숫자들을 모아서 벡터로 만든다. | 벡터의 최대값을 구한다. | 할수있어야 하는것 . A의 1번째 행, 2번째행, 3번째행을 순서대로 뽑을 수 있어야 한다. | . (실질적풀이) . A= rbind(c(3,1,2),c(4,1,4),c(2,2,2)) . vec&lt;-c() for (i in 1:3) vec[i]&lt;- min(A[i,]) . max(vec) . [1] 2 . - 입력이 아래와 같은 경우 . 7 3 1 8 3 3 3 4 . A=rbind(c(7,3,1,8),c(3,3,3,4)) . vec&lt;-c() for (i in 1:2) vec[i]&lt;- min(A[i,]) . max(vec) . [1] 3 . &#49689;&#51228; . 입력구조가 . 3 4 5 1 7 7 7 2 8 1 8 2 3 3 4 5 . 와 같을 때 출력을 구하는 코드를 작성하시오. .",
            "url": "https://guebin.github.io/2021IR/2021/10/19/(6%EC%A3%BC%EC%B0%A8)-10%EC%9B%9419%EC%9D%BC.html",
            "relUrl": "/2021/10/19/(6%EC%A3%BC%EC%B0%A8)-10%EC%9B%9419%EC%9D%BC.html",
            "date": " • Oct 19, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "(6주차) 10월14일 -- 특강",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/3) 아나콘다와 가상환경 (1) . - (2/3) 아나콘다와 가상환경 (2) . - (3/3) 아나콘다와 가상환경 (3) .",
            "url": "https://guebin.github.io/2021IR/2021/10/14/(6%EC%A3%BC%EC%B0%A8)-10%EC%9B%9414%EC%9D%BC-%ED%8A%B9%EA%B0%95.html",
            "relUrl": "/2021/10/14/(6%EC%A3%BC%EC%B0%A8)-10%EC%9B%9414%EC%9D%BC-%ED%8A%B9%EA%B0%95.html",
            "date": " • Oct 14, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "(5주차) 10월12일",
            "content": ". - (1/4) 기타연산자 (1) . - (1/4) 기타연산자 (2) . - (3/4) 기타연산자 (3) . - (4/4) 숙제해설 . &#54624;&#45817;&#50672;&#49328;&#51088; . - 예제1 . a&lt;-1 . a . [1] 1 . a=10 . a . [1] 10 . - 예제2 . 2 -&gt; a . a . [1] 2 . - 잘못된사용 . 2 = a . Error in 2 = a: invalid (do_set) left-hand side to assignment Traceback: . - 예제3 . a&lt;-b&lt;-3 . c(a,b) . [1] 3 3 . a=b=4 . c(a,b) . [1] 4 4 . - 잘못된사용 . a&lt;-3&lt;-b . Error in 3 &lt;- b: invalid (do_set) left-hand side to assignment Traceback: . 3&lt;-b . Error in 3 &lt;- b: invalid (do_set) left-hand side to assignment Traceback: . - 잘못된사용 . a=3=b . Error in 3 = b: invalid (do_set) left-hand side to assignment Traceback: . - 예제4 . a&lt;- 5 -&gt; b . c(a,b) . [1] 5 5 . - 예제5 . f &lt;- function(x) x**2 . f(100) . [1] 10000 . f = function(x) x**2 . f(8) . [1] 64 . - 개인적으로는 &lt;- 를 없애고 = 할당만 있는것도 좋을것 같다. 왜냐하면 . a=-2 . a&lt; -3 . [1] FALSE . a&lt;-3 . a . [1] 3 . 와 같이 헷갈리는 상황이 종종 발생하기 때문 . :&#50672;&#49328;&#51088; . - 예제1 . 4:6 . [1] 4 5 6 . 6:4 . [1] 6 5 4 . ()&#50672;&#49328;&#51088; . - 예제1 . 3+4*3 . [1] 15 . (3+4)*3 . [1] 21 . - 예제2: 표현식을 만들때 연산자 우선순위에 대한 자신이 없는 경우 사용 . 1:3*2 . [1] 2 4 6 . (1:3)*2 . [1] 2 4 6 . 1:(3*2) . [1] 1 2 3 4 5 6 . {}&#50672;&#49328;&#51088;: &#50668;&#47084;&#44060;&#51032; &#54364;&#54788;&#49885;&#51012; &#54616;&#45208;&#51032; &#54364;&#54788;&#49885;&#52376;&#47100;! . - 주로 if, for, function과 함께 사용된다. . - 예제1 . x&lt;-6 if(x&gt;5){ x&lt;-10 y&lt;-20 } . c(x,y) . [1] 10 20 . []&#50672;&#49328;&#51088;: &#50896;&#49548;&#52280;&#51312; &#50672;&#49328;&#51088; . - 예제1 . a&lt;- 6:-2 a . [1] 6 5 4 3 2 1 0 -1 -2 . a[2] . [1] 5 . - 예제2 . a[a&gt;2] . [1] 6 5 4 3 . - 예제3 . a[c(1,2)] . [1] 6 5 . - 예제4 . a[-c(1,2)] . [1] 4 3 2 1 0 -1 -2 . -c(1,2) . [1] -1 -2 . - 아래와 같이 사용할수는 없다. . a[c(-1,2)] . Error in a[c(-1, 2)]: only 0&#39;s may be mixed with negative subscripts Traceback: . #&#50672;&#49328;&#51088;: &#51452;&#49437;&#50672;&#49328;&#51088; . . 틀린코드이지만 어차피 아무것도 실행되지 않아서 에러가 나지는 않음 | . - 블락단위로 주석을 만드는 방법 . 주피터: 컨트롤 + / | Rstudio: 컨트롤 + 쉬프트 + c | . # asdfasdfasdf # asdfasdfasdfasdf # sdfasdfasdf . ?&#50672;&#49328;&#51088;: &#46020;&#50880;&#47568; &#50672;&#49328;&#51088; . ;&#50672;&#49328;&#51088;: &#50672;&#44208;&#50672;&#49328;&#51088; . - 예제1: 두개의 표현식은 원래 한줄에 쓸 수 없다. 그런데 ; 를 사용하면 쓸 수 있다. . a=1, b=2 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:4: unexpected &#39;,&#39; 1: a=1, ^ Traceback: . a=1;b=2 . c(a,b) . [1] 1 2 . - 아래와 같이 표현식의 마지막이 세미콜론으로 끝나도 괜찮음 . a=3;b=4; . c(a,b) . [1] 3 4 . &#50672;&#49328;&#51088; &#50864;&#49440;&#49692;&#50948; . - 예제1 . 1:3**2 . [1] 1 2 3 4 5 6 7 8 9 . - 좀 더 명확하게 아래와 같이 쓰자. . 1:(3**2) . [1] 1 2 3 4 5 6 7 8 9 . (1:3)**2 . [1] 1 4 9 . - 예제2 . 2^2:-1 . [1] 4 3 2 1 0 -1 . - 명확하게 . (2^2):-1 . [1] 4 3 2 1 0 -1 . 2^(2:-1) . [1] 4.0 2.0 1.0 0.5 .",
            "url": "https://guebin.github.io/2021IR/2021/10/12/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%9412%EC%9D%BC.html",
            "relUrl": "/2021/10/12/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%9412%EC%9D%BC.html",
            "date": " • Oct 12, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "(5주차) 10월7일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) while, break, ifelse . - (2/4) switch, reapeat, next . - (3/4) 산술연산자, 논리연산자 . - (4/4) 비교연산자, 과제설명 . &#51312;&#44148;, &#48152;&#48373;, &#47336;&#54532;&#53448;&#52636; . while . - 예제1 . tot = 0 i = 1 while(i&lt;=100){ tot=tot+i i = i+1 } . tot . [1] 5050 . - 예제1의 다른구현(1) . tot=0 for (i in 1:100) tot = tot +i . tot . [1] 5050 . - 예제1의 다른구현(2) . tot = 0 i = 1 while(TRUE){ tot = tot+i i=i+1 if (i&gt;100) break } . tot . [1] 5050 . - 예제1의 다른구현(3) . tot = 0 i = 1 while(TRUE){ tot = tot+i if (i&gt;=100) break i=i+1 } . tot . [1] 5050 . - 저는 while을 싫어합니다. . - 어쩔수 없이 써야할때가 있어서 알고있는 것입니다. . break . - 예제1 . for (i in 1:10){ print(i) if(i==3) break } . [1] 1 [1] 2 [1] 3 . - 예제2 . for (i in 1:10){ for (j in 1:10){ print(c(i,j)) if(j==3) break } if(i==5) break } . [1] 1 1 [1] 1 2 [1] 1 3 [1] 2 1 [1] 2 2 [1] 2 3 [1] 3 1 [1] 3 2 [1] 3 3 [1] 4 1 [1] 4 2 [1] 4 3 [1] 5 1 [1] 5 2 [1] 5 3 . ifelse . - 예제1 . x= -2:2 x . [1] -2 -1 0 1 2 . ifelse(x&gt;0,x,-x) . [1] 2 1 0 1 2 . - 예제1의 다른구현 . length(x) . [1] 5 . y_ = x*0 y_ . [1] 0 0 0 0 0 . for (i in 1:length(x)){ if (x[i]&gt;0) y_[i] = x[i] else y_[i] = -x[i] } . y_ . [1] 2 1 0 1 2 . - 예제2 . x= -5:5 x . [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 . y=ifelse(x&lt;0, 0, ifelse(x&gt;2,x,1)) . y . [1] 0 0 0 0 0 1 1 1 3 4 5 . plot(x,x) points(x,y,col=2,pch=16) . - 예제2의 다른구현 . x= -5:5 x . [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 . y=x*0 y . [1] 0 0 0 0 0 0 0 0 0 0 0 . n=length(x) n . [1] 11 . for(i in 1:n){ if(x[i]&lt;0) y[i]=0 else if (x[i]&gt;2) y[i]=x[i] else y[i]=1 } . y . [1] 0 0 0 0 0 1 1 1 3 4 5 . - ifelse와 if~else는 성격이 조금 다름 . ifelse: 조건에 부합하는 새로운 벡터를 생성하는데 특화되어있음 | if~else: 조건에 따라 코드의 실행흐름을 제어하는 성격의 문법 | . switch . - 예제1 . switch(1, 10,20,30) . [1] 10 . switch(2, 10,20,30) . [1] 20 . switch(3, 10,20,30) . [1] 30 . - 예제2 . switch(1, c(1,2,3),20,c(30,40)) . [1] 1 2 3 . switch(2, c(1,2,3),20,c(30,40)) . [1] 20 . switch(3, c(1,2,3),20,c(30,40)) . [1] 30 40 . - 예제3 . switch(&#39;a1&#39;, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 1 2 3 . switch(&#39;a2&#39;, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 20 . switch(&#39;a3&#39;, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 30 40 . - 예제4 . (예비학습) . x=1:10 x . [1] 1 2 3 4 5 6 7 8 9 10 . c( mean(x), mean(x**2), mean((x-mean(x))**2) ) . [1] 5.50 38.50 8.25 . 38.50 - 5.50**2 . [1] 8.25 . (예제시작) . switch(&quot;f1&quot;, f1=mean(x), f2=mean(x**2), f3=mean((x-mean(x))**2) ) . [1] 5.5 . switch(&quot;f2&quot;, f1=mean(x), f2=mean(x**2), f3=mean((x-mean(x))**2) ) . [1] 38.5 . switch(&quot;f3&quot;, f1=mean(x), f2=mean(x**2), f3=mean((x-mean(x))**2) ) . [1] 8.25 . - 예제5 . myfun&lt;-function(x,f){ switch(f, meann=mean(x), sqmeann=mean(x**2), varr=mean((x-mean(x))**2) ) } . x=1:5 myfun(x,&quot;meann&quot;) myfun(x,&quot;sqmeann&quot;) myfun(x,&quot;varr&quot;) . [1] 3 . [1] 11 . [1] 2 . repeat . - 예제1 . tot=0 i=1 repeat{ tot=tot+i i=i+1 if (i&gt;100) break } . tot . [1] 5050 . - 잘못된 예제1 . tot=0 i=1 repeat{ tot=tot+i i=i+1 } . next . - 예제1 . for(i in 1:5){ if(i==3) next else print(i) } . [1] 1 [1] 2 [1] 4 [1] 5 . break와 비교 . for(i in 1:5){ if(i==3) break else print(i) } . [1] 1 [1] 2 . - 예제2 . i=0 repeat{ i=i+1 if (i&gt;5) break if (i==3) next print(i) } . [1] 1 [1] 2 [1] 4 [1] 5 . &#50836;&#50557; . - 조건: if, if~else / ifelse, switch . - 반복: for, while, repeat . - 루프탈출: break, next . &#50672;&#49328;&#51088; . &#49328;&#49696;&#50672;&#49328;&#51088; . - 예제1 . 5+2 . [1] 7 . 6-2 . [1] 4 . 3*4 . [1] 12 . 6/5 . [1] 1.2 . - 예제2 . 2^3 . [1] 8 . 2**3 . [1] 8 . - 예제3 . 31%%3 . [1] 1 . 31%/%3 . [1] 10 . &#45436;&#47532;&#50672;&#49328;&#51088; . - 예제1 . x=c(T,T,F,F,T) y=c(TRUE,FALSE,TRUE,FALSE,TRUE) . x . [1] TRUE TRUE FALSE FALSE TRUE . y . [1] TRUE FALSE TRUE FALSE TRUE . print(x) print(!x) . [1] TRUE TRUE FALSE FALSE TRUE [1] FALSE FALSE TRUE TRUE FALSE . print(y) print(!y) . [1] TRUE FALSE TRUE FALSE TRUE [1] FALSE TRUE FALSE TRUE FALSE . . Note: TRUE, FALSE 로 구성된 열을 잘 다루면 인덱싱에 유리하다. . - 예제2: 예제1의 응용 . x=1:30 x . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 . x%%3 . [1] 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 . x[x%%3==0] # 3의 배수인것만 출력 . [1] 3 6 9 12 15 18 21 24 27 30 . x[!(x%%3==0)] # 3의 배수가 아닌것만 출력 . [1] 1 2 4 5 7 8 10 11 13 14 16 17 19 20 22 23 25 26 28 29 . - 예제2의 다른구현 (논리연산자와 TRUE/FALSE 로 이루어진 열을 다루는데 익숙하지 않다면 고생스러울 때가 있음) . x&lt;-c() j=1 for (i in 1:30){ if (i%%3 == 0) { x[j]= i j=j+1 } } . x . [1] 3 6 9 12 15 18 21 24 27 30 . x&lt;-c() j=1 for (i in 1:30){ if (i%%3 != 0) { x[j]= i j=j+1 } } . x . [1] 1 2 4 5 7 8 10 11 13 14 16 17 19 20 22 23 25 26 28 29 . - 예제3 . x=c(T,T,F,F,T) y=c(T,F,T,F,T) . print(x) print(y) print(x&amp;y) ## and 연산자, 하나라도 FALSE이면 FALSE . [1] TRUE TRUE FALSE FALSE TRUE [1] TRUE FALSE TRUE FALSE TRUE [1] TRUE FALSE FALSE FALSE TRUE . - 예제4: 예제3의 응용 . x=1:50 . x[(x&gt;30) &amp; (x%%3==0)] # 30보다크고, 3의 배수인것들 . [1] 33 36 39 42 45 48 . x[(x&gt;30) &amp; !(x%%3==0)] . [1] 31 32 34 35 37 38 40 41 43 44 46 47 49 50 . - 예제5 . x=c(T,T,F,F,T) y=c(T,F,T,F,T) . print(x) print(y) print(x|y) ## or 연산자, 하나라도 TRUE이면 TRUE . [1] TRUE TRUE FALSE FALSE TRUE [1] TRUE FALSE TRUE FALSE TRUE [1] TRUE TRUE TRUE FALSE TRUE . - 예제6: 예제5를 응용 . x=1:50 x . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 . x&gt;30 | x&lt;10 . [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE [37] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [49] TRUE TRUE . x[x&gt;30 | x&lt;10] . [1] 1 2 3 4 5 6 7 8 9 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 [26] 47 48 49 50 . - 예제7 . x=c(T,F,T,T,F) y=c(F,T,F,F,T) . print(x) print(y) print(x&amp;&amp;y) . [1] TRUE FALSE TRUE TRUE FALSE [1] FALSE TRUE FALSE FALSE TRUE [1] FALSE . x&amp;&amp;y 와 (x&amp;y)[1]는 거의 같음 | . - 예제8 . x=c(T,F,T,T,F) y=c(F,T,F,F,T) . print(x) print(y) print(x||y) . [1] TRUE FALSE TRUE TRUE FALSE [1] FALSE TRUE FALSE FALSE TRUE [1] TRUE . x||y 와 (x|y)[1]는 거의 같음 | . &#48708;&#44368;&#50672;&#49328;&#51088; . - 예제1 . x=c(1,2,3,4,5) y=c(2,2,3,2,1) . x==y . [1] FALSE TRUE TRUE FALSE FALSE . x!=y . [1] TRUE FALSE FALSE TRUE TRUE . !(x==y) . [1] TRUE FALSE FALSE TRUE TRUE . - 예제1의 잘못된 적용 (1) . x=c(1,2,3,4,5) y=c(2,2,3,2,1) . x=y . x . [1] 2 2 3 2 1 . - 예제1의 잘못된 적용 (2) . x=c(1,2,3,4,5) y=c(2,2,3,2,1) . x=!y . x . [1] FALSE FALSE FALSE FALSE FALSE . ???? 왜 이런결과가? | . (잘못된 결과의 분석) . !y . [1] FALSE FALSE FALSE FALSE FALSE . !c(1,1,0,0) . [1] FALSE FALSE TRUE TRUE . !c(2,2,0,0) . [1] FALSE FALSE TRUE TRUE . - 예제2 . x=c(1,2,3,4,5) y=c(2,2,3,2,1) . x&gt;y . [1] FALSE FALSE FALSE TRUE TRUE . x&lt;y . [1] TRUE FALSE FALSE FALSE FALSE . x&gt;=y . [1] FALSE TRUE TRUE TRUE TRUE . x&lt;=y . [1] TRUE TRUE TRUE FALSE FALSE . - 예제2의 잘못된 사용 . x=&gt;y . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:3: unexpected &#39;&gt;&#39; 1: x=&gt; ^ Traceback: . x=&lt;y . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:3: unexpected &#39;&lt;&#39; 1: x=&lt; ^ Traceback: . &#49689;&#51228; . x= -100:100/10 . x . [1] -10.0 -9.9 -9.8 -9.7 -9.6 -9.5 -9.4 -9.3 -9.2 -9.1 -9.0 -8.9 [13] -8.8 -8.7 -8.6 -8.5 -8.4 -8.3 -8.2 -8.1 -8.0 -7.9 -7.8 -7.7 [25] -7.6 -7.5 -7.4 -7.3 -7.2 -7.1 -7.0 -6.9 -6.8 -6.7 -6.6 -6.5 [37] -6.4 -6.3 -6.2 -6.1 -6.0 -5.9 -5.8 -5.7 -5.6 -5.5 -5.4 -5.3 [49] -5.2 -5.1 -5.0 -4.9 -4.8 -4.7 -4.6 -4.5 -4.4 -4.3 -4.2 -4.1 [61] -4.0 -3.9 -3.8 -3.7 -3.6 -3.5 -3.4 -3.3 -3.2 -3.1 -3.0 -2.9 [73] -2.8 -2.7 -2.6 -2.5 -2.4 -2.3 -2.2 -2.1 -2.0 -1.9 -1.8 -1.7 [85] -1.6 -1.5 -1.4 -1.3 -1.2 -1.1 -1.0 -0.9 -0.8 -0.7 -0.6 -0.5 [97] -0.4 -0.3 -0.2 -0.1 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 [109] 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 [121] 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3.0 3.1 [133] 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 4.0 4.1 4.2 4.3 [145] 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 5.5 [157] 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 [169] 6.8 6.9 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 [181] 8.0 8.1 8.2 8.3 8.4 8.5 8.6 8.7 8.8 8.9 9.0 9.1 [193] 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0 . 아래와 같은 $y$를 생성하라. . $y= begin{cases} x &amp; |x|&gt;5 0 &amp; |x| leq 2 5 &amp; o.w. end{cases}$ . 힌트: ifelse를 중첩, abs()함수를 이용 . ifelse(abs(x)&gt;5,x,ifelse(abs(x)&lt;=2,0,5)) . [1] -10.0 -9.9 -9.8 -9.7 -9.6 -9.5 -9.4 -9.3 -9.2 -9.1 -9.0 -8.9 [13] -8.8 -8.7 -8.6 -8.5 -8.4 -8.3 -8.2 -8.1 -8.0 -7.9 -7.8 -7.7 [25] -7.6 -7.5 -7.4 -7.3 -7.2 -7.1 -7.0 -6.9 -6.8 -6.7 -6.6 -6.5 [37] -6.4 -6.3 -6.2 -6.1 -6.0 -5.9 -5.8 -5.7 -5.6 -5.5 -5.4 -5.3 [49] -5.2 -5.1 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 [61] 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 [73] 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 0.0 0.0 0.0 0.0 [85] 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [97] 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [109] 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [121] 0.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 [133] 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 [145] 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.1 5.2 5.3 5.4 5.5 [157] 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 [169] 6.8 6.9 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 [181] 8.0 8.1 8.2 8.3 8.4 8.5 8.6 8.7 8.8 8.9 9.0 9.1 [193] 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0 .",
            "url": "https://guebin.github.io/2021IR/2021/10/07/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%947%EC%9D%BC.html",
            "relUrl": "/2021/10/07/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%947%EC%9D%BC.html",
            "date": " • Oct 7, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "(4주차) 10월5일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/3) 2007년(나) 9월/평가원 16(고3) 풀이 (1) . - (2/3) 2007년(나) 9월/평가원 16(고3) 풀이 (2) . - (3/3) 2007년(나) 9월/평가원 16(고3) 풀이 (3), for+break, while, 과제설명 . 2007(&#45208;) 9&#50900;/&#54217;&#44032;&#50896; 16(&#44256;3) . 자연수 $n$에 대하여 점 $P_n$을 다음 규칙에 따라 정한다. . (가) 점 $P_1$의 좌표는 $(1,1)$이다. . (나) 점 $P_n$의 좌표가 $(a,b)$일때, . $b&lt;2^a$이면 점 $P_{n+1}$의 좌표는 $(a,b+1)$이고 | $b=2^a$이면 점 $P_{n+1}$의 좌표는 $(a+1,1)$이다. | . 점 $P_n$의 좌표가 $(10,2^{10})$일 때, $n$의 값은? . (1) $2^{10}-2$ . (2) $2^{10}+2$ . (3) $2^{11}-2$ . (4) $2^{11}$ . (5) $2^{11}+2$ . (풀이전략) . - $P_1$로부터 $P_2$를 구한다. . - $P_2=(10,2^{10})$인지 체크 . 맞다면 $n=2$ | 아니라면 아래를 진행 | . - $P_2$에서 $P_3$을 구한다. . - $P_3=(10,2^{10})$인지 체크 . 맞다면 n=3 | 아니라면 아래를 진행 | . - ... . 그래서 아래와 같은 로직이면 좋겠다. . - for $n=1,2, dots, 2^{11}+2$까지 아래를 반복함 (단, $P_n=(10,2^{10})$인 경우에는 반복중지) . if Pn==(10,2^(10)) 인 경우: 반복문 탈출 else 반복할내용 . (풀이) . a=c() b=c() a[1]=1 b[1]=1 for(n in 1:2^12){ if ((a[n]==10)&amp;(b[n]==2^10)){ print(n) break }else{ ## 탈출못했을때 실행되는 코드 (실질적인 문제풀이 if(b[n]&lt;2^(a[n])){ a[n+1]=a[n] b[n+1]=b[n]+1 }else{ if(b[n]==2^(a[n])){ a[n+1]=a[n]+1 b[n+1]=1 } } } } . [1] 2046 . c(2^10-2 , 2^10+2 , 2^11-2 , 2^11 , 2^11+2) . [1] 1022 1026 2046 2048 2050 . 답은 3번 . &#48152;&#48373;&#47928;&#51012; &#51201;&#45817;&#54620; &#51312;&#44148;&#54616;&#50640;&#47564; &#49688;&#54665;&#54616;&#45716; &#48169;&#48277; . (1) 방법1: for + break 를 적절하게 활용 . (2) 방법2: while 을 이용 . x= -5 while(x&lt;0){ print(&#39;x는음수&#39;) x= x+1 } . [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; . &#49689;&#51228; . - for + break를 활용하여 위와 같은 결과가 나오도록 코드를 작성하라. . for (x in -5:10){ if (????){ break }else{ print(&#39;x는음수&#39;) #x=x+1 } } . [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; .",
            "url": "https://guebin.github.io/2021IR/2021/10/05/(4%EC%A3%BC%EC%B0%A8)-10%EC%9B%945%EC%9D%BC.html",
            "relUrl": "/2021/10/05/(4%EC%A3%BC%EC%B0%A8)-10%EC%9B%945%EC%9D%BC.html",
            "date": " • Oct 5, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "(4주차) 9월30일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/1) if문 . - (2/4) if - else 문 . - (3/4) 중첩 (1) . - (4/4) 중첩 (2), 과제설명 . if . - 아래와 같이 if (조건문) 표현식의 형태로 사용한다. (표현식은 컴퓨터에게 내가 내리는 명령어이다) . a= 2 if (a&gt;0) print(&#39;a는 양수&#39;) . [1] &#34;a는 양수&#34; . - space를 임의로 넣어도 상관없다. . a=10 if (a&gt;0) print(&#39;a는 양수&#39;) . [1] &#34;a는 양수&#34; . a=10 if (a&gt;0) print(&#39;a는 양수&#39;) . [1] &#34;a는 양수&#34; . - enter를 넣어도 상관없긴하다. . a=10 if (a&gt;0) print(&#39;a는양수&#39;) . [1] &#34;a는양수&#34; . a=10 if (a&gt;0) print(&#39;a는양수&#39;) . [1] &#34;a는양수&#34; . a=10 if (a&gt;0) print(&#39;a는양수&#39;) . [1] &#34;a는양수&#34; . - 컴퓨터에게 내릴 명령이 2개이상일 경우? $ to$ {}을 이용한다. . &#51096;&#47803;&#46108;&#50696;&#51228; . a=10 if (a&gt;0) print(&#39;a는양수&#39;) print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) . [1] &#34;a는양수&#34; [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] 10 . a=-10 if (a&gt;0) print(&#39;a는양수&#39;) ## print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) . [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] -10 . 에러메시지가 뜨지는 않았지만 잘못된 코드이다. | . &#50732;&#48148;&#47480; &#49324;&#50857;&#48277;: {}&#47484; &#51060;&#50857;&#54616;&#50668; &#47749;&#47161;&#46308;&#51012; &#47926;&#45716;&#45796;. . a=10 if (a&gt;0){ print(&#39;a는양수&#39;) print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) } . [1] &#34;a는양수&#34; [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] 10 . a=-10 if (a&gt;0){ print(&#39;a는양수&#39;) ## print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) } . - 아래와 같이 중괄호를 묶어도 상관없다. . a=10 if (a&gt;0) { print(&#39;a는양수&#39;) print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) } . [1] &#34;a는양수&#34; [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] 10 . a=10 if (a&gt;0) { print(&#39;a는양수&#39;) print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a)} . [1] &#34;a는양수&#34; [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] 10 . a=10 if (a&gt;0){ print(&#39;a는양수&#39;) print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) } . [1] &#34;a는양수&#34; [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] 10 . 위와같이 코드를 작성하면 안된다. | . - if (조건문) 표현식 . a=c(10,-10) a . [1] 10 -10 . a&gt;0 . [1] TRUE FALSE . 이 문장이 참일까 거짓일까? $ to$ R은 첫번째 원소가 참이면 참이라고 판단한다. | . a=c(10,-10) if (a&gt;0){ print(&#39;a는 양수이다&#39;) print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) } . Warning message in if (a &gt; 0) {: “the condition has length &gt; 1 and only the first element will be used” . [1] &#34;a는 양수이다&#34; [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] 10 -10 . 이러한 코드를 작성하지 말자. | . if~else . - 아래와 같이 if (조건문) 표현식1 else 표현식2의 형태로 실행한다. . x=2 if (x&gt;0) log(x) else print(&#39;x는양수이어야함&#39;) . [1] 0.6931472 . x=1 if (x&gt;0) log(x) else print(&#39;x는양수이어야함&#39;) . [1] 0 . x=0 if (x&gt;0) log(x) else print(&#39;x는양수이어야함&#39;) . [1] &#34;x는양수이어야함&#34; . x=-1 if (x&gt;0) log(x) else print(&#39;x는양수이어야함&#39;) . [1] &#34;x는양수이어야함&#34; . - if 문과 if~else 문은 다른기능이다. . x=10 if (x&gt;0) log(x) else print(&#39;x는 양수이어야함&#39;) . Error in parse(text = x, srcfile = src): &lt;text&gt;:4:1: unexpected &#39;else&#39; 3: log(x) 4: else ^ Traceback: . ?? 왜 에러가 나는가? | . - 아래는 잘 실행된다. . if (x&gt;0) log(x) else print(&#39;x는양수이어야함&#39;) . [1] &#34;x는양수이어야함&#34; . if (x&gt;0) log(x) else print(&#39;x는양수이어야함&#39;) . [1] &#34;x는양수이어야함&#34; . - 보통은 아래와 같이 사용한다. . x=0 if(x&gt;0){ log(x) }else{ print(&#39;x는 양수이어야함&#39;) } . [1] &#34;x는 양수이어야함&#34; . - 결국 한줄에 다 말하거나, {}를 적절하게 활용하면 된다. . - 아래와 같은것들도 가능 . x=0 if (x&gt;0){ log(x) }else{ print(&#39;x는 양수이어야함&#39;) } . [1] &#34;x는 양수이어야함&#34; . - 아래는 불가능 (무조건 중괄호를 친다고 해결되는것이 아님) . x=0 if (x&gt;0){ log(x) } else{ print(&#39;x는 양수이어야함&#39;) } . Error in parse(text = x, srcfile = src): &lt;text&gt;:5:1: unexpected &#39;else&#39; 4: } 5: else ^ Traceback: . - 결국 아래와 같은 코드를 권장함. (주피터보다 Rstudio가 더 쓰기편하다) . x=0 if(x&gt;0){ log(x) }else{ print(&#39;x는 양수이어야함&#39;) } . [1] &#34;x는 양수이어야함&#34; . &#51473;&#52393; . - 예제시작 . x=10 if (x&gt;0){ print(log(x)) }else{ if(x==0){ x=1e-100 print(&#39;x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.&#39;) log(x) }else{ print(&#39;x가음수입니다.&#39;) } } . [1] 2.302585 . x=0 if (x&gt;0){ print(log(x)) }else{ if(x==0){ x=1e-100 print(&#39;x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.&#39;) log(x) }else{ print(&#39;x가음수입니다.&#39;) } } . [1] &#34;x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.&#34; . [1] -230.2585 . x=-1 if (x&gt;0){ print(log(x)) }else{ if(x==0){ x=1e-100 print(&#39;x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.&#39;) log(x) }else{ print(&#39;x가음수입니다.&#39;) } } . [1] &#34;x가음수입니다.&#34; . - 보통은 아래와 같이 함수 형태로 사용한다. (중괄호지옥 $ to$ Rstudio가 좀더 편리함) . mylogfun&lt;-function(x){ if (x&gt;0){ print(log(x)) }else{ if(x==0){ x=1e-100 print(&#39;x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.&#39;) log(x) }else{ print(&#39;x가음수입니다.&#39;) } } } . mylogfun(0) . [1] &#34;x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.&#34; . [1] -230.2585 . &#49689;&#51228; . mysqrtfun()를 만들고 . (1) x&gt;=0 --&gt; sqrt(x) . (2) x&lt;0 --&gt; &#39;x는 양수이어야합니다&#39; . mysqrtfun(-2), mysqrtfun(2) 의 출력결과를 스크린샷으로 제출 .",
            "url": "https://guebin.github.io/2021IR/2021/09/30/(4%EC%A3%BC%EC%B0%A8)-9%EC%9B%9430%EC%9D%BC.html",
            "relUrl": "/2021/09/30/(4%EC%A3%BC%EC%B0%A8)-9%EC%9B%9430%EC%9D%BC.html",
            "date": " • Sep 30, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "(3주차) 9월28일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/2) for문, 2007(나) 6월 평가원 14 (고3) . - (2/2) 2007(나) 6월 평가원 14 (고3), 2004(인)/수능(홀) 19(고3), 2010(나)/수능(홀) 30(고3), if문 . for&#47928; . - 문제: 1~4까지 모두 더하면? . s=0 for(i in c(1,2,3,4)){ ## i=1,2,3,4에 대하여 아래를 반복하라. s=s+i ## 반복할 내용 } s . [1] 10 . - 위의 코드는 아래와 동일하다. . s=0 i=1 s=s+i i=2 s=s+i i=3 s=s+i i=4 s=s+i s . [1] 10 . 2007(&#45208;) 6&#50900;/&#54217;&#44032;&#50896; 14(&#44256;3) . 다음은 어느 회사의 연봉에 대한 규정이다. . (가) 입사 첫째 해 연봉은 $a$원이고, 입사 19년째 해까지의 연봉은 해마다 직전 연봉에서 8%씩 인상된다. . (나) 입사 20년째 해부터의 연봉은 입사 19년째 해 연봉의 2/3로 한다. . 이 회사에 입사한 사람이 28년동안 근무하여 받는 연봉의 총합은? (단, $1.08^{18}=4$로 계산한다) . (1) $ frac{101}{2}a$ . (2) $ frac{111}{2}a$ . (3) $ frac{121}{2}a$ . (4) $ frac{131}{2}a$ . (5) $ frac{141}{2}a$ . (풀이) . sal&lt;-c() sal[1]&lt;- 1 ## 첫해의 연봉은 1로 하자. . for(i in 2:19){ sal[i] = sal[i-1] * 1.08 } . sal . [1] 1.000000 1.080000 1.166400 1.259712 1.360489 1.469328 1.586874 1.713824 [9] 1.850930 1.999005 2.158925 2.331639 2.518170 2.719624 2.937194 3.172169 [17] 3.425943 3.700018 3.996019 . for(i in 20:28){ sal[i] = sal[19]*2/3 } . sal . [1] 1.000000 1.080000 1.166400 1.259712 1.360489 1.469328 1.586874 1.713824 [9] 1.850930 1.999005 2.158925 2.331639 2.518170 2.719624 2.937194 3.172169 [17] 3.425943 3.700018 3.996019 2.664013 2.664013 2.664013 2.664013 2.664013 [25] 2.664013 2.664013 2.664013 2.664013 . sum(sal) . [1] 65.42238 . c(101/2,111/2,121/2,131/2,141/2) . [1] 50.5 55.5 60.5 65.5 70.5 . 답은4번이다. . 2004(&#51064;)/&#49688;&#45733;(&#54848;) 19(&#44256;3) . 자료 $x_1,x_2, dots, x_{100}$에 대하여 다음 과정을 순서대로 시행하였다. . (가) 처음 두 수 $x_1$과 $x_2$의 평균을 구한다. . (나) $x_3$을 추가하여 $x_1, x_2, x_3$의 평균을 구한다. . (다) $x_4$을 추가하여 $x_1, x_2, x_3, x_4$의 평균을 구한다. . ... . $x_{100}$을 추가하여 $x_1, x_2, x_3 , dots , x_{100}$의 평균을 구한다. . 위의 과정을 시행할 결과, $x_1$과 $x_2$의 평균이 5이고, 자료 하나가 추가될때 마다 평균이 1씩 증가하였다. 이때 $x_{100}$의 값은? . (1) 194 . (2) 196 . (3) 198 . (4) 200 . (5) 202 . (풀이) . x&lt;-c() x[1]=5 x[2]=5 . for(n in 3:100){ temp_ = mean(x[1:(n-1)])+1 ## temp_ : 1~n까지의 평균 sum_ = temp_ * n # 1~n까지의 합 x[n] = sum_ - sum(x[1:(n-1)]) } . x . [1] 5 5 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 [19] 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 [37] 76 78 80 82 84 86 88 90 92 94 96 98 100 102 104 106 108 110 [55] 112 114 116 118 120 122 124 126 128 130 132 134 136 138 140 142 144 146 [73] 148 150 152 154 156 158 160 162 164 166 168 170 172 174 176 178 180 182 [91] 184 186 188 190 192 194 196 198 200 202 . 따라서 답은 5번 . 2010(&#45208;)/&#49688;&#45733;(&#54848;) 30(&#44256;3) . 수열 $ {a_n }$에 대하여 첫째항부터 제 $n$항까지의 합을 $S_n$이라고 하자. 수열 $ {S_{2n-1} }$은 공차가 -3인 등차수열이고, 수열 $ {S_{2n} }$은 공차가 2인 등차수열이다. $a_2=1$일 때, $a_8$의 값을 구하시오. . (풀이) . a&lt;-c() a[1]=222 # 첫째항은 222이라고 하자. a[2]=1 # 문제에서 a2=1이라고 하였음 . - $S_n$은 $n$이 짝수이냐, 홀수이냐에 따라서 정의가 달라짐 . $S_3=S_1-3$ . $S_5=S_3-3$ . ... . $S_4=S_2+2$ . $S_6=S_4+2$ . ... . S&lt;-c() S[1]=a[1] S[2]=a[1]+a[2] . (1:5) %% 3 . [1] 1 2 0 1 2 . n %% 2 . [1] 0 . for(n in 3:100){ ### n이 홀수라면?? (n %% 2)==1 if(n%%2 ==1){ S[n]=S[n-2]-3 }else{ ### n이 짝수라면?? (n%%2) == 0 S[n]=S[n-2]+2 } } . S . [1] 222 223 219 225 216 227 213 229 210 231 207 233 204 235 201 237 198 239 [19] 195 241 192 243 189 245 186 247 183 249 180 251 177 253 174 255 171 257 [37] 168 259 165 261 162 263 159 265 156 267 153 269 150 271 147 273 144 275 [55] 141 277 138 279 135 281 132 283 129 285 126 287 123 289 120 291 117 293 [73] 114 295 111 297 108 299 105 301 102 303 99 305 96 307 93 309 90 311 [91] 87 313 84 315 81 317 78 319 75 321 . S[8]-S[7] . [1] 16 . &#49689;&#51228; . - 2010(나)/수능(홀) 30(고3)의 문제풀이에서 a[1]의 값을 0, 222 이외의 값으로 설정하고 $a_8$을 구하라. .",
            "url": "https://guebin.github.io/2021IR/2021/09/28/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9428%EC%9D%BC.html",
            "relUrl": "/2021/09/28/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9428%EC%9D%BC.html",
            "date": " • Sep 28, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "(3주차) 9월16일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/2): 2010(나) 6월/평가원 4 (고3) . - (2/2): 2021(가) 9월/평가원 10 (고3), for문 . - 추가영상: 주피터랩, Rstudio . 2010(&#45208;) 6&#50900;/&#54217;&#44032;&#50896; 4 (&#44256;3) . (문제) 실수 $a$가 $ frac{2^a+2^{-a}}{2^{a}-2^{-a}}=-2$를 만족시킬때, $4^a+4^{-a}$의 값은? . (보기) (1) $ frac{5}{2}$ (2) $ frac{10}{3}$ (3) $ frac{17}{4}$ (4) $ frac{26}{5}$ (5) $ frac{37}{6}$ . (풀이) . - 먼저 $ frac{2^{a}+2^{-a}}{2^a-2^{-a}}=-2$를 만족하는 $a$를 찾아보자. . - $f(a)= frac{2^{a}+2^{-a}}{2^a-2^{-a}}$라고 두고 $f(a)=-2$를 만족하는 $a$를 찾으면 된다. . - 함수를 선언하자. . ### 이렇게 한다고 함수가 선언되지는 않는다. f(a) = (2^a + 2^(-a)) / (2^(a)-2^(-a)) . f&lt;-function(a){ (2^a + 2^(-a)) / (2^(a)-2^(-a)) } . - 잘 선언되었는지 확인: $a=1$을 넣으면 $f(a)= frac{2+0.5}{2-0.5}= frac{2.5}{1.5}$ . print(f(1)) print(2.5/1.5) . [1] 1.666667 [1] 1.666667 . 잘 선언된 것 같다. | . - $f(a)$의 그래프를 그리고 $f(a)=-2$에 해당하는 수평선을 그려서 대략적으로 값을 유추하여 보자. . a=seq(from=-5,to=5,by=0.1) . plot(a,f(a)) abline(h=-2,col=&#39;red&#39;) . - 우선 $-2 &lt; a&lt; 0$ 인 것 같다. 범위를 좁히고, by옵션을 사용하여 더 촘촘히 다시 그려보자. . a = seq(from=-2, to=0, by=0.0001) . plot(a,f(a)) abline(h=-2,col=&#39;red&#39;) . ?? | 함수모양을 보니 $a=0$이면 $f(a)$의 분모가 0이 되어서 정의되지 않음. | . - 범위를 $-2 &lt; a&lt; -0.1$ 로 수정해보자. . a = seq(from=-2, to=-0.1, by=0.0001) plot(a,f(a),type=&#39;l&#39;,lwd=4) abline(h=-2,col=2,lty=2,lwd=4) . col: 칼라조정 (2=빨강, &#39;red&#39;=빨강 // 4=파랑, &#39;blue&#39;=파랑) | lty: 점선의 type조정 | lwd: 선의 두께 조정 | . - 이제 해를 찾아보자. $f(a)=-2$를 찾아야 하므로 f(a)== -2를 조건식으로 걸자. . f(a)== -2 . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [805] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [817] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [829] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [841] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [853] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [865] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [877] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [889] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [901] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [913] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [925] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [937] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [949] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [961] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [973] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [985] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [997] FALSE FALSE FALSE FALSE [ reached getOption(&#34;max.print&#34;) -- omitted 18001 entries ] . - 이중에 적당한 값이 있어야 한다. 보이진 않지만 (너무 많아서 눈으로 찾을수는 없지만) 어딘가에 TRUE가 하나는 있을것이다. . - TRUE가 있는지 체크할 수 있는 방법은 없을까? . . &#48372;&#52649;&#54617;&#49845;: &#52980;&#54504;&#53552;&#44032; TRUE, FALSE&#47484; &#51060;&#54644;&#54616;&#45716; &#48169;&#49885; . - 컴퓨터가 TRUE, FALSE를 1,0으로 각각 인식함. . - 아래 예제를 관찰 . TRUE + FALSE . [1] 1 . TRUE*2 . [1] 2 . TRUE+(FALSE-1) * 2 . [1] -1 . 2*c(TRUE, FALSE, TRUE) # 2*c(1,0,1) . [1] 2 0 2 . sum(c(TRUE,FALSE,TRUE)) . [1] 2 . . - 그럼 이제 f(a)==-2의 결과에서 TRUE가 진짜 있는지 찾아보자. . sum(f(a)==-2) . [1] 0 . - ??? 없음.. . - 사실 컴퓨터는 근사계산을 하였으므로 $f(a)=-2$인 $a$를 정확하게 찾기는 힘들다. 따라서 적당히 $f(a) approx -2$인 $a$를 찾는게 더 합리적이다. . - $f(a) approx -2 $ 인 $a$를 찾는건 $f(a)+2 approx 0$인 $a$를 찾는것과 같다. . - 목표: 즉 $f(a)+2$ 의 &quot;절대값&quot;이 0에 가까운 원소를 고르면 된다. . * 참고: 절대값을 구하는 방법 . abs(c(1,2,-2,3,-4)) . [1] 1 2 2 3 4 . - 위를 응용하면 . min(abs(f(a)+2)) # f(a)의 절대값중 가장 작은 값 . [1] 3.898777e-05 . - 이제 $a$는 아래와 같이 구할 수 있다. . TFarray &lt;- abs(f(a)+2) == min(abs(f(a)+2)) a[TFarray] . [1] -0.7925 . $a=-0.7925$ . - 따라서 $4^{a}+4^{-a}$는 . 4^(0.7925) + 4^(-0.7925) . [1] 3.333403 . (보기) (1) $ frac{5}{2}$ (2) $ frac{10}{3}$ (3) $ frac{17}{4}$ (4) $ frac{26}{5}$ (5) $ frac{37}{6}$ . 보기와 비교해보면 . c(5/2,10/3,17/4,26/5,37/6) . [1] 2.500000 3.333333 4.250000 5.200000 6.166667 . 따라서 답은 2번이다. . 2021(&#44032;) 9&#50900;/&#54217;&#44032;&#50896; 10(&#44256;3) . (문제) 수열 $ {a_n }$은 $a_1=12$이고, 모든 자연수 $n$에 대하여 $a_{n+1}+a_n=(-1)^{n+1} times n$을 만족시킨다. $a_k&gt; a_1$인 자연수 $k$의 최소값은? . (보기) (1) $2$ (2) $4$ (3) $6$ (4) $8$ (5) $10$ . (풀이1) . a1=12 n=1 a2= -a1 +(-1)^(n+1)*n n=2 a3= -a2 +(-1)^(n+1)*n . a3 . [1] 9 . 보기를 보니까 10이 최대값이므로 $a_{10}$까지만 구해보자. . a1=12 n=1 a2= -a1 +(-1)^(n+1)*n n=2 a3= -a2 +(-1)^(n+1)*n n=3 a4= -a3 +(-1)^(n+1)*n n=4 a5= -a4 +(-1)^(n+1)*n n=5 a6= -a5 +(-1)^(n+1)*n n=6 a7= -a6 +(-1)^(n+1)*n n=7 a8= -a7 +(-1)^(n+1)*n n=8 a9= -a8 +(-1)^(n+1)*n n=9 a10= -a9 +(-1)^(n+1)*n . a&lt;-c(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) print(a) . [1] 12 -11 9 -6 2 3 -9 16 -24 33 . (1:10)[a&gt;12] . [1] 8 10 . 답은 (4) $8$ 이다. . (풀이2) . - 풀이2를 소개하기 전에 아래와 같이 벡터를 넣는 법을 생각하자. . * 예비학습 . a_ &lt;-c() . a_ . NULL . a_[1] &lt;- 12 . a_ . [1] 12 . a_[2] &lt;- -12 . a_ . [1] 12 -12 . a_[4] &lt;- 3 . a_ . [1] 12 -12 NA 3 . - 풀이시작 (for문) . a&lt;-c() . a[1] &lt;- 12 . ## 아래와 같은 코드를 구현하고 싶다. n=1~9 a_{n+1}= -a_n +(-1)^(n+1)*n . for(n in 1:19){ a[n+1]&lt;- -a[n]+(-1)^(n+1)*n } . print(a) . [1] 12 -11 9 -6 2 3 -9 16 -24 33 -43 54 -66 79 -93 [16] 108 -124 141 -159 178 . print((1:20)[a&gt;12]) . [1] 8 10 12 14 16 18 20 . 답은 (4) 8이다. . &#49689;&#51228; . - 2021(가) 9월/평가원 10(고3) 에 해당하는 수열을 40번째 항까지 구하라. .",
            "url": "https://guebin.github.io/2021IR/2021/09/16/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9416%EC%9D%BC.html",
            "relUrl": "/2021/09/16/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9416%EC%9D%BC.html",
            "date": " • Sep 16, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "(2주차) 9월14일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/1) 벡터의 원소를 뽑는법, 메인플랏과 서브플랏, 주석이용법 . &#48289;&#53552;&#51032; &#50896;&#49548;&#47484; &#48977;&#45716; &#48169;&#48277; . x&lt;-c(1,2,-2,4,5,-5,6) x . [1] 1 2 -2 4 5 -5 6 . &#50896;&#49548;&#46308;&#51032; &#48264;&#54840;&#47484; &#48520;&#47084;&#49436; &#48977;&#50500;&#45240;&#45796;. . - 첫 원소를 뽑고싶다. . x[1] . [1] 1 . - 세번째 원소를 뽑고싶다. . x[3] . [1] -2 . - 첫번째부터 세번째까지의 원소를 뽑고싶다. . x[1:3] . [1] 1 2 -2 . x[c(1,2,3)] . [1] 1 2 -2 . - 2,5,6 번째의 원소를 뽑고싶다면? . x[c(2,5,6)] . [1] 2 5 -5 . - 3번째 원소를 제외하고 호출 . x[-3] . [1] 1 2 4 5 -5 6 . - 3,4번째의 원소를 제외하고 호출 . x[c(-3,-4)] . [1] 1 2 5 -5 6 . x[-(3:4)] . [1] 1 2 5 -5 6 . &#50612;&#46496;&#54620; &#51312;&#44148;&#51012; &#51452;&#44256;, &#44536; &#51312;&#44148;&#50640; &#47564;&#51313;&#54616;&#45716; &#50896;&#49548; (&#54841;&#51008; &#47564;&#51313;&#54616;&#51648; &#50506;&#45716; &#50896;&#49548;)&#47484; &#48977;&#45716;&#48277; . x&lt;-c(1,2,-2,4,5,-5,6) x . [1] 1 2 -2 4 5 -5 6 . - 양수인 원소를 뽑는법 . (1) 양수인지 스스로 판단 . (2) 양수라면 나간다. . x&gt;0 . [1] TRUE TRUE FALSE TRUE TRUE FALSE TRUE . - x&gt;0이 결과는 TRUE, FALSE가 포함된 벡터 . x[x&gt;0] . [1] 1 2 4 5 6 . - 3보다 큰 원소를 뽑는 방법 . x[x&gt;3] . [1] 4 5 6 . - 3번째 원소를 뽑아라. . array_ = c(FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE) array_ . [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE . x[array_] . [1] -2 . - 값이 -2인 원소를 뽑아라. . x[x == -2] . [1] -2 . - 응용예제 . x&lt;- c(1,2,3,4,5) y&lt;- x^2 . x . [1] 1 2 3 4 5 . y . [1] 1 4 9 16 25 . $y=x^2=9$가 되도록 만드는 $x$를 알려줘! . x[y==9] . [1] 3 . &#44536;&#47548;&#51012; &#44536;&#47540; &#46412; &#44592;&#50613;&#54624; &#44163; . - 그림자체를 생성해주는 plot과 같은 명령이 있고, 생성된 그림에 덧붙여서만 그릴 수 있는 lines, points, abline 과 같은 함수가 있다. . - 생성된 그림에 덧붙여서 그릴 수 있는 함수들은 단독으로 쓸 수 없다. . x&lt;-1:60/10 x . [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 [20] 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 [39] 3.9 4.0 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 5.5 5.6 5.7 [58] 5.8 5.9 6.0 . y&lt;-sin(x) y . [1] 0.09983342 0.19866933 0.29552021 0.38941834 0.47942554 0.56464247 [7] 0.64421769 0.71735609 0.78332691 0.84147098 0.89120736 0.93203909 [13] 0.96355819 0.98544973 0.99749499 0.99957360 0.99166481 0.97384763 [19] 0.94630009 0.90929743 0.86320937 0.80849640 0.74570521 0.67546318 [25] 0.59847214 0.51550137 0.42737988 0.33498815 0.23924933 0.14112001 [31] 0.04158066 -0.05837414 -0.15774569 -0.25554110 -0.35078323 -0.44252044 [37] -0.52983614 -0.61185789 -0.68776616 -0.75680250 -0.81827711 -0.87157577 [43] -0.91616594 -0.95160207 -0.97753012 -0.99369100 -0.99992326 -0.99616461 [49] -0.98245261 -0.95892427 -0.92581468 -0.88345466 -0.83226744 -0.77276449 [55] -0.70554033 -0.63126664 -0.55068554 -0.46460218 -0.37387666 -0.27941550 . - plot은 단독으로 그림을 만드는 함수, lines는 만들어진 그림에 덧붙이는 함수 . plot(x,y,type=&#39;l&#39;,col=&#39;red&#39;) lines(x,y^2,col=&#39;blue&#39;) . - lines를 먼저 사용하면 이미 만들어진 그림이 없는 상태이므로 error가 발생 . lines(x,y^2,type=&#39;l&#39;,col=&#39;red&#39;) plot(x,y,type=&#39;l&#39;,col=&#39;blue&#39;) . Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet Traceback: 1. lines(x, y^2, type = &#34;l&#34;, col = &#34;red&#34;) 2. lines.default(x, y^2, type = &#34;l&#34;, col = &#34;red&#34;) 3. plot.xy(xy.coords(x, y), type = type, ...) . - 다양한 명령어들 비교 . plot(x,y)와 plot(x,y,type=&#39;l&#39;)을 비교해보기 | plot(x,y)와 plot(x,y,col=&#39;red&#39;)를 비교해보기 | plot(x,y)와 lines(x,y**2)를 같이 그려보기 | plot(x,y)와 points(x,y**2)를 같이 그려보기 | . &#51452;&#49437;&#51060;&#50857;&#48169;&#48277; . - 사용법 . a&lt;- 1 a&lt;- a+1 a&lt;- a+1 print(a) . [1] 3 . a&lt;- 1 #a&lt;- a+1 a&lt;- a+1 print(a) . [1] 2 . - 왜 쓰는지? (1) 코드 test (2) 설명을 쓰고싶을때 . a&lt;- 1 # a에 1을 대입하라. #a&lt;- a+1 a&lt;- a+1 # a의 값을 1증가하라. print(a) . [1] 2 . &#49689;&#51228; . 아래의 4개중 하나를 골라 비교해보고 결과를 캡쳐하여 LMS에 제출 . plot(x,y)와 plot(x,y,type=&#39;l&#39;)을 비교해보기 | plot(x,y)와 plot(x,y,col=&#39;red&#39;)를 비교해보기 | plot(x,y)와 lines(x,y**2)를 같이 그려보기 | plot(x,y)와 points(x,y**2)를 같이 그려보기 | .",
            "url": "https://guebin.github.io/2021IR/2021/09/14/(2%EC%A3%BC%EC%B0%A8)-9%EC%9B%9414%EC%9D%BC.html",
            "relUrl": "/2021/09/14/(2%EC%A3%BC%EC%B0%A8)-9%EC%9B%9414%EC%9D%BC.html",
            "date": " • Sep 14, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "(2주차) 9월9일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8): 과제제출 연장안내 . - (2/8): 아나콘다 설치 1 . - (3/8): 아나콘다 설치 2, 주피터랩을 사용하여 R실습해보기 . - (4/8): 변수이름 선언하기 . - (5/8): 변수이름 선언하는 팁 . - (6/8): 벡터선언하기 1 . - (7/8): 벡터선언하기 2, 함수선언 . - (8/8): 과제설명 . &#48320;&#49688;&#51060;&#47492;&#50640; &#50612;&#46496;&#54620; &#44050;&#51012; &#45347;&#45716; &#48169;&#48277; . - 방법1 . d=1 . - 방법2 . e &lt;- 3 . &#51452;&#51032;&#54624;&#51216;: &#50424; &#49688; &#50630;&#45716; &#48320;&#49688;&#47749;&#51060; &#51080;&#45796;. . (1) 특수문자 불가능 . a! &lt;- 3 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:2: unexpected &#39;!&#39; 1: a! ^ Traceback: . (2) 숫자로 시작하는 변수이름 불가능 . 2a &lt;- 3 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:2: unexpected symbol 1: 2a ^ Traceback: . a2 &lt;- 3 . 이것은 가능 (숫자로 시작되면 안되는 것이지 숫자를 포함하지 말라는 의미는 아님) | . (3) 띄어쓰기 불가능 . Guebin Choi &lt;- 33 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:8: unexpected symbol 1: Guebin Choi ^ Traceback: . this_is_333 &lt;- 333 . 띄어쓰기 대신 언더바(_)를 활용한다. | . this.is.777 &lt;- 777 . 언더바 말고 닷(.)을 선호하는 사람도 있다. | . (4) 언더바를 포함하는 것은 가능하지만, 언더바로 시작하는 변수명은 사용할 수 없다. ` . _x &lt;- 33 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:1: unexpected input 1: _ ^ Traceback: . (5) 사용할 수는 있지만 권장하지 않는 변수이름 . pi . [1] 3.141593 . pi&lt;-333 . pi . [1] 333 . (6) 팁.. . - 변수를 축약할때 모음을 제외하면 좋다. . result -&gt; rslt | residual -&gt; rsdl | . - 임시로 변수명을 사용해야 할 경우: 변수이름 끝에 언더바를 붙인다. . x , y, rslt_, ... | . &#48289;&#53552;&#47484; &#49440;&#50616;&#54616;&#45716; &#48169;&#48277; . - 방법1: 직접 입력 . c(1,2,3,3,4,5,2) . [1] 1 2 3 3 4 5 2 . - 방법2: seq 를 이용 . seq(from=0,to=10,by=0.1) # 0~10 까지 0.1의 간격으로 수열만들기 . [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 [16] 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 [31] 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 4.0 4.1 4.2 4.3 4.4 [46] 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 5.5 5.6 5.7 5.8 5.9 [61] 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 6.8 6.9 7.0 7.1 7.2 7.3 7.4 [76] 7.5 7.6 7.7 7.8 7.9 8.0 8.1 8.2 8.3 8.4 8.5 8.6 8.7 8.8 8.9 [91] 9.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0 . seq(from=0, to=1, length.out = 27) # 0~1 까지 등간격으로 총 27개의 수열만들기 . [1] 0.00000000 0.03846154 0.07692308 0.11538462 0.15384615 0.19230769 [7] 0.23076923 0.26923077 0.30769231 0.34615385 0.38461538 0.42307692 [13] 0.46153846 0.50000000 0.53846154 0.57692308 0.61538462 0.65384615 [19] 0.69230769 0.73076923 0.76923077 0.80769231 0.84615385 0.88461538 [25] 0.92307692 0.96153846 1.00000000 . - 방법3: : 를 이용 . 1:22 . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 . 이 방법을 살짝 응용하면 0~1까지 57개의 변수를 넣는 방법을 아래와 같이 할 수 있다. . print(0:56 / 56) . [1] 0.00000000 0.01785714 0.03571429 0.05357143 0.07142857 0.08928571 [7] 0.10714286 0.12500000 0.14285714 0.16071429 0.17857143 0.19642857 [13] 0.21428571 0.23214286 0.25000000 0.26785714 0.28571429 0.30357143 [19] 0.32142857 0.33928571 0.35714286 0.37500000 0.39285714 0.41071429 [25] 0.42857143 0.44642857 0.46428571 0.48214286 0.50000000 0.51785714 [31] 0.53571429 0.55357143 0.57142857 0.58928571 0.60714286 0.62500000 [37] 0.64285714 0.66071429 0.67857143 0.69642857 0.71428571 0.73214286 [43] 0.75000000 0.76785714 0.78571429 0.80357143 0.82142857 0.83928571 [49] 0.85714286 0.87500000 0.89285714 0.91071429 0.92857143 0.94642857 [55] 0.96428571 0.98214286 1.00000000 . 물론 아래와 같이하는것이 더 가독성이 좋다. . print(seq(from=0,to=1,length.out =57)) . [1] 0.00000000 0.01785714 0.03571429 0.05357143 0.07142857 0.08928571 [7] 0.10714286 0.12500000 0.14285714 0.16071429 0.17857143 0.19642857 [13] 0.21428571 0.23214286 0.25000000 0.26785714 0.28571429 0.30357143 [19] 0.32142857 0.33928571 0.35714286 0.37500000 0.39285714 0.41071429 [25] 0.42857143 0.44642857 0.46428571 0.48214286 0.50000000 0.51785714 [31] 0.53571429 0.55357143 0.57142857 0.58928571 0.60714286 0.62500000 [37] 0.64285714 0.66071429 0.67857143 0.69642857 0.71428571 0.73214286 [43] 0.75000000 0.76785714 0.78571429 0.80357143 0.82142857 0.83928571 [49] 0.85714286 0.87500000 0.89285714 0.91071429 0.92857143 0.94642857 [55] 0.96428571 0.98214286 1.00000000 . - 방법4: rep를 이용 . rep(0,100) . [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 . &#54632;&#49688;&#49324;&#50857;&#54616;&#45716; &#48169;&#48277; . - 기본 구조 . 함수이름 &lt;- function(입력){ 함수의 기능 return(출력) } . f&lt;-function(d){ I0=1 Id=I0*0.25 y=I0*2^(-0.25*d)/Id return(y) } . f(8) . [1] 1 . - 아래의 2개의 코드는 거의 같다. . ### 1 f&lt;-function(d){ I0=1 Id=I0*0.25 y=I0*2^(-0.25*d)/Id return(y) } f(8) ### 2 d=8 I0=1 Id=I0*0.25 y=I0*2^(-0.25*d)/Id . [1] 1 . - return을 생략해도 괜찮다. . f&lt;-function(d){ I0=1 Id=I0*0.25 y=I0*2^(-0.25*d)/Id y } f(8) . [1] 1 . &#49689;&#51228; . - 주피터랩으로 R실습할 수 있는 환경을 설정 .",
            "url": "https://guebin.github.io/2021IR/2021/09/09/(2%EC%A3%BC%EC%B0%A8)-9%EC%9B%949%EC%9D%BC.html",
            "relUrl": "/2021/09/09/(2%EC%A3%BC%EC%B0%A8)-9%EC%9B%949%EC%9D%BC.html",
            "date": " • Sep 9, 2021"
        }
        
    
  
    
        ,"post19": {
            "title": "(1주차) 9월7일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/2): 2005년 예비평가(나) 12월/평가원26(고3) 첫번째 풀이 . - (2/2): 2005년 예비평가(나) 12월/평가원26(고3) 다양한 풀이 + 과제설명 . R&#51008; &#51339;&#51008; &#44228;&#49328;&#44592; &#51060;&#45796;. . 2005&#45380; &#50696;&#48708;&#54217;&#44032;(&#45208;) 12&#50900;/&#54217;&#44032;&#50896;26(&#44256;3) . 어떤 호수에서 수면에서의 빛의 세기가 $I_0$일 때, 수면이 $d$m인 곳에서의 빛의 세기 $I_d$는 다음과 같이 나타내어진다고 한다. . $$I_d=I_0 2^{-0.25d}$$ . 이 호수에서 빛의 세기가 수면에서의 빛의 세기의 25%인 곳의 수심은? (3점) . (1) 16m . (2) 12m . (3) 10m . (4) 8m . (5) 4m . (풀이1) . I0=1 d=8 Id=I0*0.25 . I0*2^(-0.25*d) ## 0.25 랑 비슷하면 된다. 현재는 Id=0.25니까.. . [1] 0.25 . (풀이2) . d=8 y=I0*2^(-0.25*d)/Id y . [1] 1 . - $y=1$이 나오는 $d$를 찾아보면된다. $ to$ 찾아보니까 $d=8$ . (풀이3) . - 함수라는걸 만들어보자. . - $d$를 입력하면, 알아서 $y$가 계산되면 좋겠다. . $$y=f(d)$$ . f&lt;-function(d){ y=I0*2^(-0.25*d)/Id y } . - $y=f(d)= frac{I_0 2^{-0.25 d}}{I_d}$ 를 함수를 만들자. . - $y=1$이 되는 $d$를 찾아보자. 그러면 답이다. . f(8) . [1] 1 . - $d=8$이 답이다. . (풀이4) . - $(d,f(d))$ 혹은 $(d,y)$를 그래프로 그려보자. . d&lt;-c(1,2,3) . d&lt;-seq(from=0,to=10,by=0.01) . y=I0*2^(-0.25*d)/Id . plot(d,y) . plot(d,y) abline(h=1,col=2,lwd=5,lty=3) . (풀이5) . x_&lt;-c(1,2,3,2,5) . x_ == 3 . [1] FALSE FALSE TRUE FALSE FALSE . d[y==1] . [1] 8 . &#49689;&#51228; . - 아래그림에서 수평선의 위치를 $y=2$로 조정하여 그려볼것 . plot(d,y) abline(h=1.1,col=2,lwd=5,lty=3) .",
            "url": "https://guebin.github.io/2021IR/2021/09/07/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%947%EC%9D%BC.html",
            "relUrl": "/2021/09/07/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%947%EC%9D%BC.html",
            "date": " • Sep 7, 2021"
        }
        
    
  
    
        ,"post20": {
            "title": "(1주차) 9월2일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/3): R소개 , R을 활용한 간단한 계산 . - (2/3): 통계학과 진로, 통계학과의 장점, 강의계획안내 . - (3/3): R설치방법, 과제안내 . &#47112;&#54252;&#53944; . - 카카오톡 스샷제출 .",
            "url": "https://guebin.github.io/2021IR/2021/09/02/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%942%EC%9D%BC.html",
            "relUrl": "/2021/09/02/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%942%EC%9D%BC.html",
            "date": " • Sep 2, 2021"
        }
        
    
  
    
        ,"post21": {
            "title": "(A1) 깃허브와 fastpages를 이용하여 블로그 개설하기",
            "content": "About this doc . - 본 포스트는 2021년 1학기 Python 입문 강의내용중 일부를 업로드 하였음. . - Github, fastpages를 사용하여 블로그를 개설하고 관리하는 방법에 대한 설명임. . .",
            "url": "https://guebin.github.io/2021IR/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0-Copy1.html",
            "relUrl": "/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0-Copy1.html",
            "date": " • Aug 17, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "최규빈 . guebin@jbnu.ac.kr | 자연과학대학교 본관 205호 | 카카오톡 오픈채널 1 | . 2021년 2학기 종료후 폐쇄예정 &#8617; . |",
          "url": "https://guebin.github.io/2021IR/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://guebin.github.io/2021IR/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}