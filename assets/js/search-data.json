{
  
    
        "post0": {
            "title": "파이썬입문 겨울방학 특강 (2)",
            "content": "- 오늘오전: 자료형, 오브젝트 .. . - 오늘오후: 참조, 얕은복사, 깊은복사 . - 내일오전: 뷰와 카피 . - 내일오후: 개발환경 비교 . &#52280;&#51312;&#50752; &#50640;&#51068;&#47532;&#50612;&#49905; . - 아래의 코드를 관찰하자. . a=[1,2,3] b=a a=a+[4] . 현재 a,b의 출력결과는? . a,b . ([1, 2, 3, 4], [1, 2, 3]) . - 이제 다시 아래의 코드를 관찰하자. . a=[1,2,3] b=a a.append(4) . a,b . ([1, 2, 3, 4], [1, 2, 3, 4]) . - 아래의 코드를 다시 살펴보자. . a=[1,2,3] b=a a.append(4) . a,b라는 변수들은 메모리에 어떻게 저장이 되어있을까? . 상상력을 조금 발휘하면 아래와 같이 여길 수 있다. . (1) 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자. . (2) 아래를 실행하였을 경우 . a=[1,2,3] . 메모리주소1에 존재하는 방을 a라고 하고, 그 방에 [1,2,3]을 넣는다. | . (3) 아래를 실행하였을 경우 . b=a . 메모리주소38에 존재하는 방을 b라고 하고, 그 방에 a를 넣어야하는데, a는 [1,2,3]이니까 [1,2,3]을 넣는다. | . (4) 아래를 실행하면 . a.append(4) . 방 a로가서 [1,2,3]을 [1,2,3,4]로 바꾼다. | 그리고 방 b에는 아무것도 하지 않는다. | . - R에서는 맞는 비유인데, 파이썬은 적절하지 않은 비유이다. . id(a) . 139851743661952 . id(b) . 139851743661952 . 실제로는 a,b가 저장된 메모리 주소가 동일함 . - 파이썬에서는 아래가 더 적절한 비유이다. . (1) 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자. . (2) 아래를 실행하였을 경우 . a=[1,2,3] . 메모리주소139851743661952에서 [1,2,3]을 생성해요 | 방 139851743661952의 방문에 a라는 포스트잇을 붙인다. | 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 a라는 포스트잇이 붙은 방을 찾아가면 된다. | . (3) 아래를 실행하였을 경우 . b=a . a라는 포스트잇이 있는데, a라는 포스트잇이랑 b라는 포스트잇과 같은 효과를 주도록 한다. | 쉽게말하면 b라는 포스트잇을 방 139851743661952의 방문에 붙인다는 이야기. | 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 a라는 포스트잇이 붙어 있거나 b라는 포스트잇이 붙어있는 방을 찾아가면 된다. | . (4) 아래를 실행하면 . a.append(4) . a라는 포스트잇이 붙어있는 방으로 가서, 그 내용물 append함수를 써서 4를 추가하라. 즉 내용물 [1,2,3]을 [1,2,3,4]로 바꾸라. | 같은방에 a,b라는 포스트잇이 모두 붙어있음. 따라서 b라는 포스트잇이 붙은 방을 찾아가서 내용물을 열어보면 [1,2,3,4]가 나온다. | . &#54624;&#45817;&#47928;(=)&#51032; &#51060;&#54644; . - 파이썬에서 할당문을 이해하기 위해서는 언제나 오른쪽을 먼저 읽어야 한다. . 할당문의 오른쪽에서는 객체를 생성하거나 가져옴 | 그 후에 라벨을 붙이듯이 할당문 왼쪽의 변수가 할당문 오른쪽의 객체에 바인딩 된다. (참조) | . - b=a는 . 나는 이미 a가 의미하는게 무엇인지 알고있어. 그런데 그 실체를 b라고도 부르고 싶어. . 라는 것과 같다. 즉 이미 a라고 부르고 있는것을 내가 b라고도 부르고싶다는 의미인데 이는 마치 별명과 같다. (b는 a의 별명, alias) 그리고 이처럼 하나의 오브젝트에 여러개의 이름을 붙이는 것을 에일리어싱이라고 부른다. . - 참조: 하나의 메모리 주소에 변수의 이름을 바인딩하는 것을 참조라고 한다. . - 에일리어싱: 하나의 메모리 주소에 여러개의 변수이름을 바인딩 하는 것을 에일리어싱이라고 한다. . id, value . - 아래의 예제를 살펴보자. . a=[1,2,3] b=a a.append(4) c=[1,2,3,4] . 여기에서 a,b,c는 모두 같은 value를 가진다. . a . [1, 2, 3, 4] . b . [1, 2, 3, 4] . c . [1, 2, 3, 4] . 하지만 그 id까지 같은 것은 아니다. . id(a), id(b), id(c) . (139851739924096, 139851739924096, 139851742724800) . - 이제 다시 아래의 코드를 살펴보자. . a=[1,2,3] b=a a=[1,2,3]+[4] . a,b . ([1, 2, 3, 4], [1, 2, 3]) . id(a),id(b) . (139851742145536, 139851743152000) . &#51060;&#53552;&#45789; . - 참조의 개념은 확실하게 알겠음. 이제 아래의 예제를 살펴보자. . a=1+2 id(a) . 139852067748208 . b=4-1 id(b) . 139852067748208 . 이게 왜 똑같지..? . (해설) 파이썬의 경우 효율성을 위해서 -5~256까지의 정수를 미리 저장해둠. . id(22) . 139852067748816 . - 이제 아래의 예제를 살펴보자. . a=1+2021 id(a) . 139851741177168 . b=2023-1 id(b) . 139851741254000 . id(2022) . 139851741253744 . copy . - 아래의 예제를 살펴보자. (참조를 제대로 이해했다면 아래의 예제는 자연스럽게 이해가능) . l1 = [3, [66,55,44]] l2 = l1 . id(l1),id(l2) . (139851740541056, 139851740541056) . l1[0]=4 . l1 . [4, [66, 55, 44]] . l2 . [4, [66, 55, 44]] . l2.append(5) . l2 . [4, [66, 55, 44], 5] . l1 . [4, [66, 55, 44], 5] . - R과 같은 방식으로 =를 사용하고 싶다면? . l1 = [3, [66,55,44]] l2 = l1.copy() . id(l1),id(l2) ## 드디어 주소가 달라졌다. . (139851741022656, 139851741533184) . l1[0]=100 . l1 . [100, [66, 55, 44]] . l2 . [3, [66, 55, 44]] . - 이제 다 이해했다고 생각했는데.. . l1 = [3,[66,55,44]] l2 = l1.copy() . id(l1),id(l2) . (139851987671936, 139851740745472) . l1[1].append(33) . l1 . [3, [66, 55, 44, 33]] . l2 . [3, [66, 55, 44, 33]] . 왜 또 참조한것마냥 l1과 l2가 같이 바뀌고 있지? . - 위의 문제를 해설하여 보자. (주의: 해설이 좀 길어요) . (상황1) . a=2222 b=2222 . id(a),id(b) . (139851743195216, 139851743195440) . 현재 메모리 상황 . -5~256 까지의 숫자는 어딘가에 저장되어 있음 | 2222라는 오브젝트가 어떤공간에 생성되고 그 공간에 a라는 라벨이 붙음 | 2222라는 오브젝트가 어떤공간에 생성되고 그 공간에 b라는 라벨이 붙음 | . 즉 -5~256 이외의 2개의 메모리 공간을 추가적으로 사용 . (상황2) 이제 아래의 상황을 살펴보자 . a=[1,2,2222] b=[1,2,2222] . id(a),id(b) . (139851740010880, 139851742120448) . id(a[0]),id(b[0]) . (139852067748144, 139852067748144) . id(a[1]),id(b[1]) . (139852067748176, 139852067748176) . id(a[2]),id(b[2]) . (139851743195248, 139851743195568) . a.append(4) . a . [1, 2, 2222, 4] . b . [1, 2, 2222] . 해설을 다시 해보면 아래와 같다. . -5~256까지의 숫자가 메모리에 저장되어 있다. | 2222가 어떤 공간에 저장된다. 공간 X1이라고 하자. | 리스트오브젝트가 만들어지고 원소로 1,2,2222를 가짐. 이 공간을 a라고 부름. | 2222가 어떤 공간에 저장된다. 공간을 X2라고 하자. | 리스트오브젝트가 만들어지고 원소로 1,2,2222를 가짐. 이 공간을 b라고 부름. | 공간 a에 원소 4를 추가시킴. | . 즉 -5~256이외에 4개의 메모리 공간을 추가사용 . X1: 2222 | X2: 2222 | a = 1,2,공간X1의값 --&gt; append를 쓰면 1,2,공간X1의값,4 | b = 1,2,공간X2의값 | . (상황3) . l1 = [3,[66,55,44]] l2 = l1.copy() l1[1].append(33) . 해설을 해보자. . -5~256까지의 숫자가 메모리에 저장되어 있다. | [66,55,44]가 저장되는 공간이 생성됨. 이 공간을 X1 | [3,[66,55,44]]가 저장되는 공간이 생성됨. 이 공간을 l1 | 공간 l2가 만들어지고 그 안에 리스트가 있음. 리스트의 첫번째원소는 3, 두번째원소는 공간X1의 값. | 공간X1의 값에 접근하여 33을 추가함. 즉 공간 X1의 값을 [66,55,44]에서 [66,55,44,33]으로 변경 | . 따라서 . l1 = [3, 공간X1의 값] | l2 = [3, 공간X2의 값] | l1[1].append(33) 을 하는 순간 공간 x1의 값이 [66,55,44]에서 [66,55,44,33]으로 변경 | . - 결국 아래의 2개의 코드는 다른 코드임 . a=[2222,3333] b=[2222,3333] . id(a),id(b) . (139851750028864, 139851740431104) . id(a[0]),id(b[0]) . (139851743196432, 139851743196336) . id(a[1]),id(b[1]) . (139851743196240, 139851743196752) . a=[2222,3333] b=a.copy() . id(a),id(b) . (139851739986112, 139851739526784) . id(a[0]),id(b[0]) . (139851743196912, 139851743196912) . id(a[1]),id(b[1]) . (139851743196848, 139851743196848) . - 결국 *.copy() 메소드는 깊은곳까지 복사를 하지 않음. (메모리를 너무 아낀다.) . - 사실 그런데 이렇게 해도 평소에는 티가 잘 안난다. . a=[2222,3333] b=a.copy() . a . [2222, 3333] . b . [2222, 3333] . b[1]=4444 . b . [2222, 4444] . id(a),id(b) . (139851740984000, 139851740712640) . id(a[0]),id(b[0]) . (139851743197456, 139851743197456) . id(a[1]),id(b[1]) . (139851743197392, 139851743197488) .",
            "url": "https://guebin.github.io/2021IR/2022/01/03/WINIP2.html",
            "relUrl": "/2022/01/03/WINIP2.html",
            "date": " • Jan 3, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "파이썬입문 겨울방학 특강 (1)",
            "content": "- 오늘오전: 자료형, 오브젝트 .. . - 오늘오후: 참조, 얕은복사, 깊은복사 . - 내일오전: 뷰와 카피 . - 내일오후: 개발환경 비교 . a=[1,2,3] . a . [1, 2, 3] . b=a . b . [1, 2, 3] . a.append(4) . a . [1, 2, 3, 4] . b . [1, 2, 3, 4] . 0&#52264;&#50896; &#51088;&#47308;&#54805;&#51032; &#49548;&#44060; . - 0차원 자료형: 하나의 값을 저장할 수 있는 자료형 . - int, bool, float . a=100 . type(a) . int . a=1.2*3 a . 3.5999999999999996 . type(a) . float . a=True b=False . type(a) . bool . - 0차원 자료형이 int, bool, float 3개만 있는 것은 아니다. . a=1+1j b=2-2j . type(a) . complex . c=a+b c . (3-1j) . type(c) . complex . 잘 쓰지 않음 | . 0&#52264;&#50896; &#51088;&#47308;&#54805;&#51032; &#48320;&#54872; . - float $ to$ int . a=3.14122222 a . 3.14122222 . b=int(a) b . 3 . - int $ to$ float . a=3 type(a) . int . b=float(a) type(b) . float . - bool $ to$ int, bool $ to$ float (이게 가능하지 않을것 같지만 사실 가능함) . a=True int(a) . 1 . float(a) . 1.0 . b=False int(b) . 0 . float(b) . 0.0 . - &quot;이런건 변환 못하겠지?&quot; 싶은것도 바꿔줌 . bool(-3.14) . True . 저는 이런걸 쓰지 않아요.. | . - 형변환이 항상 성공하는것은 아님 (규칙은 잘 모르겠음) . float(3+0j) . TypeError Traceback (most recent call last) &lt;ipython-input-48-804a051fe87a&gt; in &lt;module&gt; -&gt; 1 float(3+0j) TypeError: can&#39;t convert complex to float . - 묵시적 형변환 (약간 눈치주는 느낌) . explicit: 온풍기를 좀 키자.. | implicit: 날이 좀 춥지 않어..? (온풍기좀 틀자는 이야기) | . True*1 . 1 . 1을 곱해야하는데..? 너 계속 bool형태로 있을거야?? | . 1*1.0 . 1.0 . 1.0을 곱할건데..? 너 계속 int형으로 있을거야?? | . 1&#52264;&#50896; &#51088;&#47308;&#54805;&#51032; &#49548;&#44060; . - 기본적인 1차원 자료형은 리스트와 튜플이 있다. . a=[1,2,3] ## 리스트 a . [1, 2, 3] . type(a) . list . b=(1,2,3) ## 튜플 b . (1, 2, 3) . type(b) . tuple . - 리스트와 튜플 모두 원소에 접근하기 위해서 []를 사용한다. (R과 동일) . a[0] . 1 . a[1] . 2 . a[2] . 3 . b[0] . 1 . b[1] . 2 . b[2] . 3 . - 리스트는 원소의 값을 바꿀 수 있지만 튜플은 바꿀 수 없다. . a . [1, 2, 3] . a[0]=100 . a . [100, 2, 3] . b . (1, 2, 3) . b[0]=100 . TypeError Traceback (most recent call last) &lt;ipython-input-67-2a3fb166f233&gt; in &lt;module&gt; -&gt; 1 b[0]=100 TypeError: &#39;tuple&#39; object does not support item assignment . - 문자열도 1차원자료형으로 생각한다. (조금 의외임) . a=&#39;guebin&#39; . type(a) . str . a[0] . &#39;g&#39; . a[1] . &#39;u&#39; . - 그밖에 집합, 딕셔너리와 같은 1차원 자료형도 있다. (여기서는 자세히 다루지 않음) . s={1,2,3,4,4} . s . {1, 2, 3, 4} . type(s) . set . d={&#39;a&#39;:123,&#39;b&#39;:234 ,&#39;c&#39;:233} d . {&#39;a&#39;: 123, &#39;b&#39;: 234, &#39;c&#39;: 233} . type(d) . dict . d[&#39;a&#39;] . 123 . d[0] . KeyError Traceback (most recent call last) &lt;ipython-input-93-123a9cc6df61&gt; in &lt;module&gt; -&gt; 1 d[0] KeyError: 0 . - 원소에 접근할 수 있는 자료형인지 없는 자료형인지 파악하는 방법? . dir()을 사용했을 경우 __getitem__ 이 보이면 원소에 접근할 수 있는 자료형임. | . a=[1,2,3] a.__getitem__? . Docstring: x.__getitem__(y) &lt;==&gt; x[y] Type: builtin_function_or_method . a.__getitem__(1) ## a[1] . 2 . &#47532;&#49828;&#53944;&#44277;&#48512; 1&#45800;&#44228; . - 리스트의 선언 . a=[1,2,3] a . [1, 2, 3] . type(a) . list . - 비어있는 리스트를 선언 . a=list() ## 방법1 a . [] . a=[] ## 방법2 a . [] . - 리스트에서 +의 의미 . a=[1,2,3] b=[4,5,6] a+b . [1, 2, 3, 4, 5, 6] . 충격.. 리스트에서는 + 연산자를 쓰면 우리가 상식적으로 생각하는 벡터연산이 수행되지 않음. | . - 리스트에서 *의 의미 . a=[1,2,3] a+a . [1, 2, 3, 1, 2, 3] . a*2 ## a+a?? . [1, 2, 3, 1, 2, 3] . [1]*10 . [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] . - 예제: 비어있는 리스트를 만들고 [1], [2], [3]을 각각 더하여 원소를 추가해보자. . a=[] a . [] . a=a+[1] a . [1] . a=a+[2] a . [1, 2] . a=a+[3] a . [1, 2, 3] . &#47532;&#49828;&#53944;&#44277;&#48512; 2&#45800;&#44228; . - 리스트에서 원소를 추가하는 또 다른 방법 . a = [] a += [1] a += [2] a += [3] a . [1, 2, 3] . - 리스트에서 원소를 추가하는 또 또 다른 방법 . a=[] a . [] . a.append(1) a . [1] . a.append(2) a . [1, 2] . a.append(3) a . [1, 2, 3] . - a.append(1)이라는 문법이 너무 낯설어요 $ to$ 당연해요 . 파이썬 특징: 모든 변수명 뒤에 .을 붙이면 그 변수에 특화된 새로운 기능을 쓸 수 있다. (파이썬에서 변수는 단순히 정보가 담긴 그릇을 의미하는 것이 아니다. 기능이 있다.) | 장점: 초보자라도 눈치껏 문법을 배우기 편하다. | 단점: 처음에는 너무 이해하기 난해함. | . - 마음의 눈 . a.f() = f(a) 로 생각하면 편리함 | a.f(2) = f(a,2) 로 생각하면 편리함. | 이러한 점에서 R의 %&gt;% 연산자와 유사하다고 생각할 수 있음 (사실 약간 다르긴해요) | . - 리스트 특화기능 (=특화함수=메소드) . (append) . a.append? . Signature: a.append(object, /) Docstring: Append object to the end of the list. Type: builtin_function_or_method . a=[1,2,3] a.append(4) a . [1, 2, 3, 4] . (clear) . a.clear? . Signature: a.clear() Docstring: Remove all items from list. Type: builtin_function_or_method . a=[1,2,3] a.clear() a . [] . (copy) . a.copy? . Signature: a.copy() Docstring: Return a shallow copy of the list. Type: builtin_function_or_method . a=[1,2,3] b=a.copy() b . [1, 2, 3] . (count) . a.count? . Signature: a.count(value, /) Docstring: Return number of occurrences of value. Type: builtin_function_or_method . a=[1,1,2,3.14,3.14] a.count(3.14) . 2 . (extend) . a.extend? . Signature: a.extend(iterable, /) Docstring: Extend list by appending elements from the iterable. Type: builtin_function_or_method . a=[1,2,3] b=[1,2,3,4,5,6] a.extend(b) a . [1, 2, 3, 1, 2, 3, 4, 5, 6] . (index) . a.index? . Signature: a.index(value, start=0, stop=9223372036854775807, /) Docstring: Return first index of value. Raises ValueError if the value is not present. Type: builtin_function_or_method . a=[1,2,3,3,4,4,5,6] a.index(5) . 6 . (insert) . a.insert? . Signature: a.insert(index, object, /) Docstring: Insert object before index. Type: builtin_function_or_method . a=[1,2,3] a.insert(0,88) a . [88, 1, 2, 3] . (pop) . a.pop? . Signature: a.pop(index=-1, /) Docstring: Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. Type: builtin_function_or_method . a=[1,2,3,4] a.pop() a . [1, 2, 3] . a.pop() a . [1, 2] . a.pop() a . [1] . a.pop() a . [] . (remove) . a.remove? . Signature: a.remove(value, /) Docstring: Remove first occurrence of value. Raises ValueError if the value is not present. Type: builtin_function_or_method . a=[1,2,3,44] a.remove(44) . a . [1, 2, 3] . (reverse) . a.reverse? . Signature: a.reverse() Docstring: Reverse *IN PLACE*. Type: builtin_function_or_method . a=[1,2,3] a.reverse() a . [3, 2, 1] . (sort) . a.sort? . Signature: a.sort(*, key=None, reverse=False) Docstring: Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. Type: builtin_function_or_method . a=[1,3,2,4] a.sort() a . [1, 2, 3, 4] . &#47532;&#49828;&#53944;&#44277;&#48512; 3&#45800;&#44228; . &#47532;&#49828;&#53944;&#51032; &#48772;&#49480;&#44284; &#45208;&#45591;&#49480; . - 리스트의 뺄셈: 이런건 없다. . a=[1,2,3,4] a-[1] . TypeError Traceback (most recent call last) &lt;ipython-input-178-fcd9077664c1&gt; in &lt;module&gt; 1 a=[1,2,3,4] -&gt; 2 a-[1] TypeError: unsupported operand type(s) for -: &#39;list&#39; and &#39;list&#39; . - 리스트의 나눗셈: 이런건 없다. . a=[1,2,3,1,2,3] a/2 . TypeError Traceback (most recent call last) &lt;ipython-input-179-0f405c3ca648&gt; in &lt;module&gt; 1 a=[1,2,3,1,2,3] -&gt; 2 a/2 TypeError: unsupported operand type(s) for /: &#39;list&#39; and &#39;int&#39; . a.append(4) &#50752; a+[4] &#51032; &#52264;&#51060;&#51216;? . - a=a+[4]: a는 변화하지 않음. . a=[1,2,3] a+[4] . [1, 2, 3, 4] . a . [1, 2, 3] . - a.append(4): a자체가 변화함 . a=[1,2,3] a.append(4) a . [1, 2, 3, 4] . - 보통 메소드를 쓰면 a자체가 변화할때가 많다. . a=[1,2,3] a.reverse() a . [3, 2, 1] . - 그런데 모든 메소드가 a를 변화시키는 것은 아니다. (명확한 기준은 없는데 왠지 의미상 a를 변화시킬 필요가 없을 것 같은게 있어요..) . a=[1,2,2,3,4] a.count(2) . 2 . a . [1, 2, 2, 3, 4] . len&#51008; list&#51032; &#50896;&#49548;&#47484; &#49464;&#50612;&#49436; &#47532;&#53556;&#54620;&#45796;. . a=[1,2,3,3] len(a) . 4 . a=[] len(a) . 0 . - 아래는 동작하지 않음. . a=[1,2,3] a.len() . AttributeError Traceback (most recent call last) &lt;ipython-input-192-0f2df5fcd2b1&gt; in &lt;module&gt; 1 a=[1,2,3] -&gt; 2 a.len() AttributeError: &#39;list&#39; object has no attribute &#39;len&#39; . [3]&#44284; 3&#51008; &#45796;&#47476;&#45796; . - 다른점1: [3] 1차원, 3은 0차원 자료형 . a=[3] len(a) . 1 . a=3 len(a) . TypeError Traceback (most recent call last) &lt;ipython-input-195-ef5c313af7eb&gt; in &lt;module&gt; 1 a=3 -&gt; 2 len(a) TypeError: object of type &#39;int&#39; has no len() . - 다른점2: +연산 적용시 차이점 . a=[3] a+[4] . [3, 4] . a=3 a+4 . 7 . a=[3] a+4 . TypeError Traceback (most recent call last) &lt;ipython-input-198-51cc563c823d&gt; in &lt;module&gt; 1 a=[3] -&gt; 2 a+4 TypeError: can only concatenate list (not &#34;int&#34;) to list . a=3 a+[4] . TypeError Traceback (most recent call last) &lt;ipython-input-199-62e0fc93f386&gt; in &lt;module&gt; 1 a=3 -&gt; 2 a+[4] TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;list&#39; . &#47532;&#49828;&#53944;&#51032; &#50896;&#49548;&#45716; &#50612;&#46496;&#54620; &#54805;&#53468;&#46020; &#44032;&#45733;&#54616;&#45796;. . - 예제1 . a=[True,3,3.14] a . [True, 3, 3.14] . type(a[0]) . bool . type(a[1]) . int . type(a[2]) . float . 예제1에 대한 디스커션 . 리스트에 포함된 3개의 원소가 모두 다른 자료형을 가지고 있음. | 즉 원소들이 형변환 되지 않음. (Python의 list는 R에서의 벡터보다 리스트에 가까운 느낌이다) | . - 예제2 . a=[[True,3,3.14],True,[3],3] a . [[True, 3, 3.14], True, [3], 3] . 예제2에 대한 디스커션 . 첫번째 원소는 리스트 (1차원) | 두번째 원소는 bool (0차원) | 세번째 원소는 길이가 1인 리스트 (1차원) | 네번째 원소는 int (0차원) | . &#51473;&#52393;&#47532;&#49828;&#53944; . A=[[1,2,3],[4,5,6],[7,8,9]] A . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . - A는 아래와 같은 매트릭스로 생각할 수 있다. . ${ bf A} = begin{bmatrix} 1 &amp; 2 &amp; 3 4 &amp; 5 &amp; 6 7 &amp; 8 &amp; 9 end{bmatrix}$ . - ${ bf A}$에서 (1,1)의 원소를 뽑고싶다! = 1을 뽑고싶음 . A[0,0] . TypeError Traceback (most recent call last) &lt;ipython-input-210-da4621a80edb&gt; in &lt;module&gt; -&gt; 1 A[0,0] TypeError: list indices must be integers or slices, not tuple . 실패 | . A[0][0] . 1 . 성공 | . - 성공의 이유분석 . A . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . A[0] . [1, 2, 3] . A[0][0] . 1 . - ${ bf A}$에서 (2,3)위치의 원소를 뽑아보자. $ to$ 파이썬 인덱스로 치면 (1,2) . A[1][2] . 6 . - 매트릭스는 아니지만 매트릭스 같아! . 1차원 배열을 다차원 배열로 확장할 수 있는 기본아이디어를 제공함 . &#53916;&#54540;&#44277;&#48512; 1&#45800;&#44228; . - 튜플은 ()로 선언한다. . a=(1,2,3) a . (1, 2, 3) . type(a) . tuple . - +로 튜플과 튜플을 합칠 수 있다. . a=(1,2,3) b=(4,5,6) a+b . (1, 2, 3, 4, 5, 6) . - 비어있는 튜플을 선언하는 방법 . a=tuple() a . () . a=() a . () . - 원소가 하나있는 튜플을 만들기 위해서는 아래와 같이 한다. . a=(1,) a . (1,) . a+(2,) . (1, 2) . - 튜플도 리스트와 비슷한 방식으로 원소에 접근한다. . a=(1,2,3) a[0] . 1 . a[1] . 2 . a[2] . 3 . - 튜플은 원소에 접근할 수는 있지만 내용을 바꿀 수는 없다. . a=(1,2,3) a[0] . 1 . a[0]=100 . TypeError Traceback (most recent call last) &lt;ipython-input-232-f96ffea17930&gt; in &lt;module&gt; -&gt; 1 a[0]=100 TypeError: &#39;tuple&#39; object does not support item assignment . - 예제: 빈튜플을 만들어보고 (1,) (2,) (3,) 을 더하여 원소를 추가해보자. . a=() a . () . a=a+(1,)+(2,)+(3,) a . (1, 2, 3) . - 아래와 같은 방식도 가능 . a = () a += (1,) a += (2,) a += (3,) a . (1, 2, 3) . &#53916;&#54540;&#44277;&#48512; 2&#45800;&#44228;: &#53916;&#54540; &#50616;&#54056;&#53433; . - 의미가 명확할때는 ()를 생략할 수 있다. . a = 1,2,3,4,5 a . (1, 2, 3, 4, 5) . 1,2,3 . (1, 2, 3) . 1&#52264;&#50896;&#51088;&#47308;&#54805;&#51032; &#48320;&#54872; . - 리스트를 튜플로 . tuple([1,2,3]) . (1, 2, 3) . - 튜플을 리스트로 . list((1,2,3)) . [1, 2, 3] . numpy . 파이썬은 그렇게 좋은 계산성능을 보유하고 있지 않음 . - 놀라운점1: pi가 없음 . pi . NameError Traceback (most recent call last) &lt;ipython-input-241-f84ab820532c&gt; in &lt;module&gt; -&gt; 1 pi NameError: name &#39;pi&#39; is not defined . - 놀라운점2: sqrt가 없다. . sqrt(2) . NameError Traceback (most recent call last) &lt;ipython-input-242-66e338417901&gt; in &lt;module&gt; -&gt; 1 sqrt(2) NameError: name &#39;sqrt&#39; is not defined . - 사칙연산빼고 되는게 없는것 같은데? . log(10) . NameError Traceback (most recent call last) &lt;ipython-input-243-8fe8026424a0&gt; in &lt;module&gt; -&gt; 1 log(10) NameError: name &#39;log&#39; is not defined . exp(1) . NameError Traceback (most recent call last) &lt;ipython-input-244-a9c50c82dfa5&gt; in &lt;module&gt; -&gt; 1 exp(1) NameError: name &#39;exp&#39; is not defined . sin(0) . NameError Traceback (most recent call last) &lt;ipython-input-245-afbcc558f753&gt; in &lt;module&gt; -&gt; 1 sin(0) NameError: name &#39;sin&#39; is not defined . numpy&#47484; &#50416;&#47732; &#54028;&#51060;&#50028;&#51008; &#51339;&#51008; &#44228;&#49328;&#44592;&#44032; &#46108;&#45796;. . 사용법: library(tidyverse)와 비슷하게 import numpy 를 하면 된다. | . import numpy . numpy.pi . 3.141592653589793 . numpy.sqrt(2) . 1.4142135623730951 . numpy.exp(1) . 2.718281828459045 . numpy.log(2.718281828459045) . 1.0 . numpy.sin(0) . 0.0 . - numpy를 모두 치는 것이 불편함 $ to$ 줄여서 약어로 쓰고싶다. . import numpy as np . np.sqrt(2) . 1.4142135623730951 . np.exp(1) . 2.718281828459045 . np.log(2.718281828459045) . 1.0 . np.sin(0) . 0.0 . numpy &#44277;&#48512;: 1&#45800;&#44228; . - numpy.ndarray 자료형을 만드는 방법 . a=[1,2,3] b=np.array(a) b . array([1, 2, 3]) . - numpy를 사용하면 R과 유사한 환경이 만들어짐 . a+1 . TypeError Traceback (most recent call last) &lt;ipython-input-265-98b939904c8e&gt; in &lt;module&gt; -&gt; 1 a+1 TypeError: can only concatenate list (not &#34;int&#34;) to list . b+1 . array([2, 3, 4]) . np.sqrt(b) . array([1. , 1.41421356, 1.73205081]) . np.log(b) . array([0. , 0.69314718, 1.09861229]) . np.sin(b) . array([0.84147098, 0.90929743, 0.14112001]) . np.exp(b) . array([ 2.71828183, 7.3890561 , 20.08553692]) . ((b+1)+2)/3 . array([1.33333333, 1.66666667, 2. ]) .",
            "url": "https://guebin.github.io/2021IR/2022/01/03/WINIP1.html",
            "relUrl": "/2022/01/03/WINIP1.html",
            "date": " • Jan 3, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "기말고사 안내사항",
            "content": "&#49884;&#54744;&#50976;&#54805; . - 오픈북: 강의노트, 본인이 정리한 노트, 인터넷 검색 가능 . - 비대면: Zoom을 활용하여 응시 . &#49884;&#54744;&#49884;&#44036; . - 일시: LMS를 통해 공지한 날의 수업시간 . - 시험시간 중 처음 30분은 장비점검시간으로 활용함 (단, 모든 사람이 준비될 경우 30분을 기다리지 않고 시작) . . Note: 따라서 R입문의 경우 장비점검에 30분을 모두 사용한다면 실질적으로 문제를 풀고 답안을 제출할때 까지 쓸 수 있는 시간은 30분입니다. . &#49884;&#54744;&#49892; &#51077;&#51109; . - LMS $ to$ 강의대화 $ to$ Zoom 화상강의 바로 가기로 입장 . &#49884;&#54744;&#47928;&#51228; &#44277;&#44060;&#48169;&#49885; . - LMS 공지사항을 통하여 시험문제의 URL을 공개 . &#51228;&#52636;&#48169;&#49885; &#48143; &#54805;&#49885; . - LMS의 레포트 메뉴를 활용하여 답안지를 제출 (종료시간 이전에 미리 제출가능) . - 제출은 Rmarkdown에서 작성된 pdf파일의 형태만 인정한다. 제출파일은 RMD/PDF 파일이다. . &#51456;&#48708;&#47932; . - 컴퓨터 및 노트북: 시험지 확인 및 문제풀이 용도 . - 핸드폰: Zoom을 통하여 주변상황을 및 컴퓨터 화면을 촬영하는 용도 . . Note: 중간에 핸드폰 및 노트북이 꺼지지 않도록 배터리 충전기를 준비한다. . &#49884;&#54744;&#51204; &#51456;&#48708;&#49324;&#54637; . - 시험준비시간 동안 핸드폰을 아래와 같이 배치하여 학생의 컴퓨터 화면 및 주변상황이 보이도록 함 . . Note: 적절한 각도를 설정하기 어려운 경우 주변환경보다 컴퓨터의 화면이 잘 보이도록 설정할 것 . - 학생증을 준비하여 시험 시작 직전에 본인의 얼굴과 학생증을 함께 촬영한다. (5초간) . &#50976;&#51032;&#49324;&#54637; . - 줌의 대화명은 이름과 학번을 모두 적는다. (예시: 최규빈_202143052) . . Note: 동명이인이 있을 수 있으므로 학번을 같이 적으세요 . - 질문은 카카오톡 채널 혹은 줌의 채팅기능을 이용한다. . - Zoom에서 스피커 음소거를 하지 않는다. (전체 공지사항등이 있을때 음성으로 공지함) . - 핸드폰으로 Zoom참가 중 전화가 오면 거절하고 받지 않는다. (전화통화시 Zoom연결이 종료되므로 부정행위로 의심할 수 있음) . &#44592;&#53440; &#52280;&#44256;&#49324;&#54637; . - 핸드폰과 피씨를 이용하여 줌에 동시접속할 경우 . 최규빈_202143052_핸드폰 | 최규빈_202143052_컴퓨터 | . 와 같이 기기를 분리하여 적는다. . - 시험문제는 코랩으로 풀어도 무방하며 시험문제를 다운받아 개인 주피터노트북 등으로 풀어도 무방하다. . - 제출은 RMD와 PDF파일 형태로 제출한다. 그외의 제출형식(.txt, .R, .html, .png)등은 인정하지 않는다. .",
            "url": "https://guebin.github.io/2021IR/2021/12/21/%EC%8B%9C%ED%97%98%EA%B4%80%EB%A0%A8-%EC%95%88%EB%82%B4%EC%82%AC%ED%95%AD.html",
            "relUrl": "/2021/12/21/%EC%8B%9C%ED%97%98%EA%B4%80%EB%A0%A8-%EC%95%88%EB%82%B4%EC%82%AC%ED%95%AD.html",
            "date": " • Dec 21, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "2021년 1학기 R입문 기말고사 (ver 1.00)",
            "content": "의미가 모호한 문제는 질문할것 . 필요한 패키지는 스스로 로드하여 사용할 것 . 1. &#54924;&#44480;&#48516;&#49437; (35&#51216;) . 아래와 같은 수식을 고려하자. . $$y_i= 1.5+ 5 sin(t_i)+ 3 cos(4 t_i)+ epsilon_i, quad i=1,2, dots, 1000$$ . 여기에서 $t_i= frac{2 pi i}{1000}$ 이다. 그리고 $ epsilon_i sim i.i.d~ N(0,1)$, 즉 서로 독립인 표준정규분포에서 추출된 샘플이다. . (1) rnorm()&#51012; &#51060;&#50857;&#54616;&#50668; $ { epsilon_i }_{i=1}^{1000}$ &#51012; &#47564;&#46308;&#44256; &#51060;&#47484; &#48289;&#53552;&#47196; &#47564;&#46308;&#50612;&#46972;. &#51593; &#50500;&#47000;&#50752; &#44057;&#51008; &#48289;&#53552;&#47484; &#49373;&#49457;&#54616;&#46972;. . $ boldsymbol{ epsilon}=( epsilon_1, dots, epsilon_{1000})$ | . (2) $ big { sin(t_i) big }_{i=1}^{1000}$&#50752; $ big { cos(4t_i) big }_{i=1}^{1000}$&#47484; &#44033;&#44033; &#49373;&#49457;&#54616;&#44256; &#51060;&#47484; ${ bf x}_1$&#50752; ${ bf x}_2$&#50640; &#51200;&#51109;&#54616;&#46972;. &#51593; &#50500;&#47000;&#50752; &#44057;&#51008; 2&#44060;&#51032; &#48289;&#53552;&#47484; &#49373;&#49457;&#54616;&#46972;. . ${ bf x}_1= big( sin( frac{2 pi}{1000}), sin( frac{4 pi}{1000}), dots, sin(2 pi) big)$ | ${ bf x}_2= big( cos( frac{8 pi}{1000}), cos( frac{16 pi}{1000}), dots, cos(8 pi) big)$ | . (3) (1),(2)&#47196; &#48512;&#53552; $y_i$&#47484; &#44228;&#49328;&#54616;&#44256;, $(t_i,y_i)$&#47484; scatter plot&#51004;&#47196; &#49884;&#44033;&#54868; &#54616;&#46972;. &#49353;&#51008; &#39;gray60&#39;&#51012; &#49324;&#50857;&#54616;&#46972;. &#49884;&#44033;&#54868; &#50696;&#49884;&#45716; &#50500;&#47000;&#50752; &#44057;&#45796;. . . (4) &#46160; &#48289;&#53552; ${ bf x}_1$, ${ bf x}_2$&#50752; cbind()&#47484; &#51060;&#50857;&#54616;&#50668; &#50500;&#47000;&#50752; &#44057;&#51008; $1000 times 3$ &#47588;&#53944;&#47533;&#49828; ${ bf X}$&#47484; &#47564;&#46308;&#50612;&#46972;. . $${ bf X}= begin{bmatrix} 1 &amp; sin( frac{2 pi}{1000}) &amp; cos( frac{8 pi}{1000}) 1 &amp; sin( frac{4 pi}{1000}) &amp; cos( frac{16 pi}{1000}) dots &amp; dots &amp; dots 1 &amp; sin(2 pi) &amp; cos(8 pi) end{bmatrix} $$ . (5) $3 times 1$ &#47588;&#53944;&#47533;&#49828; $ boldsymbol{ beta}= begin{bmatrix} 1.5 5 3 end{bmatrix}$&#47484; &#47564;&#46308;&#44256; &#47588;&#53944;&#47533;&#49828; &#44273;&#51012; &#51060;&#50857;&#54616;&#50668; ${ bf X} { boldsymbol beta}$&#47484; &#44228;&#49328;&#54616;&#46972;. &#44228;&#49328;&#44208;&#44284;&#47484; &#48289;&#53552;&#54868;&#54616;&#44256; (3)&#51032; $y$&#52629;&#50640; &#48521;&#51008;&#49440;&#51004;&#47196; &#49884;&#44033;&#54868; &#54616;&#46972;. &#49884;&#44033;&#54868; &#50696;&#49884;&#45716; &#50500;&#47000;&#50752; &#44057;&#45796;. (&#54596;&#50836;&#54616;&#45796;&#47732; &#51201;&#51208;&#54616;&#44172; &#49440;&#51032; &#44405;&#44592;&#47484; &#51312;&#51221;&#54624; &#44163;) . . (6) &#50500;&#47000;&#51032; &#49688;&#49885;&#51012; &#51060;&#50857;&#54616;&#50668; $ boldsymbol{ hat beta}$&#47484; &#44228;&#49328;&#54616;&#44256; &#44228;&#49328;&#44208;&#44284;&#47484; $ boldsymbol{ beta}$&#50752; &#48708;&#44368;&#54616;&#46972;. . $$ boldsymbol{ hat beta} = ({ bf X}^ top { bf X})^{-1}{ bf X}^ top { bf y}$$ . 여기에서 ${ bf X}$와 ${ bf y}$는 각각 아래와 같다. . ${ bf X}= begin{bmatrix} 1 &amp; sin( frac{2 pi}{1000}) &amp; cos( frac{8 pi}{1000}) 1 &amp; sin( frac{8 pi}{1000}) &amp; cos( frac{16 pi}{1000}) dots &amp; dots &amp; dots 1 &amp; sin(2 pi) &amp; cos(8 pi) end{bmatrix}$, $ quad { bf y}= begin{bmatrix} y_1 y_2 dots y_{1000} end{bmatrix}$ | . 또한 ${ bf X}^ top$는 ${ bf X}$의 전치행렬(transpose) 그리고 $({ bf X}^ top { bf X})^{-1}$은 ${ bf X}^ top { bf X}$의 역행렬을 의미한다. . (7) ${ bf X} boldsymbol{ hat beta}$&#47484; &#44228;&#49328;&#54616;&#46972;. &#44228;&#49328;&#44208;&#44284;&#47484; &#48289;&#53552;&#54868; &#54616;&#44256; (5)&#51032; &#49884;&#44033;&#54868; &#44208;&#44284;&#50640; &#54392;&#47480;&#51216;&#49440;&#51004;&#47196; &#49884;&#44033;&#54868; &#54616;&#46972;. &#49884;&#44033;&#54868; &#50696;&#49884;&#45716; &#50500;&#47000;&#50752; &#44057;&#45796;. (&#54596;&#50836;&#54616;&#45796;&#47732; &#51201;&#51208;&#54616;&#44172; &#49440;&#51032; &#44405;&#44592;&#47484; &#51312;&#51221;&#54624; &#44163;) . . 2. &#47788;&#53580;&#52852;&#47484;&#47196; &#51201;&#48516; (10&#51216;) . (1) $ int_{-1.96}^{1.96} frac{1}{ sqrt{2 pi}}e^{- frac{1}{2}x^2}dx$&#51032; &#44050;&#51012; runif()&#47484; &#51060;&#50857;&#54620; &#47788;&#53580;&#52852;&#47484;&#47196; &#51201;&#48516;&#51004;&#47196; &#44228;&#49328;&#54616;&#46972;. . (2) rnorm()&#51012; &#51060;&#50857;&#54616;&#50668; &#54364;&#51456;&#51221;&#44508;&#48516;&#54252;&#50640;&#49436; 1000&#44060;&#51032; &#54869;&#47456;&#48320;&#49688;&#47484; &#49373;&#49457;&#54616;&#44256; &#49373;&#49457;&#46108; &#54869;&#47456;&#48320;&#49688;&#46308; &#51473; &#44396;&#44036; $(-1.96 , 1.96)$&#49324;&#51060;&#50640; &#51080;&#45716; &#54869;&#47456;&#48320;&#49688;&#47484; count&#54616;&#46972;. . 3. &#51669;&#44160;&#45796;&#47532; (10&#51216;) . 10명의 참가자가 (유리,강화유리)의 쌍으로 이루어진 징검다리를 건너는 게임을 시작한다. (유리,강화유리)의 쌍은 총 20개 있다. 따라서 유리는 총 40장이 있다. 참가자는 강화유리로 된 징검다리를 밟으면 살아남지만 유리로 된 징검다리를 밟으면 죽는다. 10명의 참가자의 특징은 아래와 같다. . 1번~8번 참가자, 10번 참가자: 50퍼센트의 확률로 강화유리를 고를 수 있다. | 9번 참가자: 95퍼센트의 확률로 강화유리를 고를 수 있다. | . 다리를 건너는 순서는 아래와 같이 번호의 오름차순으로 건너는 방법과 번호의 내림차순으로 건너는 2가지 방법이 있다고 하자. . Type A: 10번 참가자부터 다리를 건너고 그 뒤로 9번, 8번, ... 1번 순으로 다리를 건넌다. | Type B: 1번 참가자부터 다리를 건너고 그 뒤로 2번, 3번, ... 10번 순으로 다리를 건넌다. | . 8번 참가자는 Type A 와 Type B 중 어떠한 경우에 살아남을 확률이 높은가? . 4. COVID19 (15&#51216;) . 아래는 한국의 코로나확진자 발생수를 tibble로 불러오는 코드와 그 결과이다. . df=read_csv(&#39;https://raw.githubusercontent.com/guebin/2021IR/master/_notebooks/covid19.csv&#39;) head(df) . Rows: 12294 Columns: 5 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &#34;,&#34; chr (1): prov dbl (4): year, month, day, cases ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. . A tibble: 6 × 5 yearmonthdayprovcases . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;chr&gt;&lt;dbl&gt; . 2020 | 1 | 20 | 서울 | 0 | . 2020 | 1 | 20 | 부산 | 0 | . 2020 | 1 | 20 | 대구 | 0 | . 2020 | 1 | 20 | 인천 | 1 | . 2020 | 1 | 20 | 광주 | 0 | . 2020 | 1 | 20 | 대전 | 0 | . (1) 2020&#45380;&#51032; &#54869;&#51652;&#51088;(cases)&#52509;&#54633;&#44284; 2021&#45380;&#51032; &#54869;&#51652;&#51088;(cases)&#52509;&#54633;&#51012; &#44396;&#54616;&#46972;. . (2) 2020&#45380; 2&#50900;1&#51068; ~ 2020&#45380; 2&#50900;15&#51068;&#44620;&#51648;&#51032; &#44592;&#44036;&#46041;&#50504; &#54869;&#51652;&#51088;&#51032; &#54633;&#51012; &#51648;&#50669;&#48324;&#47196; &#45208;&#45572;&#50612; &#44396;&#54616;&#46972; (&#50500;&#47000;&#50696;&#49884; &#52280;&#44256;). &#44032;&#51109; &#47566;&#51008; &#54869;&#51652;&#51088;&#44032; &#48156;&#44204;&#46108; &#51648;&#50669;&#51008; &#50612;&#46356;&#51064;&#44032;? . 즉 아래를 각각 계산하고 2020년 2월1일 ~ 2020년 2월15일 기간동안 발생한 확진자의 합이 가장 큰 지역을 찾으면 된다. . 2020년2월1일 ~ 2020년2월15일 기간 서울에서 발생한 확진자의 합 = 2020년2월1일 서울에서 발생한 확진자수 + ... + 2020년2월15일 서울에서 발생한 확진자수 | ... | 2020년2월1일 ~ 2020년2월15일 기간 제주에서 발생한 확진자의 합 = 2020년2월1일 제주에서 발생한 확진자수 + ... + 2020년2월15일 제주에서 발생한 확진자수 | . (3) 2020&#45380; 2&#50900;16&#51068; ~ 2020&#45380; 2&#50900;29&#51068;&#44620;&#51648;&#51032; &#44592;&#44036;&#46041;&#50504; &#54869;&#51652;&#51088;&#51032; &#52509;&#54633;&#51012; &#51648;&#50669;&#48324;&#47196; &#45208;&#45572;&#50612; &#44396;&#54616;&#46972; (&#50500;&#47000;&#50696;&#49884; &#52280;&#44256;). &#44032;&#51109; &#47566;&#51008; &#54869;&#51652;&#51088;&#44032; &#48156;&#44204;&#46108; &#51648;&#50669;&#51008; &#50612;&#46356;&#51064;&#44032;? . 즉 아래를 각각 계산하고 2020년 2월16일 ~ 2020년 2월29일 기간동안 발생한 확진자의 합이 가장 큰 지역을 찾으면 된다. . 2020년2월16일 ~ 2020년2월29일 기간 서울에서 발생한 확진자의 합 = 2020년2월16일 서울에서 발생한 확진자수 + ... + 2020년2월29일 서울에서 발생한 확진자수 | ... | 2020년2월16일 ~ 2020년2월29일 기간 제주에서 발생한 확진자의 합 = 2020년2월16일 제주에서 발생한 확진자수 + ... + 2020년2월29일 제주에서 발생한 확진자수 | . 5. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (10&#51216;) . (1) cumprod &#54632;&#49688;&#47484; &#51060;&#50857;&#54616;&#50668; $7!=7 times 6 times 5 times dots times 1$&#51012; &#44228;&#49328;&#54616;&#46972;. . (2) $ sum_{n=0}^{ infty} frac{n}{n!}$&#51032; &#44050;&#51012; &#44540;&#49324;&#51201;&#51004;&#47196; &#44228;&#49328;&#54616;&#46972;. &#44228;&#49328;&#44208;&#44284;&#47484; exp(1)&#44284; &#48708;&#44368;&#54616;&#46972;. . (3) &#54364;&#51456;&#51221;&#44508;&#48516;&#54252;&#50640;&#49436; 1000&#44060;&#51032; &#45212;&#49688;&#47484; &#49373;&#49457;&#48156;&#49373;&#49884;&#53416; &#46244; 0&#48372;&#45796; &#53360; &#49688;&#47484; &#49464;&#50612;&#48372;&#46972;. . (4) $p=0.2$&#51064; &#48288;&#47476;&#45572;&#51060;&#48516;&#54252;&#50640;&#49436; 1000&#44060;&#51032; &#45212;&#49688;&#47484; &#47564;&#46308;&#47732; 1&#51060; &#47751;&#44060;&#51221;&#46020; &#54252;&#54632;&#46104;&#45716;&#44032;? &#49884;&#48044;&#47112;&#51060;&#49496;&#51012; &#53685;&#54616;&#50668; &#44160;&#51613;&#54616;&#46972;. . (5) &#50500;&#47000;&#45716; &#54364;&#51456;&#51221;&#44508;&#48516;&#54252;, &#51593; &#54217;&#44512;&#51060; 0&#51060;&#44256; &#54364;&#51456;&#54200;&#52264;&#44032; 1&#51064; &#51221;&#44508;&#48516;&#54252;&#50640;&#49436; 1000&#44060;&#51032; &#45212;&#49688;&#47484; &#49373;&#49457;&#54616;&#50668; $x$&#46972;&#45716; &#48320;&#49688;&#50640; &#51200;&#51109;&#54620;&#46244; $x$&#51032; &#55176;&#49828;&#53664;&#44536;&#47016;&#51012; &#44536;&#47536; &#50696;&#49884;&#51060;&#45796;. &#50500;&#47000;&#51032; &#50696;&#49884;&#47484; &#51060;&#50857;&#54616;&#50668; &#54217;&#44512;&#51060; 1&#51060;&#44256; &#54364;&#51456;&#54200;&#52264;&#44032; 1&#51064; &#51221;&#44508;&#48516;&#54252;&#50640;&#49436; 5000&#44060;&#51032; &#45212;&#49688;&#47484; &#49373;&#49457;&#54620;&#46244; $y$&#50640; &#51200;&#51109;&#54616;&#44256; $y$&#51032; &#55176;&#49828;&#53664;&#44536;&#47016;&#51012; &#44536;&#47140;&#46972;. &#49884;&#44033;&#54868; &#50696;&#49884;&#45716; &#50500;&#47000;&#50752; &#44057;&#45796;. . x=rnorm(1000) hist(x) . (6) &#50500;&#47000;&#50752; &#44057;&#51008; &#48289;&#53552; x&#50640;&#49436; &#51677;&#49688;&#48264;&#51704; &#50896;&#49548; (&#51593; x[2],x[4],$ dots$,x[2000])&#51032; &#54633;&#51012; &#44396;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972; . x=-1000:1000/1000 . (7) 2021&#45380; A&#50472;&#51032; &#50672;&#48393;&#51008; 5000&#51060;&#45796;. &#47588;&#45380; &#50672;&#48393;&#51008; 3%&#50473; &#50724;&#47480;&#45796;&#44256; &#54616;&#51088;. 2030&#45380; A&#50472;&#51032; &#50672;&#48393;&#51008; &#50620;&#47560;&#51064;&#44032;? . (8) &#51076;&#51032;&#51032; &#51077;&#47141; $x$&#50640; &#45824;&#54616;&#50668; &#50500;&#47000;&#47484; &#47564;&#51313;&#54616;&#45716; &#54632;&#49688;&#47484; &#49440;&#50616;&#54616;&#46972;. . $x &gt;0$: $ log (x)$를 계산하여 출력 | $x =0$: print(&quot;음의 무한대&quot;) | $x &lt;0$: print(&quot;x는 양수이어야 합니다.&quot;) | . (9) &#50500;&#47000;&#50752; &#44057;&#51008; &#45936;&#51060;&#53552;&#54532;&#47112;&#51076;&#51060; &#51080;&#45796;&#44256; &#54616;&#51088;. . df=tibble(X1=rnorm(100),X2=rnorm(100)) head(df) . A tibble: 6 × 2 X1X2 . &lt;dbl&gt;&lt;dbl&gt; . -0.92831089 | 2.5959065 | . -0.07387717 | -1.0698486 | . -1.60085998 | -0.0705430 | . -0.29223020 | 0.6043498 | . 0.62995753 | 0.4082469 | . -0.26448626 | 0.3490946 | . 위의 데이터프레임 df에서 mutate를 이용하여 Z=X1^2+X2^2을 계산하여 새로운 열 Z를 만들어라. . (10) &#50500;&#47000;&#50752; &#44057;&#51008; &#47588;&#53944;&#47533;&#49828;&#50640;&#49436; apply&#54632;&#49688;&#47484; &#51060;&#50857;&#54616;&#50668; &#44033; &#54665;&#51032; &#54633;&#44284; &#44033; &#50676;&#51032; &#54633;&#51012; &#44396;&#54616;&#46972; . set.seed(1221) mat = rbinom(n=100,size=5,prob=0.5) dim(mat)=c(10,10) print(mat) . [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [1,] 2 3 3 2 2 3 1 3 3 3 [2,] 1 3 3 4 2 2 4 2 2 1 [3,] 2 2 2 2 4 4 2 3 3 3 [4,] 3 2 4 5 2 5 1 4 2 2 [5,] 2 2 2 2 1 4 2 2 3 4 [6,] 5 1 3 1 1 3 4 2 4 3 [7,] 4 3 4 3 2 3 2 3 0 1 [8,] 4 4 2 3 2 3 3 0 4 2 [9,] 5 5 4 3 2 4 4 4 1 4 [10,] 2 4 4 3 1 3 3 2 1 2 . 즉 아래를 구하라 . - 각 행의 합 . 1행의 합 = 2+3+3+ ... +3+3+3 | ... | 10행의 합 = 2+4+4+ ... +2+1+2 | . - 각 열의 합 . 1열의 합 = 2+1+2+ ... +4+5+2 | ... | 10열의 합 = 3+1+3+ ... +2+4+2 | . 6. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (20&#51216;) . (1) &#51088;&#47308; $x_1,x_2, dots, x_{50}$&#50640; &#45824;&#54616;&#50668; &#45796;&#51020; &#44284;&#51221;&#51012; &#49692;&#49436;&#45824;&#47196; &#49884;&#54665;&#54616;&#50688;&#45796;. . (가) 처음 두 수 $x_1$과 $x_2$의 평균을 구한다. . (나) $x_3$을 추가하여 $x_1, x_2, x_3$의 평균을 구한다. . (다) $x_4$을 추가하여 $x_1, x_2, x_3, x_4$의 평균을 구한다. . ... . $x_{50}$을 추가하여 $x_1, x_2, x_3 , dots , x_{50}$의 평균을 구한다. . 위의 과정을 시행할 결과, $x_1$과 $x_2$의 평균이 5이고, 자료 하나가 추가될때 마다 평균이 1씩 증가하였다. 이때 $x_{50}$의 값은? . (2) &#48373;&#46020;&#51032; &#46972;&#52964; . 복도에 100개의 라커가 있다. 복도를 어떤 남자가 짝수번호의 라커를 모두 연다. 그리고 나서 3의 배수의 라커를 전부 닫는다. 그 다음에는 번호가 4의 배수인 라커를 순서대로 찾아다니며 열려 있으면 닫고, 닫혀 있으면 연다. 그 다음에는 번호가 5의 배수인 라커를 순서대로 찾아다니며 열려있으면 닫고, 닫혀있으면 연다. 이후에 6의 배수, 7의 배수 .. 인 라커를 순서대로 찾아다니며 행동을 반복한다. 이런식으로 복도를 50번 지나가면 열린 라커의 문은 몇개가 되겠는가? (주의: 중간고사문제와 약간다릅니다, 다른부분은 볼드체 표시했습니다) . (3) &#47788;&#53580;&#52852;&#47484;&#47196; &#49884;&#48044;&#47112;&#51060;&#49496;&#51012; &#51060;&#50857;&#54616;&#50668; &#50896;&#51452;&#50984; $ pi$&#47484; &#52628;&#47200;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . (4) &#50500;&#47000;&#50752; &#44057;&#51008; &#50672;&#47549;&#51068;&#52264;&#48169;&#51221;&#49885;&#51012; &#54392;&#45716; R&#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . $ begin{cases} w+2x+3y+4z=1 2w+2x+y=9 x-y=4 3w+x-y+3y=7 end{cases}$ . (5) &#50864;&#49328;&#51032; &#54924;&#51204; . 다음은 인터넷에서 어떠한 자료를 다운받아 매트릭스로 저장하는 코드이다. . df=read.csv(&quot;https://raw.githubusercontent.com/guebin/2021IR/master/_notebooks/round2.csv&quot;) X=as.matrix(df) . 매트릭스는 X이라는 변수에 저장되어 있다. 저장된 모양은 아래와 같다. $${ bf X}= begin{bmatrix} x_1 &amp; y_1 x_2 &amp; y_2 dots &amp; dots x_{5513} &amp; y_{5513} end{bmatrix} $$ 아래를 계산하여 $ tilde{ bf X}$를 만들고 $$ tilde{ bf X}={ bf X} begin{bmatrix} cos( frac{ pi}{4}) &amp; - sin ( frac{ pi}{4}) sin( frac{ pi}{4}) &amp; cos ( frac{ pi}{4}) end{bmatrix} $$ . $ tilde{ bf X}$의 첫번째열을 $x$축으로, 두번째열을 $y$축으로 하여 시각화 하라. 시각화 예시는 아래와 같다. . .",
            "url": "https://guebin.github.io/2021IR/2021/12/21/2021%EB%85%84-1%ED%95%99%EA%B8%B0-R%EC%9E%85%EB%AC%B8%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC.html",
            "relUrl": "/2021/12/21/2021%EB%85%84-1%ED%95%99%EA%B8%B0-R%EC%9E%85%EB%AC%B8%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC.html",
            "date": " • Dec 21, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "(15주차) 12월16일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/3) 데이터프레임, 티블 (1) . - (2/3) 데이터프레임, 티블 (2) . - (3/3) 기말고사관련 설명 . library(tidyverse) . ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── ✔ ggplot2 3.3.5 ✔ purrr 0.3.4 ✔ tibble 3.1.6 ✔ dplyr 1.0.7 ✔ tidyr 1.1.4 ✔ stringr 1.4.0 ✔ readr 2.1.1 ✔ forcats 0.5.1 ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ✖ dplyr::filter() masks stats::filter() ✖ dplyr::lag() masks stats::lag() . &#45936;&#51060;&#53552;&#54532;&#47112;&#51076;, &#54000;&#48660;&#51012; &#47564;&#46300;&#45716; &#48169;&#48277; . - 방법1: 선언하여 만들기 (새롭게 정의) . tibble(v1=1:3, v2=c(T,F,T), v3=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)) . A tibble: 3 × 3 v1v2v3 . &lt;int&gt;&lt;lgl&gt;&lt;chr&gt; . 1 | TRUE | a | . 2 | FALSE | b | . 3 | TRUE | c | . 각 열들의 자료형이 모두 달라도 가능 (티블의 매력) | 티블의 형태는 매트릭스 같지만 이처럼 다른 자료형이 들어가는 것은 리스트를 연상시킴 | . - 방법2: 선언하여 만들기2 (기존에 정의된 벡터들을 활용) . x=1:5 y=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;) tibble(x,y) . A tibble: 5 × 2 xy . &lt;int&gt;&lt;chr&gt; . 1 | a | . 2 | b | . 3 | c | . 4 | d | . 5 | e | . tibble(v1=x,v2=y) . A tibble: 5 × 2 v1v2 . &lt;int&gt;&lt;chr&gt; . 1 | a | . 2 | b | . 3 | c | . 4 | d | . 5 | e | . - 방법3: 벡터나 매트릭스를 만들고 그것을 티블로 변형 . as_tibble(x) . A tibble: 5 × 1 value . &lt;int&gt; . 1 | . 2 | . 3 | . 4 | . 5 | . as_tibble(cbind(x,y)) . A tibble: 5 × 2 xy . &lt;chr&gt;&lt;chr&gt; . 1 | a | . 2 | b | . 3 | c | . 4 | d | . 5 | e | . 모든 컬럼이 chr로 저장되는 단점이 있음 | . - 방법4: 리스트를 만들고 그것을 티블로 변형 . as_tibble(list(x=x,y=y)) . A tibble: 5 × 2 xy . &lt;int&gt;&lt;chr&gt; . 1 | a | . 2 | b | . 3 | c | . 4 | d | . 5 | e | . as_tibble(list(v1=x,v2=y)) . A tibble: 5 × 2 v1v2 . &lt;int&gt;&lt;chr&gt; . 1 | a | . 2 | b | . 3 | c | . 4 | d | . 5 | e | . - 데이터프레임의 경우도 티블과 비슷하게 만들 수 있다. . as_tibble 대신 data.frame | tibble 대신 data.frame | . data.frame(v1=1:3, v2=c(T,F,T), v3=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)) . A data.frame: 3 × 3 v1v2v3 . &lt;int&gt;&lt;lgl&gt;&lt;chr&gt; . 1 | TRUE | a | . 2 | FALSE | b | . 3 | TRUE | c | . data.frame(x,y) . A data.frame: 5 × 2 xy . &lt;int&gt;&lt;chr&gt; . 1 | a | . 2 | b | . 3 | c | . 4 | d | . 5 | e | . data.frame(v1=x,v2=y) . A data.frame: 5 × 2 v1v2 . &lt;int&gt;&lt;chr&gt; . 1 | a | . 2 | b | . 3 | c | . 4 | d | . 5 | e | . data.frame(x) . A data.frame: 5 × 1 x . &lt;int&gt; . 1 | . 2 | . 3 | . 4 | . 5 | . data.frame(cbind(x,y)) . A data.frame: 5 × 2 xy . &lt;chr&gt;&lt;chr&gt; . 1 | a | . 2 | b | . 3 | c | . 4 | d | . 5 | e | . data.frame(list(x=x,y=y)) . A data.frame: 5 × 2 xy . &lt;int&gt;&lt;chr&gt; . 1 | a | . 2 | b | . 3 | c | . 4 | d | . 5 | e | . data.frame(list(v1=x,v2=y)) . A data.frame: 5 × 2 v1v2 . &lt;int&gt;&lt;chr&gt; . 1 | a | . 2 | b | . 3 | c | . 4 | d | . 5 | e | . - tibble()과 data.frame()의 결과가 다를수도 있음 . lst = list(x=x,y=y,z=cbind(x,y)) lst . $x &lt;ol class=list-inline&gt;1 | 2 | 3 | 4 | 5 | &lt;/ol&gt; $y &lt;ol class=list-inline&gt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39; | &#39;d&#39; | &#39;e&#39; | &lt;/ol&gt; $z A matrix: 5 × 2 of type chr xy . 1 | a | . 2 | b | . 3 | c | . 4 | d | . 5 | e | . data.frame(lst) . A data.frame: 5 × 4 xyz.xz.y . &lt;int&gt;&lt;chr&gt;&lt;chr&gt;&lt;chr&gt; . 1 | a | 1 | a | . 2 | b | 2 | b | . 3 | c | 3 | c | . 4 | d | 4 | d | . 5 | e | 5 | e | . as_tibble(lst) . A tibble: 5 × 3 xyz . &lt;int&gt;&lt;chr&gt;&lt;chr[,2]&gt; . 1 | a | 1, a | . 2 | b | 2, b | . 3 | c | 3, c | . 4 | d | 4, d | . 5 | e | 5, e | . - 데이터프레임과 티블은 as_tibble()과 data.frame()을 이용하여 서로의 형태로 변환가능하다. . data.frame(v1=1:3, v2=c(T,F,T), v3=c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)) . A data.frame: 3 × 3 v1v2v3 . &lt;int&gt;&lt;lgl&gt;&lt;chr&gt; . 1 | TRUE | a | . 2 | FALSE | b | . 3 | TRUE | c | . data.frame(v1=1:3, v2=c(T,F,T), v3=c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)) %&gt;% as_tibble . A tibble: 3 × 3 v1v2v3 . &lt;int&gt;&lt;lgl&gt;&lt;chr&gt; . 1 | TRUE | a | . 2 | FALSE | b | . 3 | TRUE | c | . data.frame(v1=1:3, v2=c(T,F,T), v3=c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)) %&gt;% as_tibble %&gt;% data.frame . A data.frame: 3 × 3 v1v2v3 . &lt;int&gt;&lt;lgl&gt;&lt;chr&gt; . 1 | TRUE | a | . 2 | FALSE | b | . 3 | TRUE | c | . 즉 아래가 가능함 . df= data.frame(v1=1:3, v2=c(T,F,T), v3=c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)) df . A data.frame: 3 × 3 v1v2v3 . &lt;int&gt;&lt;lgl&gt;&lt;chr&gt; . 1 | TRUE | a | . 2 | FALSE | b | . 3 | TRUE | c | . df=as_tibble(df) df . A tibble: 3 × 3 v1v2v3 . &lt;int&gt;&lt;lgl&gt;&lt;chr&gt; . 1 | TRUE | a | . 2 | FALSE | b | . 3 | TRUE | c | . df=data.frame(df) df . A data.frame: 3 × 3 v1v2v3 . &lt;int&gt;&lt;lgl&gt;&lt;chr&gt; . 1 | TRUE | a | . 2 | FALSE | b | . 3 | TRUE | c | . &#45936;&#51060;&#53552;&#54532;&#47112;&#51076;, &#54000;&#48660;&#51032; &#54644;&#49437; . - 매트릭스: (1) 모든 열은 동일한 숫자의 row를 가져야하며 (2) 행렬의 모든 원소는 동일한 자료형을 가져야 함 . - 리스트: (1) 모든 원소가 동일한 길이의 오브젝트로 구성될 필요가 없다. (2) 그리고 리스트의 각 원소가 동일한 자료형을 가질 필요도 없다. . - 티블 혹은 데이터프레임은 . 자료형이 자유로운 매트릭스로 해석할 수 있고 | 모든 원소가 동일한 길이의 오브젝트로 구성된 리스트 | . 로 생각할 수 있다. . &#45936;&#51060;&#53552;&#54532;&#47112;&#51076;&#44284; &#54000;&#48660;&#51032; &#49324;&#50857;&#48277; . - 데이터셋팅 . x = 1:3 y = c(T,F,T) z = c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) lst = list(x=x,y=y,z=z) mat = cbind(x,y,z) df = tibble(x=x,y=y,z=z) . print(lst) print(mat) print(df) . $x [1] 1 2 3 $y [1] TRUE FALSE TRUE $z [1] &#34;a&#34; &#34;b&#34; &#34;c&#34; x y z [1,] &#34;1&#34; &#34;TRUE&#34; &#34;a&#34; [2,] &#34;2&#34; &#34;FALSE&#34; &#34;b&#34; [3,] &#34;3&#34; &#34;TRUE&#34; &#34;c&#34; # A tibble: 3 × 3 x y z &lt;int&gt; &lt;lgl&gt; &lt;chr&gt; 1 1 TRUE a 2 2 FALSE b 3 3 TRUE c . - df에서 열들의 이름을 알고 싶다. . print(colnames(lst)) print(colnames(mat)) print(colnames(df)) . NULL [1] &#34;x&#34; &#34;y&#34; &#34;z&#34; [1] &#34;x&#34; &#34;y&#34; &#34;z&#34; . print(names(lst)) print(names(mat)) print(names(df)) . [1] &#34;x&#34; &#34;y&#34; &#34;z&#34; NULL [1] &#34;x&#34; &#34;y&#34; &#34;z&#34; . - df에서 첫번째 열을 추출하고 싶다? . mat[,1] #lst[,1] df[,1] . &lt;ol class=list-inline&gt;&#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &lt;/ol&gt; A tibble: 3 × 1 x . &lt;int&gt; . 1 | . 2 | . 3 | . lst[[1]] df[[1]] . &lt;ol class=list-inline&gt;1 | 2 | 3 | &lt;/ol&gt; &lt;ol class=list-inline&gt;1 | 2 | 3 | &lt;/ol&gt; - df를 매트릭스처럼 생각하는건 사실 직관적이지만 리스트라고는 생각하기 어렵다. df를 리스트라고 해석하면 아래와 같은 문법들도 쉽게 이해가능하다. . lst[1] df[1] . $x = &lt;ol class=list-inline&gt;1 | 2 | 3 | &lt;/ol&gt; A tibble: 3 × 1 x . &lt;int&gt; . 1 | . 2 | . 3 | . lst$x df$x . &lt;ol class=list-inline&gt;1 | 2 | 3 | &lt;/ol&gt; &lt;ol class=list-inline&gt;1 | 2 | 3 | &lt;/ol&gt; lst[&#39;x&#39;] df[&#39;x&#39;] . $x = &lt;ol class=list-inline&gt;1 | 2 | 3 | &lt;/ol&gt; A tibble: 3 × 1 x . &lt;int&gt; . 1 | . 2 | . 3 | . lst[1:2] df[1:2] . $x &lt;ol class=list-inline&gt;1 | 2 | 3 | &lt;/ol&gt; $y &lt;ol class=list-inline&gt;TRUE | FALSE | TRUE | &lt;/ol&gt; A tibble: 3 × 2 xy . &lt;int&gt;&lt;lgl&gt; . 1 | TRUE | . 2 | FALSE | . 3 | TRUE | . - 매트릭스처럼 생각한다면 아래와 같은 형태도 가능하다. . mat[2:3,] df[2:3,] . A matrix: 2 × 3 of type chr xyz . 2 | FALSE | b | . 3 | TRUE | c | . A tibble: 2 × 3 xyz . &lt;int&gt;&lt;lgl&gt;&lt;chr&gt; . 2 | FALSE | b | . 3 | TRUE | c | . mat[,1:2] df[,1:2] . A matrix: 3 × 2 of type chr xy . 1 | TRUE | . 2 | FALSE | . 3 | TRUE | . A tibble: 3 × 2 xy . &lt;int&gt;&lt;lgl&gt; . 1 | TRUE | . 2 | FALSE | . 3 | TRUE | . mat[,&#39;x&#39;] df[,&#39;x&#39;] . &lt;ol class=list-inline&gt;&#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &lt;/ol&gt; A tibble: 3 × 1 x . &lt;int&gt; . 1 | . 2 | . 3 | . mat[,c(&#39;x&#39;,&#39;y&#39;)] df[,c(&#39;x&#39;,&#39;y&#39;)] . A matrix: 3 × 2 of type chr xy . 1 | TRUE | . 2 | FALSE | . 3 | TRUE | . A tibble: 3 × 2 xy . &lt;int&gt;&lt;lgl&gt; . 1 | TRUE | . 2 | FALSE | . 3 | TRUE | . mat[2:3,c(&#39;x&#39;,&#39;y&#39;)] df[2:3,c(&#39;x&#39;,&#39;y&#39;)] . A matrix: 2 × 2 of type chr xy . 2 | FALSE | . 3 | TRUE | . A tibble: 2 × 2 xy . &lt;int&gt;&lt;lgl&gt; . 2 | FALSE | . 3 | TRUE | .",
            "url": "https://guebin.github.io/2021IR/2021/12/16/(15%EC%A3%BC%EC%B0%A8)-12%EC%9B%9416%EC%9D%BC.html",
            "relUrl": "/2021/12/16/(15%EC%A3%BC%EC%B0%A8)-12%EC%9B%9416%EC%9D%BC.html",
            "date": " • Dec 16, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "(14주차) 12월14일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - 강의노트는 LMS참고하세요 .",
            "url": "https://guebin.github.io/2021IR/2021/12/14/(14%EC%A3%BC%EC%B0%A8)-12%EC%9B%9414%EC%9D%BC.html",
            "relUrl": "/2021/12/14/(14%EC%A3%BC%EC%B0%A8)-12%EC%9B%9414%EC%9D%BC.html",
            "date": " • Dec 14, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "(14주차) 12월9일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/5) 징검다리 문제 III 두번째 풀이 (1) . - (2/5) 징검다리 문제 III 두번째 풀이 (2) . - (3/5) 징검다리 문제 III 세번째 풀이 (1) . - (4/5) 징검다리 문제 III 세번째 풀이 (2) . - (5/5) 징검다리 문제 III 세번째 풀이 (3) . &#51669;&#44160;&#45796;&#47532; &#47928;&#51228; III. . 강화유리와 유리를 구분할 수 있는 유리 장인이 있다. . 이 유리장인은 80퍼센트의 확률로 강화유리를 고른다. . 총 10명의 참가자가 있고 이 참가자들은 (유리,강화유리)의 조합으로 이루어진 징검다리를 5번연속으로 건너야 한다. . 아래의 경우에 참가자들은 평균적으로 몇명이 살아남겠는가? . (1) 일반인1 - 일반인2 - .... - 일반인9 - 유리장인 || (강화유리, 유리) . (2) 유리장인 - 일반인1 - 일반인2 - ... - 일반인9 || (강화유리, 유리) . 1000번 시뮬레이션을 하여 결과를 추정하라. . (단, 일반인은 50%의 확률로 강화유리를 고를수 있다고 하자) . . [예시] (1)의 시뮬레이션 결과가 아래와 같다고 하자. . 첫번째 징검다리: 유리장인이 강화유리 선택 | 두번째 징검다리: 유리장인이 강화유리 선택 | 세번째 징검다리: 유리장인이 일반유리 선택 $ to$ 유리장인 탈락 &amp; 일반인9는 당연히 강화유리를 선택 | 네번째 징검다리: 일반인9가 일반유리 선택 $ to$ 일반인9 탈락 &amp; 일반인8은 당연히 강화유리 선택 | 다섯번째 징검다리: 일반인8이 강화유리 선택 | . 이 경우는 일반인8,일반인7, $ dots$, 일반인1이 살아남으므로 8명이 살아남는다. . [예시] (2)의 시뮬레이션 결과가 아래와 같다고 하자. . 첫번째 징검다리: 일반인9 일반유리 선택 $ to$ 일반인9 탈락 &amp; 일반인8은 강화유리 선택 | 두번째 징검다리: 일반인8 일반유리 선택 $ to$ 일반인8 탈락 &amp; 일반인7은 강화유리 선택 | 세번째 징검다리: 일반인7 일반유리 선택 $ to$ 일반인7 탈락 &amp; 일반인6은 강화유리 선택 | 네번째 징검다리: 일반인6 일반유리 선택 $ to$ 일반인6 탈락 &amp; 일반인5는 강화유리 선택 | 다섯번째 징검다리: 일반인5 일반유리 선택 $ to$ 일반인5 탈락 &amp; 일반인4는 강화유리 선택 | . 이 경우는 일반인4,일반인3,일반인2,일반인1,유리장인 이 살아남는다. (따라서 5명) . - 즉 살아남을수 있는 최대인원수는 10명이며 최소인원수는 5명이다. . - 유리장인이 100%의 확률로 강화유리를 구분한다면 (1)의 경우 항상 10명이 살아남는다. (즉 평균도 10명) . &#54400;&#51060;2 . - 아래와 같은 수식을 세울 수 있다. . 총 살아남은 사람의 수 = 5 + 장인의 성공횟수 + (5-장인의성공횟수-1)의 기회중에서 일반인의 성공횟수 . 단 (5-장인의성공횟수-1)=&lt;0 이면 마지막항은 0으로 계산한다. | . - 장인의 성공횟수를 $x$, 일반인의 성공횟수를 $y$라고 하자. 그러면 구하는것은 $5+x+y$이다. . - 장인의 성공횟수 . library(tidyverse) . x_ = rbinom(5,size=1,0.8) x_ . [1] 1 1 1 0 1 . cumprod(x_) . [1] 1 1 1 0 0 . x=sum(cumprod(x_)) print(x) . [1] 3 . - 일반인의 성공횟수 . xx_ = 5-x-1 . print(xx_) . [1] 1 . y = rbinom(1, size=xx_, 0.5) y . [1] 1 . - 살아남은 사람수는? . print(5+x+y) . [1] 9 . - 정리하면 . rslt &lt;- c() for (i in 1:10000){ x=sum(cumprod(rbinom(5,size=1,0.8))) xx_=5-x-1 if (xx_&gt;0) y = rbinom(1, size=xx_, 0.5) else y=0 rslt[i]=5+x+y } . mean(rslt) . [1] 8.4895 . &#54400;&#51060;3 . ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) ARR . [1] &#34;N1&#34; &#34;N2&#34; &#34;N3&#34; &#34;N4&#34; &#34;N5&#34; &#34;N6&#34; &#34;N7&#34; &#34;N8&#34; &#34;N9&#34; &#34;A&#34; . SURV = 10 . PLAYER = ARR[SURV] PLAYER . [1] &#34;A&#34; . STAGE = 0 . - 첫시도 . toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical . PROB = 0.8 TOSSRSLT = toss(PROB) if (TOSSRSLT==TRUE){ SURV = SURV STAGE = STAGE + 1 PLAYER = ARR[SURV] }else{ SURV = SURV - 1 STAGE = STAGE + 1 PLAYER = ARR[SURV] } . print(TOSSRSLT) print(SURV) print(STAGE) print(PLAYER) . [1] TRUE [1] 10 [1] 1 [1] &#34;A&#34; . - 코드를 간단히 수정하자. . PROB = 0.8 TOSSRSLT = toss(PROB) if (TOSSRSLT==FALSE) SURV = SURV - 1 STAGE = STAGE + 1 PLAYER = ARR[SURV] . print(TOSSRSLT) print(SURV) print(STAGE) print(PLAYER) . [1] TRUE [1] 10 [1] 2 [1] &#34;A&#34; . - 다시 처음부터 보고싶다면? . SURV = 10 STAGE = 0 PLAYER = ARR[SURV] . PROB = 0.8 TOSSRSLT = toss(PROB) if (TOSSRSLT==FALSE) SURV = SURV - 1 STAGE = STAGE + 1 PLAYER = ARR[SURV] . print(TOSSRSLT) print(SURV) print(STAGE) print(PLAYER) . [1] TRUE [1] 10 [1] 1 [1] &#34;A&#34; . - reset을 하는 함수를 만들자. . reset = function(){ SURV = 10 STAGE = 0 PLAYER = ARR[SURV] } . 제대로 동작하지 않음 $ to$ =를 &lt;&lt;-로 수정해보자. | . reset = function(){ SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } . reset() . print(TOSSRSLT) print(SURV) print(STAGE) print(PLAYER) . [1] TRUE [1] 10 [1] 0 [1] &#34;A&#34; . - 출력함수의 기능을 묶어보자. $ to$ 출력(display)와 저장기능을 통합하여 record 함수 만듬 . record = function() list(TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) . record()$SURV %&gt;% print . [1] 10 . - reset + record 를 사용하고 결과를 살펴보면 . reset() record() . $TOSSRSLT [1] TRUE $SURV [1] 10 $STAGE [1] 0 $PLAYER [1] &#34;A&#34; . TOSSRSLT의 의미가 헷갈릴수 있으니 약간 수정하자. | . record = function() list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) . reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } . reset() record() . $PRE_TOSSRSLT [1] NA $SURV [1] 10 $STAGE [1] 0 $PLAYER [1] &#34;A&#34; . - 지금까지 코드의 중간정리 . ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) SURV = 10 PLAYER = ARR[SURV] STAGE = 0 PROB = 0.8 TOSSRSLT = NA ### 변수들의 모음 . toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } record = function(){ list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) } ### 함수들의 모음 . PROB = 0.8 TOSSRSLT = toss(PROB) if (TOSSRSLT==FALSE) SURV = SURV - 1 STAGE = STAGE + 1 PLAYER = ARR[SURV] ### body . - PROB 가 항상 0.8인것은 아니며 사실 PLAYER==&#39;A&#39; 일 경우에만 0.8 이고 그외의 경우는 0.5 이다. . ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) SURV = 10 PLAYER = ARR[SURV] STAGE = 0 PROB = 0.8 TOSSRSLT = NA ### 변수들의 모음 . toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } record = function(){ list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) } ### 함수들의 모음 . PROB = 0.5+ (PLAYER==&#39;A&#39;)*0.3 #### 이부분을 수정했음 TOSSRSLT = toss(PROB) if (TOSSRSLT==FALSE) SURV = SURV - 1 STAGE = STAGE + 1 PLAYER = ARR[SURV] ### body . - Test 해보자. . reset() record() . $PRE_TOSSRSLT [1] NA $SURV [1] 10 $STAGE [1] 0 $PLAYER [1] &#34;A&#34; . PROB = 0.5+ (PLAYER==&#39;A&#39;)*0.3 #### 이부분을 수정했음 TOSSRSLT = toss(PROB) if (TOSSRSLT==FALSE) SURV = SURV - 1 STAGE = STAGE + 1 PLAYER = ARR[SURV] record() . $PRE_TOSSRSLT [1] TRUE $SURV [1] 10 $STAGE [1] 1 $PLAYER [1] &#34;A&#34; . - 스테이지를 진행하는 부분을 묶어서 함수로 처리하자. . ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) SURV = 10 PLAYER = ARR[SURV] STAGE = 0 PROB = 0.8 TOSSRSLT = NA ### 변수들의 모음 . toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } record = function(){ list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) } go = function(){ PROB &lt;&lt;- 0.5+ (PLAYER==&#39;A&#39;)*0.3 TOSSRSLT &lt;&lt;- toss(PROB) if (TOSSRSLT==FALSE) SURV &lt;&lt;- SURV - 1 STAGE &lt;&lt;- STAGE + 1 PLAYER &lt;&lt;- ARR[SURV] } ### 함수들의 모음 . ### body . - test . reset() record() . $PRE_TOSSRSLT [1] NA $SURV [1] 10 $STAGE [1] 0 $PLAYER [1] &#34;A&#34; . go() record() . $PRE_TOSSRSLT [1] FALSE $SURV [1] 9 $STAGE [1] 1 $PLAYER [1] &#34;N9&#34; . - 어차피 5번 시행을 하므로 go이외에 gogo함수를 따로 만들자. . ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) SURV = 10 PLAYER = ARR[SURV] STAGE = 0 PROB = 0.8 TOSSRSLT = NA ### 변수들의 모음 . toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } record = function(){ list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) } go = function(){ PROB &lt;&lt;- 0.5+ (PLAYER==&#39;A&#39;)*0.3 TOSSRSLT &lt;&lt;- toss(PROB) if (TOSSRSLT==FALSE) SURV &lt;&lt;- SURV - 1 STAGE &lt;&lt;- STAGE + 1 PLAYER &lt;&lt;- ARR[SURV] } gogo = function() for(i in 1:5) go() ### 함수들의 모음 . - test . reset() record() . $PRE_TOSSRSLT [1] NA $SURV [1] 10 $STAGE [1] 0 $PLAYER [1] &#34;A&#34; . gogo() record() . $PRE_TOSSRSLT [1] TRUE $SURV [1] 9 $STAGE [1] 5 $PLAYER [1] &#34;N9&#34; . - 히스토리를 볼 수 있는 gogo함수를 만들어보자. . gogo_history = function(){ rslt_ = as_tibble(record()) ## go를 시작하기전의 결과가 티블로 만들어짐 for(i in 1:5){ go() rslt_ = rbind(rslt_, as_tibble(record())) } print(rslt_) } . reset() record() . $PRE_TOSSRSLT [1] NA $SURV [1] 10 $STAGE [1] 0 $PLAYER [1] &#34;A&#34; . gogo_history() . # A tibble: 6 × 4 PRE_TOSSRSLT SURV STAGE PLAYER &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 NA 10 0 A 2 FALSE 9 1 N9 3 TRUE 9 2 N9 4 TRUE 9 3 N9 5 FALSE 8 4 N8 6 TRUE 8 5 N8 . - 이제 simulate_once 라는 함수를 만들어서 시뮬레이션 결과를 저장하자. . simulate_once = function(){ reset() gogo() return(record()$SURV ) } . simulate_once() %&gt;% print . [1] 10 . - 따라서 답은 . simrslt = c() for (i in 1:100000) simrslt[i] = simulate_once() mean(simrslt) %&gt;% print . [1] 8.51736 . - 코드를 최종적으로 정리하면 . ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) SURV = 10 PLAYER = ARR[SURV] STAGE = 0 PROB = 0.8 TOSSRSLT = NA ### 변수들의 모음 . toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } record = function(){ list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) } go = function(){ PROB &lt;&lt;- 0.5+ (PLAYER==&#39;A&#39;)*0.3 TOSSRSLT &lt;&lt;- toss(PROB) if (TOSSRSLT==FALSE) SURV &lt;&lt;- SURV - 1 STAGE &lt;&lt;- STAGE + 1 PLAYER &lt;&lt;- ARR[SURV] } gogo = function() for(i in 1:5) go() gogo_history = function(){ rslt_ = as_tibble(record()) ## go를 시작하기전의 결과가 티블로 만들어짐 for(i in 1:5){ go() rslt_ = rbind(rslt_, as_tibble(record())) } print(rslt_) } simulate_once = function(){ reset() gogo() return(record()$SURV ) } ### 함수들의 모음 . simrslt = c() for (i in 1:100000) simrslt[i] = simulate_once() mean(simrslt) ### body . [1] 8.50571 . &#51060;&#47084;&#54620; &#48169;&#49885;&#51032; &#53076;&#46377;&#49828;&#53440;&#51068; . - 장점: 함수의 입력/출력을 상당부분 생략가능, 함수의 출력을 어딘가에 저장하는 번거로운 과정도 스킵가능, 구현이 쉬움 . - 단점: 지정한 변수들과 함수의 목록을 한번에 파악하기 힘듬. 하나의 노트북에서 다른 풀이도 함께하다보면 변수이름들이 매우 헷갈릴수 있음. . - 단점을 극복하기 위한 대안 (1) 하나의 노트북을 사용한다. (2) 변수나 함수들을 모두 초기화한다. (커널초기화) (3) 이 모든것을 하나의 함수로 묶는다. . - (2) 변수나 함수들을 모두 초기화하는 방법 . ls() ## 현재 R에 저장된 변수목록을 출력 . [1] &#34;ARR&#34; &#34;go&#34; &#34;gogo&#34; &#34;gogo_history&#34; [5] &#34;i&#34; &#34;PLAYER&#34; &#34;PROB&#34; &#34;record&#34; [9] &#34;reset&#34; &#34;rslt&#34; &#34;simrslt&#34; &#34;simulate_once&#34; [13] &#34;STAGE&#34; &#34;SURV&#34; &#34;toss&#34; &#34;TOSSRSLT&#34; [17] &#34;x&#34; &#34;x_&#34; &#34;xx_&#34; &#34;y&#34; . rm(list=ls()) # 현재 R환경에 있는 함수+변수를 삭제 . ls() ## 현재 R에 저장된 변수목록을 출력 . character(0) . 이제 R에는 더이상 함수나 변수가 없다. | . - (3) 이 모든것을 하나의 함수로 묶는방법 . rm(list=ls()) . ls() . character(0) . 일단 R환경은 깨끗한 상태임 | . SIMULATE = function(){ ### 변수들의 모음 ARR = c(&#39;N1&#39;,&#39;N2&#39;,&#39;N3&#39;,&#39;N4&#39;,&#39;N5&#39;,&#39;N6&#39;,&#39;N7&#39;,&#39;N8&#39;,&#39;N9&#39;,&#39;A&#39;) SURV = 10 PLAYER = ARR[SURV] STAGE = 0 PROB = 0.8 TOSSRSLT = NA ### Subfunction들의 모음 toss = function(p) rbinom(n=1,size=1,prob=p) %&gt;% as.logical reset = function(){ TOSSRSLT &lt;&lt;- NA SURV &lt;&lt;- 10 STAGE &lt;&lt;- 0 PLAYER &lt;&lt;- ARR[SURV] } record = function(){ list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) } go = function(){ PROB &lt;&lt;- 0.5+ (PLAYER==&#39;A&#39;)*0.3 TOSSRSLT &lt;&lt;- toss(PROB) if (TOSSRSLT==FALSE) SURV &lt;&lt;- SURV - 1 STAGE &lt;&lt;- STAGE + 1 PLAYER &lt;&lt;- ARR[SURV] } gogo = function() for(i in 1:5) go() gogo_history = function(){ rslt_ = as_tibble(record()) ## go를 시작하기전의 결과가 티블로 만들어짐 for(i in 1:5){ go() rslt_ = rbind(rslt_, as_tibble(record())) } print(rslt_) } simulate_once = function(){ reset() gogo() return(record()$SURV ) } ### BODY simrslt = c() for (i in 1:100000) simrslt[i] = simulate_once() mean(simrslt) } . ls() . [1] &#34;SIMULATE&#34; . 현재는 SIMULATE 하나만 저장되어있음 | . SIMULATE() . [1] 8.5075 . ls() . [1] &#34;SIMULATE&#34; . 실행한이후에도 SIMULATE 하나만 저장되어 있음 | .",
            "url": "https://guebin.github.io/2021IR/2021/12/09/(14%EC%A3%BC%EC%B0%A8)-12%EC%9B%949%EC%9D%BC.html",
            "relUrl": "/2021/12/09/(14%EC%A3%BC%EC%B0%A8)-12%EC%9B%949%EC%9D%BC.html",
            "date": " • Dec 9, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "(13주차) 12월7일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/2) 징검다리문제 III 해석적풀이 (1) . - (2/2) 징검다리문제 III 해석적풀이 (2) . &#51669;&#44160;&#45796;&#47532; &#47928;&#51228; III. . 강화유리와 유리를 구분할 수 있는 유리 장인이 있다. . 이 유리장인은 80퍼센트의 확률로 강화유리를 고른다. . 총 10명의 참가자가 있고 이 참가자들은 (유리,강화유리)의 조합으로 이루어진 징검다리를 5번연속으로 건너야 한다. . 아래의 경우에 참가자들은 평균적으로 몇명이 살아남겠는가? . (1) 일반인1 - 일반인2 - .... - 일반인9 - 유리장인 || (강화유리, 유리) . (2) 유리장인 - 일반인1 - 일반인2 - ... - 일반인9 || (강화유리, 유리) . 1000번 시뮬레이션을 하여 결과를 추정하라. . (단, 일반인은 50%의 확률로 강화유리를 고를수 있다고 하자) . . [예시] (1)의 시뮬레이션 결과가 아래와 같다고 하자. . 첫번째 징검다리: 유리장인이 강화유리 선택 | 두번째 징검다리: 유리장인이 강화유리 선택 | 세번째 징검다리: 유리장인이 일반유리 선택 $ to$ 유리장인 탈락 &amp; 일반인9는 당연히 강화유리를 선택 | 네번째 징검다리: 일반인9가 일반유리 선택 $ to$ 일반인9 탈락 &amp; 일반인8은 당연히 강화유리 선택 | 다섯번째 징검다리: 일반인8이 강화유리 선택 | . 이 경우는 일반인8,일반인7, $ dots$, 일반인1이 살아남으므로 8명이 살아남는다. . [예시] (2)의 시뮬레이션 결과가 아래와 같다고 하자. . 첫번째 징검다리: 일반인9 일반유리 선택 $ to$ 일반인9 탈락 &amp; 일반인8은 강화유리 선택 | 두번째 징검다리: 일반인8 일반유리 선택 $ to$ 일반인8 탈락 &amp; 일반인7은 강화유리 선택 | 세번째 징검다리: 일반인7 일반유리 선택 $ to$ 일반인7 탈락 &amp; 일반인6은 강화유리 선택 | 네번째 징검다리: 일반인6 일반유리 선택 $ to$ 일반인6 탈락 &amp; 일반인5는 강화유리 선택 | 다섯번째 징검다리: 일반인5 일반유리 선택 $ to$ 일반인5 탈락 &amp; 일반인4는 강화유리 선택 | . 이 경우는 일반인4,일반인3,일반인2,일반인1,유리장인 이 살아남는다. (따라서 5명) . - 즉 살아남을수 있는 최대인원수는 10명이며 최소인원수는 5명이다. . - 유리장인이 100%의 확률로 강화유리를 구분한다면 (1)의 경우 항상 10명이 살아남는다. (즉 평균도 10명) . &#54644;&#49437;&#51201; &#54400;&#51060; (=&#51060;&#47200;&#51201; &#54400;&#51060;) . - 장인이 맨 앞에 있는 경우에 한정한 해석적 풀이 (=이론적 풀이) . - 10명이 살아남을 확률? $0.8^5$ . - 9명이 살아남을 확률? . 장인이 1번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | 장인이 2번째 탈락 = $0.8^1 times 0.2 times 0.5^3$ | 장인이 3번째 탈락 = $0.8^2 times 0.2 times 0.5^2$ | 장인이 4번째 탈락 = $0.8^3 times 0.2 times 0.5^1$ | 장인이 5번째 탈락 = $0.8^4 times 0.2 times 0.5^0$ | . - 8명이 살아남을 확률? . 장인이 1번째 탈락 = $choose(4,1) times 0.8^0 times 0.2 times 0.5^4$ 일반인이 2번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | 일반인이 3번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | 일반인이 4번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | 일반인이 5번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | . | 장인이 2번째 탈락 = $choose(3,1) times 0.8^1 times 0.2 times 0.5^3$ 일반인이 3번째 탈락 = $0.8^1 times 0.2 times 0.5^3$ | 일반인이 4번째 탈락 = $0.8^2 times 0.2 times 0.5^3$ | 일반인이 5번째 탈락 = $0.8^2 times 0.2 times 0.5^3$ | . | 장인이 3번째 탈락 = $choose(2,1) times 0.8^2 times 0.2 times 0.5^2$ 일반인이 4번째 탈락 = $0.8^2 times 0.2 times 0.5^2$ | 일반인이 5번째 탈락 = $0.8^2 times 0.2 times 0.5^2$ | . | 장인이 4번째 탈락 = $choose(1,1) times 0.8^3 times 0.2 times 0.5^1$ 일반인이 5번째 탈락 = $0.8^3 times 0.2 times 0.5^1$ | . | . - 7명이 살아남을 확률? . 장인이 1번째 탈락 = $choose(4,2) times 0.8^0 times 0.2 times 0.5^4$ 일반인이 2,3번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | 일반인이 2,4번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | 일반인이 2,5번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | 일반인이 3,4번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | 일반인이 3,5번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | 일반인이 4,5번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | . | 장인이 2번째 탈락 = $choose(3,2) times 0.8^1 times 0.2 times 0.5^3$ 일반인이 3,4번째 탈락 = $0.8^1 times 0.2 times 0.5^3$ | 일반인이 3,5번째 탈락 = $0.8^2 times 0.2 times 0.5^3$ | 일반인이 4,5번째 탈락 = $0.8^2 times 0.2 times 0.5^3$ | . | 장인이 3번째 탈락 = $choose(2,2) times 0.8^2 times 0.2 times 0.5^2$ 일반인이 4,5번째 탈락 = $0.8^2 times 0.2 times 0.5^2$ | . | . - 6명이 살아남을 확률? . 장인이 1번째 탈락 = $choose(4,3) times 0.8^0 times 0.2 times 0.5^4$ 일반인이 2,3,4번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | 일반인이 2,3,5번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | 일반인이 2,4,5번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | 일반인이 3,4,5번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | . | 장인이 2번째 탈락 = $1 times 0.8^1 times 0.2 times 0.5^3$ 일반인이 3,4,5번째 탈락 = $0.8^1 times 0.2 times 0.5^3$ | . | . - 5명이 살아남을 확률? $0.2 times 0.5^4$ . 장인 + 일반인4명 연속탈락 | . - 계산기를 이용하여 확률을 계산하자. . 0.8^5 . [1] 0.32768 . surv9_prob = c() for (i in 0:4) surv9_prob[i+1]= 0.8^i *0.2 *0.5^(4-i) . surv9_prob . [1] 0.01250 0.02000 0.03200 0.05120 0.08192 . surv9_prob %&gt;% sum . [1] 0.19762 . surv8_prob = c() for (i in 0:3) surv8_prob[i+1]= choose(4-i,1)*0.8^i *0.2 *0.5^(4-i) ## 7명 surv7_prob = c() for (i in 0:2) surv7_prob[i+1]= choose(4-i,2)*0.8^i *0.2 *0.5^(4-i) ## 6명 surv6_prob = c() for (i in 0:1) surv6_prob[i+1]= choose(4-i,3)*0.8^i *0.2 *0.5^(4-i) ## 5명 surv5_prob = c() for (i in 0:0) surv5_prob[i+1]= choose(4-i,4)*0.8^i *0.2 *0.5^(4-i) . - 확률의 총합 . 0.8^5 + sum(surv9_prob) + sum(surv8_prob) + sum(surv7_prob) + sum(surv6_prob) +sum(surv5_prob) . [1] 1 . 잘 구해진것 같다. | . - 평균 . 0.8^5*10 + sum(surv9_prob)*9 + sum(surv8_prob)*8 + sum(surv7_prob)*7 + sum(surv6_prob)*6 + sum(surv5_prob)*5 . [1] 8.50848 .",
            "url": "https://guebin.github.io/2021IR/2021/12/07/(13%EC%A3%BC%EC%B0%A8)-12%EC%9B%947%EC%9D%BC.html",
            "relUrl": "/2021/12/07/(13%EC%A3%BC%EC%B0%A8)-12%EC%9B%947%EC%9D%BC.html",
            "date": " • Dec 7, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "(13주차) 12월2일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - 강의노트는 LMS참고하세요 .",
            "url": "https://guebin.github.io/2021IR/2021/12/02/(13%EC%A3%BC%EC%B0%A8)-12%EC%9B%942%EC%9D%BC.html",
            "relUrl": "/2021/12/02/(13%EC%A3%BC%EC%B0%A8)-12%EC%9B%942%EC%9D%BC.html",
            "date": " • Dec 2, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "(12주차) 11월30일 + 11월25일보충강의",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/7) 숙제풀이 . - (2/7) select . - (3/7) filter . - (4/7) mutate . - (5/7) group_by, summarise . - (6/7) flight data . - (7/7) 숙제설명 . &#45936;&#51060;&#53552;&#54532;&#47112;&#51076;&#44284; &#54000;&#48660; . library(tidyverse) . - 길이가 50인 벡터생성 . A = rnorm(10*5) A ## 길이가 50인 벡터에 정규분포에 추출한 값 . [1] 1.17767702 2.73106894 -1.35304458 -0.03276446 0.53369832 0.49395437 [7] -0.57098744 0.08639052 0.13038589 -0.83919513 0.63070688 0.79315491 [13] -0.88411918 -0.89302478 -1.73600236 -1.03698473 -0.01582456 0.96717754 [19] -0.22076719 1.01093743 0.95756614 -1.06746861 -0.80694017 0.40289417 [25] 0.03584857 0.07879276 -1.20817133 -0.67848560 -0.99625585 0.99035758 [31] -0.30129979 0.63455394 0.59275899 -0.02683564 0.36659406 -0.39990796 [37] 0.03857880 -0.94117668 -0.52508619 0.68735157 -0.11328093 -0.62775891 [43] 0.90407099 0.45493649 -0.32498564 0.11173280 -0.18886705 -0.30540003 [49] 1.84845946 -0.17473138 . - 매트릭스로 변경 . dim(A) = c(10,5) A . [,1] [,2] [,3] [,4] [,5] [1,] 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 [2,] 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 [3,] -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 [4,] -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 [5,] 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 [6,] 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 [7,] -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 [8,] 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 [9,] 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 [10,] -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - 티블로 변경 (자동으로 V1,...,V5 열의 이름이 지정됨) . A = as_tibble(A) A . Warning message: “The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0. Using compatibility `.name_repair`. This warning is displayed once every 8 hours. Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.” . V1 V2 V3 V4 V5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - 컬럼의 이름 확인 . colnames(A) . [1] &#34;V1&#34; &#34;V2&#34; &#34;V3&#34; &#34;V4&#34; &#34;V5&#34; . - 칼럼의 이름을 바꾸고 싶다면? . colnames(A) = c(&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;,&#39;X4&#39;,&#39;X5&#39;) A . X1 X2 X3 X4 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . select() . - 처음 3개의 칼럼과 마지막 1개의 칼럼을 선택하고 싶다면? . A %&gt;% select(1:3,5) . X1 X2 X3 X5 1 1.17767702 0.63070688 0.95756614 -0.1132809 2 2.73106894 0.79315491 -1.06746861 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.9040710 4 -0.03276446 -0.89302478 0.40289417 0.4549365 5 0.53369832 -1.73600236 0.03584857 -0.3249856 6 0.49395437 -1.03698473 0.07879276 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 1.8484595 10 -0.83919513 1.01093743 0.99035758 -0.1747314 . - 열의 이름을 통하여서도 선택할 수 있음 . A %&gt;% select(X1:X3,X5) . X1 X2 X3 X5 1 1.17767702 0.63070688 0.95756614 -0.1132809 2 2.73106894 0.79315491 -1.06746861 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.9040710 4 -0.03276446 -0.89302478 0.40289417 0.4549365 5 0.53369832 -1.73600236 0.03584857 -0.3249856 6 0.49395437 -1.03698473 0.07879276 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 1.8484595 10 -0.83919513 1.01093743 0.99035758 -0.1747314 . - 열의 이름과 위치인덱스를 혼합하여 사용할 수 있음 . A %&gt;% select(X1:X3, 5) . X1 X2 X3 X5 1 1.17767702 0.63070688 0.95756614 -0.1132809 2 2.73106894 0.79315491 -1.06746861 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.9040710 4 -0.03276446 -0.89302478 0.40289417 0.4549365 5 0.53369832 -1.73600236 0.03584857 -0.3249856 6 0.49395437 -1.03698473 0.07879276 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 1.8484595 10 -0.83919513 1.01093743 0.99035758 -0.1747314 . - 열의 이름과 위치인덱스를 혼합하여 사용할 수 있음 (2) . A %&gt;% select(1:3, X5) . X1 X2 X3 X5 1 1.17767702 0.63070688 0.95756614 -0.1132809 2 2.73106894 0.79315491 -1.06746861 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.9040710 4 -0.03276446 -0.89302478 0.40289417 0.4549365 5 0.53369832 -1.73600236 0.03584857 -0.3249856 6 0.49395437 -1.03698473 0.07879276 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 1.8484595 10 -0.83919513 1.01093743 0.99035758 -0.1747314 . - 선택한 결과를 다른 변수에 저장가능 . A %&gt;% select(1:3, X5) -&gt; B B . X1 X2 X3 X5 1 1.17767702 0.63070688 0.95756614 -0.1132809 2 2.73106894 0.79315491 -1.06746861 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.9040710 4 -0.03276446 -0.89302478 0.40289417 0.4549365 5 0.53369832 -1.73600236 0.03584857 -0.3249856 6 0.49395437 -1.03698473 0.07879276 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 1.8484595 10 -0.83919513 1.01093743 0.99035758 -0.1747314 . select(-c()) . - A라는 자료를 다시 살펴보자. . A . X1 X2 X3 X4 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - 특정열을 제외하고 선택 . A %&gt;% select(-(X1:X3)) . X4 X5 1 -0.30129979 -0.1132809 2 0.63455394 -0.6277589 3 0.59275899 0.9040710 4 -0.02683564 0.4549365 5 0.36659406 -0.3249856 6 -0.39990796 0.1117328 7 0.03857880 -0.1888670 8 -0.94117668 -0.3054000 9 -0.52508619 1.8484595 10 0.68735157 -0.1747314 . A %&gt;% select(-(1:3)) . X4 X5 1 -0.30129979 -0.1132809 2 0.63455394 -0.6277589 3 0.59275899 0.9040710 4 -0.02683564 0.4549365 5 0.36659406 -0.3249856 6 -0.39990796 0.1117328 7 0.03857880 -0.1888670 8 -0.94117668 -0.3054000 9 -0.52508619 1.8484595 10 0.68735157 -0.1747314 . select(...,start_with()) . - 데이터 확인 . A . X1 X2 X3 X4 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - 열의 이름 확인 및 변경 . colnames(A) . [1] &#34;X1&#34; &#34;X2&#34; &#34;X3&#34; &#34;X4&#34; &#34;X5&#34; . colnames(A)= c(&#39;XY1&#39;,&#39;XY2&#39;,&#39;XZ1&#39;,&#39;XZ2&#39;,&#39;X5&#39;) . A . XY1 XY2 XZ1 XZ2 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - XY로 시작하는 열을 선택 . A %&gt;% select(starts_with(&#39;XY&#39;)) . XY1 XY2 1 1.17767702 0.63070688 2 2.73106894 0.79315491 3 -1.35304458 -0.88411918 4 -0.03276446 -0.89302478 5 0.53369832 -1.73600236 6 0.49395437 -1.03698473 7 -0.57098744 -0.01582456 8 0.08639052 0.96717754 9 0.13038589 -0.22076719 10 -0.83919513 1.01093743 . select(...,ends_with()) . - 데이터확인 . A . XY1 XY2 XZ1 XZ2 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - 2로 끝나는 열을 선택 . A %&gt;% select(ends_with(&#39;2&#39;)) . XY2 XZ2 1 0.63070688 -0.30129979 2 0.79315491 0.63455394 3 -0.88411918 0.59275899 4 -0.89302478 -0.02683564 5 -1.73600236 0.36659406 6 -1.03698473 -0.39990796 7 -0.01582456 0.03857880 8 0.96717754 -0.94117668 9 -0.22076719 -0.52508619 10 1.01093743 0.68735157 . select(...,contains()) . - 데이터확인 . A . XY1 XY2 XZ1 XZ2 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - Z를 포함하는 열을 선택 . A %&gt;% select(contains(&quot;Z&quot;)) . XZ1 XZ2 1 0.95756614 -0.30129979 2 -1.06746861 0.63455394 3 -0.80694017 0.59275899 4 0.40289417 -0.02683564 5 0.03584857 0.36659406 6 0.07879276 -0.39990796 7 -1.20817133 0.03857880 8 -0.67848560 -0.94117668 9 -0.99625585 -0.52508619 10 0.99035758 0.68735157 . select(...,everything()) . - 데이터확인 . A . XY1 XY2 XZ1 XZ2 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - Z를 포함하는 열을 앞으로 이동시킴 . A %&gt;% select(contains(&quot;Z&quot;),everything()) . XZ1 XZ2 XY1 XY2 X5 1 0.95756614 -0.30129979 1.17767702 0.63070688 -0.1132809 2 -1.06746861 0.63455394 2.73106894 0.79315491 -0.6277589 3 -0.80694017 0.59275899 -1.35304458 -0.88411918 0.9040710 4 0.40289417 -0.02683564 -0.03276446 -0.89302478 0.4549365 5 0.03584857 0.36659406 0.53369832 -1.73600236 -0.3249856 6 0.07879276 -0.39990796 0.49395437 -1.03698473 0.1117328 7 -1.20817133 0.03857880 -0.57098744 -0.01582456 -0.1888670 8 -0.67848560 -0.94117668 0.08639052 0.96717754 -0.3054000 9 -0.99625585 -0.52508619 0.13038589 -0.22076719 1.8484595 10 0.99035758 0.68735157 -0.83919513 1.01093743 -0.1747314 . filter() . - 데이터확인 . A . XY1 XY2 XZ1 XZ2 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - X5&gt;0인 행들만 뽑고싶다. . A %&gt;% filter(X5&gt;0) . XY1 XY2 XZ1 XZ2 X5 1 -1.35304458 -0.8841192 -0.80694017 0.59275899 0.9040710 2 -0.03276446 -0.8930248 0.40289417 -0.02683564 0.4549365 3 0.49395437 -1.0369847 0.07879276 -0.39990796 0.1117328 4 0.13038589 -0.2207672 -0.99625585 -0.52508619 1.8484595 . - X5&gt;0 이고 XY2&gt;0 인 행들만 뽑고싶다. . A %&gt;% filter(X5&gt;0 &amp; XY2&gt;0) . XY1 XY2 XZ1 XZ2 X5 . - 위의 결과에서 XZ를 포함하는 열을 뽑고싶다. . A %&gt;% filter(X5&gt;0 &amp; XY2&gt;0) %&gt;% select(contains(&quot;XZ&quot;)) . XZ1 XZ2 . mutate() . - 데이터를 확인 . A . XY1 XY2 XZ1 XZ2 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - 새로운 변수추가 . A %&gt;% mutate(X6=abs(X5)) . XY1 XY2 XZ1 XZ2 X5 X6 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 0.1747314 . - 여러개의 새로운 변수를 추가하는 기능도 있음 . A %&gt;% mutate(X6=abs(X5),Z7=X5**2) . XY1 XY2 XZ1 XZ2 X5 X6 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 0.1747314 Z7 1 0.01283257 2 0.39408125 3 0.81734435 4 0.20696721 5 0.10561567 6 0.01248422 7 0.03567076 8 0.09326918 9 3.41680236 10 0.03053106 . - 표준화 . A %&gt;% mutate(X6=abs(X5),Z7=X5**2,Z8=(Z7-mean(Z7))/sd(Z7)) . XY1 XY2 XZ1 XZ2 X5 X6 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 0.1747314 Z7 Z8 1 0.01283257 -0.4756090 2 0.39408125 -0.1127605 3 0.81734435 0.2900747 4 0.20696721 -0.2908439 5 0.10561567 -0.3873039 6 0.01248422 -0.4759406 7 0.03567076 -0.4538731 8 0.09326918 -0.3990545 9 3.41680236 2.7640755 10 0.03053106 -0.4587647 . group_by() . sex = c(&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;) value = c(1,2,3,10,20,30,40) . df = tibble(sex,value) df . sex value 1 M 1 2 M 2 3 M 3 4 F 10 5 F 20 6 F 30 7 F 40 . df %&gt;% group_by(sex) %&gt;% summarise(mean_value=mean(value)) . sex mean_value 1 F 25 2 M 2 . 그룹별로 묶은 다음에 평균을 계산함 | . - 신기한데? 다른것도 실습해보자. . df %&gt;% group_by(sex) %&gt;% summarise(sqrt_value=sqrt(value)) . `summarise()` has grouped output by &#39;sex&#39;. You can override using the `.groups` argument. . sex sqrt_value 1 F 3.162278 2 F 4.472136 3 F 5.477226 4 F 6.324555 5 M 1.000000 6 M 1.414214 7 M 1.732051 . 의도한 결과는 아님. 이렇게 쓰는건 아니에요! | . - 아래를 수행한 꼴임 . df %&gt;% mutate(sqrt_value=sqrt(value)) . sex value sqrt_value 1 M 1 1.000000 2 M 2 1.414214 3 M 3 1.732051 4 F 10 3.162278 5 F 20 4.472136 6 F 30 5.477226 7 F 40 6.324555 . - summarise에 쓸수 있는 함수꼴은 평균과 같이 $n$개의 벡터가 입력으로 올때 하나의 스칼라출력을 주는 함수모양이어야함 . - 예를들면 아래는 가능 . df %&gt;% group_by(sex) %&gt;% summarise(mean_sqrt_value=mean(sqrt(value))) . sex mean_sqrt_value 1 F 4.859049 2 M 1.382088 . (sqrt(1)+sqrt(2)+sqrt(3))/3 . [1] 1.382088 . (sqrt(10)+sqrt(20)+sqrt(30)+sqrt(40))/4 . [1] 4.859049 . - group_by + mutate . df %&gt;% group_by(sex) %&gt;% mutate(value2= value-mean(value)) . sex value value2 1 M 1 -1 2 M 2 0 3 M 3 1 4 F 10 -15 5 F 20 -5 6 F 30 5 7 F 40 15 . - 위의 코드는 아래와 동일하다. . df %&gt;% filter(sex==&#39;M&#39;) %&gt;% mutate(value2 = value - mean(value)) . sex value value2 1 M 1 -1 2 M 2 0 3 M 3 1 . df %&gt;% filter(sex==&#39;F&#39;) %&gt;% mutate(value2 = value - mean(value)) . sex value value2 1 F 10 -15 2 F 20 -5 3 F 30 5 4 F 40 15 . df %&gt;% filter(sex==&#39;M&#39;) %&gt;% mutate(value2 = value - mean(value)) -&gt; A1 df %&gt;% filter(sex==&#39;F&#39;) %&gt;% mutate(value2 = value - mean(value)) -&gt; A2 . A1 . sex value value2 1 M 1 -1 2 M 2 0 3 M 3 1 . A2 . sex value value2 1 F 10 -15 2 F 20 -5 3 F 30 5 4 F 40 15 . - 두 데이터프레임을 합치면 된다. (어떻게..??) . rbind(A1,A2) # 아 몰라.. 매트릭스처럼 하면 되지 않을까? . sex value value2 1 M 1 -1 2 M 2 0 3 M 3 1 4 F 10 -15 5 F 20 -5 6 F 30 5 7 F 40 15 . 된다... (떡밥) | . NA . - NA 포함되어도 개별연산은 괜찮아요 . x = c(1,2,NA,4,5) x . [1] 1 2 NA 4 5 . x+1 . [1] 2 3 NA 5 6 . x**2 . [1] 1 4 NA 16 25 . - 그런데 summarise에 쓸 연산은 망가져요 . mean(x) . [1] NA . max(x) . [1] NA . - 수정을 위해서 . mean(x,na.rm=TRUE) . [1] 3 . max(x,na.rm=TRUE) . [1] 5 . - 데이터프레임에서도 비슷합니다. . tibble(x) %&gt;% mutate(z=x+1) . x z 1 1 2 2 2 3 3 NA NA 4 4 5 5 5 6 . tibble(x) %&gt;% summarise(z=mean(x)) . z 1 NA . tibble(x) %&gt;% summarise(z=mean(x,na.rm=TRUE)) . z 1 3 . - NA를 무조건 없애는것이 좋은가? . x&lt;- c(1,2,NA,4) y&lt;- c(1,NA,3,4) z&lt;- c(NA,2,3,4) w&lt;- c(1,2,3,NA) . tibble(x,y,z,w) . x y z w 1 1 1 NA 1 2 2 NA 2 2 3 NA 3 3 3 4 4 4 4 NA . tibble(x,y,z,w) %&gt;% mutate(xy=x+y) . x y z w xy 1 1 1 NA 1 2 2 2 NA 2 2 NA 3 NA 3 3 3 NA 4 4 4 4 NA 8 . tibble(x,y,z,w) %&gt;% mutate(xy=x+y) %&gt;% summarise(mean_xy = mean(xy,na.rm=TRUE)) . mean_xy 1 5 . 그래도 NA를 살려두면 좋지않을까? 데이터 하나하나가 소중하니까요! | . - 결측치를 살릴까 죽일까? . x=c(1,2,3,4,NA,5,6,7) y=c(-1,-2,-3,-4,77,-5,-6,-7) . tibble(x,y) . x y 1 1 -1 2 2 -2 3 3 -3 4 4 -4 5 NA 77 6 5 -5 7 6 -6 8 7 -7 . tibble(x,y) %&gt;% filter(x&gt;3,x&lt;7) . x y 1 4 -4 2 5 -5 3 6 -6 . ?? y=77 은 죄없이 사라짐. 사실 보류로 봐야하지않나? NA는 3보다 크지 않지만 작지도 않음, 또한 7보다 크지 않지만 작지도 않음 | . - 결측치를 살리고 싶다. . tibble(x,y) %&gt;% filter(is.na(x)) . x y 1 NA 77 . tibble(x,y) %&gt;% filter(is.na(x) | (x&gt;3 &amp; x&lt;7)) . x y 1 4 -4 2 NA 77 3 5 -5 4 6 -6 . 데이터는 소중함 | . &#49892;&#49845; . library(nycflights13) . ref: https://r4ds.had.co.nz/transform.html | . df=flights df . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour 1 11 UA 1545 N14228 EWR IAH 227 1400 5 2 20 UA 1714 N24211 LGA IAH 227 1416 5 3 33 AA 1141 N619AA JFK MIA 160 1089 5 4 -18 B6 725 N804JB JFK BQN 183 1576 5 5 -25 DL 461 N668DN LGA ATL 116 762 6 6 12 UA 1696 N39463 EWR ORD 150 719 5 7 19 B6 507 N516JB EWR FLL 158 1065 6 8 -14 EV 5708 N829AS LGA IAD 53 229 6 9 -8 B6 79 N593JB JFK MCO 140 944 6 10 8 AA 301 N3ALAA LGA ORD 138 733 6 minute time_hour 1 15 2013-01-01 05:00:00 2 29 2013-01-01 05:00:00 3 40 2013-01-01 05:00:00 4 45 2013-01-01 05:00:00 5 0 2013-01-01 06:00:00 6 58 2013-01-01 05:00:00 7 0 2013-01-01 06:00:00 8 0 2013-01-01 06:00:00 9 0 2013-01-01 06:00:00 10 0 2013-01-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . - 1월1일의 모든 항공편을 선택하고싶다. . df %&gt;% filter(month==1 &amp; day==1) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour minute 1 11 UA 1545 N14228 EWR IAH 227 1400 5 15 2 20 UA 1714 N24211 LGA IAH 227 1416 5 29 3 33 AA 1141 N619AA JFK MIA 160 1089 5 40 4 -18 B6 725 N804JB JFK BQN 183 1576 5 45 5 -25 DL 461 N668DN LGA ATL 116 762 6 0 6 12 UA 1696 N39463 EWR ORD 150 719 5 58 7 19 B6 507 N516JB EWR FLL 158 1065 6 0 8 -14 EV 5708 N829AS LGA IAD 53 229 6 0 9 -8 B6 79 N593JB JFK MCO 140 944 6 0 10 8 AA 301 N3ALAA LGA ORD 138 733 6 0 time_hour 1 2013-01-01 05:00:00 2 2013-01-01 05:00:00 3 2013-01-01 05:00:00 4 2013-01-01 05:00:00 5 2013-01-01 06:00:00 6 2013-01-01 05:00:00 7 2013-01-01 06:00:00 8 2013-01-01 06:00:00 9 2013-01-01 06:00:00 10 2013-01-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . df %&gt;% filter(month==1 , day==1) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour minute 1 11 UA 1545 N14228 EWR IAH 227 1400 5 15 2 20 UA 1714 N24211 LGA IAH 227 1416 5 29 3 33 AA 1141 N619AA JFK MIA 160 1089 5 40 4 -18 B6 725 N804JB JFK BQN 183 1576 5 45 5 -25 DL 461 N668DN LGA ATL 116 762 6 0 6 12 UA 1696 N39463 EWR ORD 150 719 5 58 7 19 B6 507 N516JB EWR FLL 158 1065 6 0 8 -14 EV 5708 N829AS LGA IAD 53 229 6 0 9 -8 B6 79 N593JB JFK MCO 140 944 6 0 10 8 AA 301 N3ALAA LGA ORD 138 733 6 0 time_hour 1 2013-01-01 05:00:00 2 2013-01-01 05:00:00 3 2013-01-01 05:00:00 4 2013-01-01 05:00:00 5 2013-01-01 06:00:00 6 2013-01-01 05:00:00 7 2013-01-01 06:00:00 8 2013-01-01 06:00:00 9 2013-01-01 06:00:00 10 2013-01-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . - 11월에 출발하거나 12월에 출발한 항공 . df %&gt;% filter(month==11 | month==12) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 11 1 5 2359 6 352 345 2 2013 11 1 35 2250 105 123 2356 3 2013 11 1 455 500 -5 641 651 4 2013 11 1 539 545 -6 856 827 5 2013 11 1 542 545 -3 831 855 6 2013 11 1 549 600 -11 912 923 7 2013 11 1 550 600 -10 705 659 8 2013 11 1 554 600 -6 659 701 9 2013 11 1 554 600 -6 826 827 10 2013 11 1 554 600 -6 749 751 arr_delay carrier flight tailnum origin dest air_time distance hour 1 7 B6 745 N568JB JFK PSE 205 1617 23 2 87 B6 1816 N353JB JFK SYR 36 209 22 3 -10 US 1895 N192UW EWR CLT 88 529 5 4 29 UA 1714 N38727 LGA IAH 229 1416 5 5 -24 AA 2243 N5CLAA JFK MIA 147 1089 5 6 -11 UA 303 N595UA JFK SFO 359 2586 6 7 6 US 2167 N748UW LGA DCA 57 214 6 8 -2 US 2134 N742PS LGA BOS 40 184 6 9 -1 DL 563 N912DE LGA ATL 126 762 6 10 -2 DL 731 N315NB LGA DTW 93 502 6 minute time_hour 1 59 2013-11-01 23:00:00 2 50 2013-11-01 22:00:00 3 0 2013-11-01 05:00:00 4 45 2013-11-01 05:00:00 5 45 2013-11-01 05:00:00 6 0 2013-11-01 06:00:00 7 0 2013-11-01 06:00:00 8 0 2013-11-01 06:00:00 9 0 2013-11-01 06:00:00 10 0 2013-11-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . - 아래와 동일한 코드 . df %&gt;% filter(month %in% c(11,12)) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 11 1 5 2359 6 352 345 2 2013 11 1 35 2250 105 123 2356 3 2013 11 1 455 500 -5 641 651 4 2013 11 1 539 545 -6 856 827 5 2013 11 1 542 545 -3 831 855 6 2013 11 1 549 600 -11 912 923 7 2013 11 1 550 600 -10 705 659 8 2013 11 1 554 600 -6 659 701 9 2013 11 1 554 600 -6 826 827 10 2013 11 1 554 600 -6 749 751 arr_delay carrier flight tailnum origin dest air_time distance hour 1 7 B6 745 N568JB JFK PSE 205 1617 23 2 87 B6 1816 N353JB JFK SYR 36 209 22 3 -10 US 1895 N192UW EWR CLT 88 529 5 4 29 UA 1714 N38727 LGA IAH 229 1416 5 5 -24 AA 2243 N5CLAA JFK MIA 147 1089 5 6 -11 UA 303 N595UA JFK SFO 359 2586 6 7 6 US 2167 N748UW LGA DCA 57 214 6 8 -2 US 2134 N742PS LGA BOS 40 184 6 9 -1 DL 563 N912DE LGA ATL 126 762 6 10 -2 DL 731 N315NB LGA DTW 93 502 6 minute time_hour 1 59 2013-11-01 23:00:00 2 50 2013-11-01 22:00:00 3 0 2013-11-01 05:00:00 4 45 2013-11-01 05:00:00 5 45 2013-11-01 05:00:00 6 0 2013-11-01 06:00:00 7 0 2013-11-01 06:00:00 8 0 2013-11-01 06:00:00 9 0 2013-11-01 06:00:00 10 0 2013-11-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . - arr_delay &lt;=120 이고 dep_delay &lt;=120 인 항공편을 찾고 싶다. . df %&gt;% filter(arr_delay &lt;= 120, dep_delay&lt;=120) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour 1 11 UA 1545 N14228 EWR IAH 227 1400 5 2 20 UA 1714 N24211 LGA IAH 227 1416 5 3 33 AA 1141 N619AA JFK MIA 160 1089 5 4 -18 B6 725 N804JB JFK BQN 183 1576 5 5 -25 DL 461 N668DN LGA ATL 116 762 6 6 12 UA 1696 N39463 EWR ORD 150 719 5 7 19 B6 507 N516JB EWR FLL 158 1065 6 8 -14 EV 5708 N829AS LGA IAD 53 229 6 9 -8 B6 79 N593JB JFK MCO 140 944 6 10 8 AA 301 N3ALAA LGA ORD 138 733 6 minute time_hour 1 15 2013-01-01 05:00:00 2 29 2013-01-01 05:00:00 3 40 2013-01-01 05:00:00 4 45 2013-01-01 05:00:00 5 0 2013-01-01 06:00:00 6 58 2013-01-01 05:00:00 7 0 2013-01-01 06:00:00 8 0 2013-01-01 06:00:00 9 0 2013-01-01 06:00:00 10 0 2013-01-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . df %&gt;% filter(arr_delay &lt;= 120 &amp; dep_delay&lt;=120) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour 1 11 UA 1545 N14228 EWR IAH 227 1400 5 2 20 UA 1714 N24211 LGA IAH 227 1416 5 3 33 AA 1141 N619AA JFK MIA 160 1089 5 4 -18 B6 725 N804JB JFK BQN 183 1576 5 5 -25 DL 461 N668DN LGA ATL 116 762 6 6 12 UA 1696 N39463 EWR ORD 150 719 5 7 19 B6 507 N516JB EWR FLL 158 1065 6 8 -14 EV 5708 N829AS LGA IAD 53 229 6 9 -8 B6 79 N593JB JFK MCO 140 944 6 10 8 AA 301 N3ALAA LGA ORD 138 733 6 minute time_hour 1 15 2013-01-01 05:00:00 2 29 2013-01-01 05:00:00 3 40 2013-01-01 05:00:00 4 45 2013-01-01 05:00:00 5 0 2013-01-01 06:00:00 6 58 2013-01-01 05:00:00 7 0 2013-01-01 06:00:00 8 0 2013-01-01 06:00:00 9 0 2013-01-01 06:00:00 10 0 2013-01-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . df %&gt;% filter(!(arr_delay &gt; 120 | dep_delay&gt; 120)) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour 1 11 UA 1545 N14228 EWR IAH 227 1400 5 2 20 UA 1714 N24211 LGA IAH 227 1416 5 3 33 AA 1141 N619AA JFK MIA 160 1089 5 4 -18 B6 725 N804JB JFK BQN 183 1576 5 5 -25 DL 461 N668DN LGA ATL 116 762 6 6 12 UA 1696 N39463 EWR ORD 150 719 5 7 19 B6 507 N516JB EWR FLL 158 1065 6 8 -14 EV 5708 N829AS LGA IAD 53 229 6 9 -8 B6 79 N593JB JFK MCO 140 944 6 10 8 AA 301 N3ALAA LGA ORD 138 733 6 minute time_hour 1 15 2013-01-01 05:00:00 2 29 2013-01-01 05:00:00 3 40 2013-01-01 05:00:00 4 45 2013-01-01 05:00:00 5 0 2013-01-01 06:00:00 6 58 2013-01-01 05:00:00 7 0 2013-01-01 06:00:00 8 0 2013-01-01 06:00:00 9 0 2013-01-01 06:00:00 10 0 2013-01-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . - 변수이름을 확인하자. . df %&gt;% colnames . [1] &#34;year&#34; &#34;month&#34; &#34;day&#34; &#34;dep_time&#34; [5] &#34;sched_dep_time&#34; &#34;dep_delay&#34; &#34;arr_time&#34; &#34;sched_arr_time&#34; [9] &#34;arr_delay&#34; &#34;carrier&#34; &#34;flight&#34; &#34;tailnum&#34; [13] &#34;origin&#34; &#34;dest&#34; &#34;air_time&#34; &#34;distance&#34; [17] &#34;hour&#34; &#34;minute&#34; &#34;time_hour&#34; . df %&gt;% names . [1] &#34;year&#34; &#34;month&#34; &#34;day&#34; &#34;dep_time&#34; [5] &#34;sched_dep_time&#34; &#34;dep_delay&#34; &#34;arr_time&#34; &#34;sched_arr_time&#34; [9] &#34;arr_delay&#34; &#34;carrier&#34; &#34;flight&#34; &#34;tailnum&#34; [13] &#34;origin&#34; &#34;dest&#34; &#34;air_time&#34; &#34;distance&#34; [17] &#34;hour&#34; &#34;minute&#34; &#34;time_hour&#34; . 왜 방법이 두개있을까? (떡밥) | . - 변수가 너무 많아서 귀찮음. 몇개만 추리자. . year~day 는 포함 | delay로 끝나는 변수들 | distance, air_time | . df %&gt;% select(year:day, ends_with(&#39;delay&#39;), distance, air_time) . year month day dep_delay arr_delay distance air_time 1 2013 1 1 2 11 1400 227 2 2013 1 1 4 20 1416 227 3 2013 1 1 2 33 1089 160 4 2013 1 1 -1 -18 1576 183 5 2013 1 1 -6 -25 762 116 6 2013 1 1 -4 12 719 150 7 2013 1 1 -5 19 1065 158 8 2013 1 1 -3 -14 229 53 9 2013 1 1 -3 -8 944 140 10 2013 1 1 -2 8 733 138 11 2013 1 1 -2 -2 1028 149 12 2013 1 1 -2 -3 1005 158 13 2013 1 1 -2 7 2475 345 14 2013 1 1 -2 -14 2565 361 15 2013 1 1 -1 31 1389 257 16 2013 1 1 0 -4 187 44 17 2013 1 1 -1 -8 2227 337 18 2013 1 1 0 -7 1076 152 19 2013 1 1 0 12 762 134 20 2013 1 1 1 -6 1023 147 21 2013 1 1 -8 -8 1020 170 22 2013 1 1 -3 16 502 105 23 2013 1 1 -4 -12 1085 152 24 2013 1 1 -4 -8 760 128 25 2013 1 1 0 -17 1085 157 26 2013 1 1 8 32 719 139 27 2013 1 1 11 14 2586 366 28 2013 1 1 3 4 1074 175 [ reached getOption(&#34;max.print&#34;) -- omitted 33 rows ] . - 아래의 수식을 이용해서 gain, speed를 계산하자. . gain = dep_delay - arr_delay | speed = distance / air_time | . df %&gt;% select(year:day, ends_with(&#39;delay&#39;), distance, air_time) %&gt;% mutate(gain = dep_delay - arr_delay, speed = distance / air_time) . year month day dep_delay arr_delay distance air_time gain speed 1 2013 1 1 2 11 1400 227 -9 6.167401 2 2013 1 1 4 20 1416 227 -16 6.237885 3 2013 1 1 2 33 1089 160 -31 6.806250 4 2013 1 1 -1 -18 1576 183 17 8.612022 5 2013 1 1 -6 -25 762 116 19 6.568966 6 2013 1 1 -4 12 719 150 -16 4.793333 7 2013 1 1 -5 19 1065 158 -24 6.740506 8 2013 1 1 -3 -14 229 53 11 4.320755 9 2013 1 1 -3 -8 944 140 5 6.742857 10 2013 1 1 -2 8 733 138 -10 5.311594 11 2013 1 1 -2 -2 1028 149 0 6.899329 12 2013 1 1 -2 -3 1005 158 1 6.360759 13 2013 1 1 -2 7 2475 345 -9 7.173913 14 2013 1 1 -2 -14 2565 361 12 7.105263 15 2013 1 1 -1 31 1389 257 -32 5.404669 16 2013 1 1 0 -4 187 44 4 4.250000 17 2013 1 1 -1 -8 2227 337 7 6.608309 18 2013 1 1 0 -7 1076 152 7 7.078947 19 2013 1 1 0 12 762 134 -12 5.686567 20 2013 1 1 1 -6 1023 147 7 6.959184 21 2013 1 1 -8 -8 1020 170 0 6.000000 22 2013 1 1 -3 16 502 105 -19 4.780952 [ reached getOption(&#34;max.print&#34;) -- omitted 39 rows ] . - year, month, day 로 그룹핑을하고 평균속도와 평균gain을 계산해보자. . df %&gt;% select(year:day, ends_with(&#39;delay&#39;), distance, air_time) %&gt;% mutate(gain = dep_delay - arr_delay, speed = distance / air_time) %&gt;% group_by(year,month,day) %&gt;% summarise(gain_mean=mean(gain),speed_mean=mean(speed)) . `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. . year month day gain_mean speed_mean 1 2013 1 1 NA NA 2 2013 1 2 NA NA 3 2013 1 3 NA NA 4 2013 1 4 NA NA 5 2013 1 5 NA NA 6 2013 1 6 NA NA 7 2013 1 7 NA NA 8 2013 1 8 NA NA 9 2013 1 9 NA NA 10 2013 1 10 NA NA 11 2013 1 11 NA NA 12 2013 1 12 NA NA 13 2013 1 13 NA NA 14 2013 1 14 NA NA 15 2013 1 15 NA NA 16 2013 1 16 NA NA 17 2013 1 17 NA NA 18 2013 1 18 NA NA 19 2013 1 19 NA NA 20 2013 1 20 NA NA 21 2013 1 21 NA NA 22 2013 1 22 NA NA 23 2013 1 23 NA NA 24 2013 1 24 NA NA 25 2013 1 25 NA NA 26 2013 1 26 NA NA 27 2013 1 27 NA NA 28 2013 1 28 NA NA 29 2013 1 29 NA NA 30 2013 1 30 NA NA ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ 336 2013 12 2 NA NA 337 2013 12 3 NA NA 338 2013 12 4 NA NA 339 2013 12 5 NA NA 340 2013 12 6 NA NA 341 2013 12 7 NA NA 342 2013 12 8 NA NA 343 2013 12 9 NA NA 344 2013 12 10 NA NA [ reached getOption(&#34;max.print&#34;) -- omitted 21 rows ] . 다 NA가 나옴.. | . df %&gt;% select(year:day, ends_with(&#39;delay&#39;), distance, air_time) %&gt;% mutate(gain = dep_delay - arr_delay, speed = distance / air_time) %&gt;% group_by(year,month,day) %&gt;% summarise(gain_mean=mean(gain,na.rm=TRUE),speed_mean=mean(speed,na.rm=TRUE)) . `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. . year month day gain_mean speed_mean 1 2013 1 1 -1.2154031 5.956879 2 2013 1 2 0.9849138 6.085977 3 2013 1 3 5.1744444 6.163061 4 2013 1 4 10.8986784 6.389652 5 2013 1 5 7.2580195 6.259174 6 2013 1 6 2.9095296 6.146544 7 2013 1 7 10.3645161 6.488469 8 2013 1 8 5.7858744 6.215331 9 2013 1 9 2.5655095 6.021767 10 2013 1 10 8.7438105 6.375353 11 2013 1 11 7.5954198 6.326487 12 2013 1 12 14.6093979 6.613691 13 2013 1 13 4.6877323 6.353392 14 2013 1 14 -0.8418202 6.018617 15 2013 1 15 -0.3019296 5.918271 16 2013 1 16 -9.7924971 5.819344 17 2013 1 17 1.1923497 5.923112 18 2013 1 18 4.9263736 6.207338 19 2013 1 19 11.8882265 6.340853 20 2013 1 20 3.0640205 6.098927 21 2013 1 21 1.5232816 5.911828 22 2013 1 22 0.2225989 5.966793 23 2013 1 23 3.6925676 6.081496 24 2013 1 24 4.1156388 6.305144 25 2013 1 25 -5.3469852 6.177677 26 2013 1 26 6.4619970 6.342779 27 2013 1 27 9.6972705 6.371808 28 2013 1 28 5.7794632 6.288730 29 2013 1 29 9.1047181 6.297918 30 2013 1 30 2.0226131 6.072084 ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ 336 2013 12 2 8.6172345 6.538165 337 2013 12 3 3.7637306 6.385837 338 2013 12 4 5.5354497 6.374694 339 2013 12 5 0.7886279 6.315847 340 2013 12 6 -4.9424779 6.088300 341 2013 12 7 -0.5210210 6.083830 342 2013 12 8 -16.0335404 6.015119 343 2013 12 9 -7.9688889 5.927017 344 2013 12 10 -18.0433018 5.851833 [ reached getOption(&#34;max.print&#34;) -- omitted 21 rows ] . &#49689;&#51228; . 강화유리와 유리를 구분할 수 있는 유리 장인이 있다. . 이 유리장인은 80퍼센트의 확률로 강화유리를 고른다. . 총 10명의 참가자가 있고 이 참가자들은 (유리,강화유리)의 조합으로 이루어진 징검다리를 5번연속으로 건너야 한다. . 아래의 경우에 참가자들은 평균적으로 몇명이 살아남겠는가? . (1) 일반인1 - 일반인2 - .... - 일반인9 - 유리장인 || (강화유리, 유리) . (2) 유리장인 - 일반인1 - 일반인2 - ... - 일반인9 || (강화유리, 유리) . 1000번 시뮬레이션을 하여 결과를 추정하라. . (단, 일반인은 50%의 확률로 강화유리를 고를수 있다고 하자) . . [예시] (1)의 시뮬레이션 결과가 아래와 같다고 하자. . 첫번째 징검다리: 유리장인이 강화유리 선택 | 두번째 징검다리: 유리장인이 강화유리 선택 | 세번째 징검다리: 유리장인이 일반유리 선택 $ to$ 유리장인 탈락 &amp; 일반인9는 당연히 강화유리를 선택 | 네번째 징검다리: 일반인9가 일반유리 선택 $ to$ 일반인9 탈락 &amp; 일반인8은 당연히 강화유리 선택 | 다섯번째 징검다리: 일반인8이 강화유리 선택 | . 이 경우는 일반인8,일반인7, $ dots$, 일반인1이 살아남으므로 8명이 살아남는다. . [예시] (2)의 시뮬레이션 결과가 아래와 같다고 하자. . 첫번째 징검다리: 일반인9 일반유리 선택 $ to$ 일반인9 탈락 &amp; 일반인8은 강화유리 선택 | 두번째 징검다리: 일반인8 일반유리 선택 $ to$ 일반인8 탈락 &amp; 일반인7은 강화유리 선택 | 세번째 징검다리: 일반인7 일반유리 선택 $ to$ 일반인7 탈락 &amp; 일반인6은 강화유리 선택 | 네번째 징검다리: 일반인6 일반유리 선택 $ to$ 일반인6 탈락 &amp; 일반인5는 강화유리 선택 | 다섯번째 징검다리: 일반인5 일반유리 선택 $ to$ 일반인5 탈락 &amp; 일반인4는 강화유리 선택 | . 이 경우는 일반인4,일반인3,일반인2,일반인1,유리장인 이 살아남는다. (따라서 5명) . - 즉 살아남을수 있는 최대인원수는 10명이며 최소인원수는 5명이다. . - 유리장인이 100%의 확률로 강화유리를 구분한다면 (1)의 경우 항상 10명이 살아남는다. (즉 평균도 10명) .",
            "url": "https://guebin.github.io/2021IR/2021/11/30/(12%EC%A3%BC%EC%B0%A8)-11%EC%9B%9430%EC%9D%BC,-11%EC%9B%9425%EC%9D%BC-%EB%B3%B4%EA%B0%95.html",
            "relUrl": "/2021/11/30/(12%EC%A3%BC%EC%B0%A8)-11%EC%9B%9430%EC%9D%BC,-11%EC%9B%9425%EC%9D%BC-%EB%B3%B4%EA%B0%95.html",
            "date": " • Nov 30, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "(11주차) 11월23일",
            "content": "library(tidyverse) . &#44053;&#51032;&#50689;&#49345; . . - (1/3) 징검다리 문제풀이 . - (2/3) 징검다리 문제풀이 . - (3/3) 징검다리 문제풀이 . &#51669;&#44160;&#45796;&#47532;&#47928;&#51228;&#54400;&#51060; . (&#54400;&#51060;1) . - (유리, 강화유리) . set = c(&#39;tempered glass&#39;,&#39;glass&#39;) set . [1] &#34;tempered glass&#34; &#34;glass&#34; . - sample을 이용하여 0.8의 확률로 강화유리를 뽑음 . sample(size=5, set, prob=c(0.8,0.2),replace=T) . [1] &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;glass&#34; [5] &#34;tempered glass&#34; . - 함수로 보기좋게 만들자. . simulate_once = function() sample(size=5, set, prob=c(0.8,0.2),replace=T) #입력이 없는 함수 . simulate_once() . [1] &#34;glass&#34; &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;tempered glass&#34; [5] &#34;tempered glass&#34; . - 뽑은결과를 바탕으로 사망유무를 판단 . a = simulate_once() a . [1] &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;glass&#34; [5] &#34;tempered glass&#34; . a[1] == &quot;tempered glass&quot; &amp; a[2] == &quot;tempered glass&quot; &amp; a[3] == &quot;tempered glass&quot; &amp; a[4] == &quot;tempered glass&quot; &amp; a[5] == &quot;tempered glass&quot; . [1] FALSE . 조건 | . - 위의 조건이 참이면 b=1, 참이 아니라면 b=0 . if (a[1] == &quot;tempered glass&quot; &amp; a[2] == &quot;tempered glass&quot; &amp; a[3] == &quot;tempered glass&quot; &amp; a[4] == &quot;tempered glass&quot; &amp; a[5] == &quot;tempered glass&quot;){ b=1 }else{ b=0} . b . [1] 0 . - 함수로 정리하자. . test = function(a){ if (a[1] == &quot;tempered glass&quot; &amp; a[2] == &quot;tempered glass&quot; &amp; a[3] == &quot;tempered glass&quot; &amp; a[4] == &quot;tempered glass&quot; &amp; a[5] == &quot;tempered glass&quot;) b=1 else b=0 b } . a=simulate_once() print(a) test(a) . [1] &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;tempered glass&#34; [5] &#34;tempered glass&#34; . [1] 1 . - 답을 구해보자 . sum_ = 0 for (i in 1:1000) sum_ = sum_ + test(simulate_once()) . sum_ . [1] 322 . (&#54400;&#51060;2) . - 시행결과를 벡터로하는 편이 좋겠다. . set = c(&#39;tempered glass&#39;,&#39;glass&#39;) simulate_once = function() sample(size=5, set, prob=c(0.8,0.2),replace=T) #입력이 없는 함수 test = function(a){ if (a[1] == &quot;tempered glass&quot; &amp; a[2] == &quot;tempered glass&quot; &amp; a[3] == &quot;tempered glass&quot; &amp; a[4] == &quot;tempered glass&quot; &amp; a[5] == &quot;tempered glass&quot;) b=1 else b=0 b } # sum_ = 0 # for (i in 1:1000) sum_ = sum_ + test(simulate_once()) 컨트롤+/ (Rstudio: 컨트롤+쉬프트+c) rslt = c() for (i in 1:1000) rslt[i] = test(simulate_once()) . rslt . [1] 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 [38] 0 0 0 1 0 0 0 1 1 0 0 1 0 1 0 0 1 0 1 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 1 [75] 0 1 1 1 1 0 1 1 1 0 1 0 0 1 0 1 1 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 [112] 0 0 1 0 1 0 1 0 1 0 0 0 0 1 0 0 0 1 1 1 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 1 1 [149] 1 0 0 0 0 1 0 0 1 1 1 0 0 1 1 1 0 1 0 1 0 0 1 0 1 1 0 1 0 1 0 0 1 1 1 0 0 [186] 0 1 0 0 1 0 0 1 0 0 0 0 0 1 0 [ reached getOption(&#34;max.print&#34;) -- omitted 800 entries ] . sum(rslt) . [1] 317 . (&#54400;&#51060;3) . - 시뮬레이션 결과를 매트릭스에 저장하면 더 디버깅이 용이하다. . mat = rep(0,1000*5) dim(mat) = c(1000,5) head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] 0 0 0 0 0 [2,] 0 0 0 0 0 [3,] 0 0 0 0 0 [4,] 0 0 0 0 0 [5,] 0 0 0 0 0 [6,] 0 0 0 0 0 . mat[1,] . [1] 0 0 0 0 0 . mat[1,] = simulate_once() . head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] glass tempered glass tempered glass tempered glass glass [2,] 0 0 0 0 0 [3,] 0 0 0 0 0 [4,] 0 0 0 0 0 [5,] 0 0 0 0 0 [6,] 0 0 0 0 0 . for (i in 1:1000) mat[i,] = simulate_once() . head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] tempered glass tempered glass tempered glass tempered glass tempered glass [2,] glass tempered glass tempered glass tempered glass glass [3,] tempered glass tempered glass tempered glass tempered glass tempered glass [4,] tempered glass tempered glass tempered glass tempered glass tempered glass [5,] tempered glass tempered glass glass glass tempered glass [6,] tempered glass tempered glass tempered glass glass tempered glass . rslt=c() for (i in 1:1000) rslt[i] = test(mat[i,]) . rslt[1:5] . [1] 1 0 1 1 0 . mat[1:5,] . [,1] [,2] [,3] [,4] [,5] [1,] tempered glass tempered glass tempered glass tempered glass tempered glass [2,] glass tempered glass tempered glass tempered glass glass [3,] tempered glass tempered glass tempered glass tempered glass tempered glass [4,] tempered glass tempered glass tempered glass tempered glass tempered glass [5,] tempered glass tempered glass glass glass tempered glass . - 정리하면 . set = c(&#39;tempered glass&#39;,&#39;glass&#39;) simulate_once = function() sample(size=5, set, prob=c(0.8,0.2),replace=T) #입력이 없는 함수 test = function(a){ if (a[1] == &quot;tempered glass&quot; &amp; a[2] == &quot;tempered glass&quot; &amp; a[3] == &quot;tempered glass&quot; &amp; a[4] == &quot;tempered glass&quot; &amp; a[5] == &quot;tempered glass&quot;) b=1 else b=0 b } mat = rep(0,1000*5) dim(mat) = c(1000,5) rslt = c() # for (i in 1:1000) rslt[i] = test(simulate_once()) for (i in 1:1000){ mat[i,] = simulate_once() rslt[i] = test(mat[i,]) } sum(rslt) . [1] 329 . (&#54400;&#51060;4) . - 어차피 mat 매트릭스만 만들면 되니까 . set = c(&#39;tempered glass&#39;,&#39;glass&#39;) mat= sample(size=1000*5, set, prob=c(0.8,0.2),replace=T) #입력이 없는 함수 dim(mat)=c(1000,5) . head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] glass tempered glass glass tempered glass tempered glass [2,] tempered glass tempered glass glass tempered glass glass [3,] tempered glass tempered glass tempered glass glass glass [4,] tempered glass tempered glass tempered glass glass tempered glass [5,] tempered glass tempered glass tempered glass tempered glass tempered glass [6,] tempered glass tempered glass tempered glass tempered glass tempered glass . test = function(a){ if (a[1] == &quot;tempered glass&quot; &amp; a[2] == &quot;tempered glass&quot; &amp; a[3] == &quot;tempered glass&quot; &amp; a[4] == &quot;tempered glass&quot; &amp; a[5] == &quot;tempered glass&quot;) b=1 else b=0 b } rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } sum(rslt) . [1] 326 . (&#54400;&#51060;5) . - 매트릭스의 원소가 꼭 문자열일 필요는 없는것 같음 . set = c(1,0) mat= sample(size=1000*5, set, prob=c(0.8,0.2),replace=T) #입력이 없는 함수 dim(mat)=c(1000,5) . head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] 1 1 1 1 1 [2,] 1 0 1 1 1 [3,] 1 1 1 1 1 [4,] 0 1 1 0 1 [5,] 1 1 1 1 1 [6,] 0 1 1 1 1 . test = function(a){ if (a[1] == 1 &amp; a[2] == 1 &amp; a[3] == 1 &amp; a[4] == 1 &amp; a[5] == 1) b=1 else b=0 b } rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } sum(rslt) . [1] 355 . - 조건도 아래와 같이 간소화할 수있다. . test = function(a){ if (sum(a)==5) b=1 else b=0 b } rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } sum(rslt) . [1] 355 . - 아래와 같이 바꿔도 가능 . test = function(a){ if (prod(a)==1) b=1 else b=0 b } rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } sum(rslt) . [1] 355 . - test함수 자체도 아래와 같이 간소화 가능 . test = function(a){ prod(c(1,0,1,1,1))==1 } . - 정리하면 . set = c(1,0) mat= sample(size=1000*5, set, prob=c(0.8,0.2),replace=T) #입력이 없는 함수 dim(mat)=c(1000,5) head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] 1 1 1 1 1 [2,] 1 1 1 0 1 [3,] 0 0 1 1 1 [4,] 1 1 1 1 1 [5,] 1 0 1 0 1 [6,] 0 1 0 1 1 . test = function(a) prod(a)==1 rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } sum(rslt) . [1] 334 . (&#54400;&#51060;6) . - 숫자로 만들고 보니까 베르누이로 뽑아도 괜찮을 것 같다. . rbinom(5,size=1,prob=0.8) # 하나의행 . [1] 1 1 1 1 1 . set을 만들 필요가 없음 | . mat = rbinom(1000*5,size=1,prob=0.8) dim(mat)=c(1000,5) head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] 1 1 1 1 0 [2,] 1 1 1 1 1 [3,] 1 1 1 1 1 [4,] 1 1 0 1 1 [5,] 1 1 1 1 0 [6,] 1 1 1 1 1 . test = function(a) prod(a)==1 rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } sum(rslt) . [1] 341 . (&#54400;&#51060;7) . - 매트릭스 옆에 결과를 붙여보자. . mat = rbinom(1000*5,size=1,prob=0.8) dim(mat)=c(1000,5) head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] 1 1 1 1 1 [2,] 1 0 1 1 1 [3,] 1 1 1 0 1 [4,] 1 1 0 0 1 [5,] 1 0 0 1 0 [6,] 0 1 1 0 1 . test = function(a) prod(a)==1 rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } . cbind(mat,rslt)[1:20,] . rslt [1,] 1 1 1 1 1 1 [2,] 1 0 1 1 1 0 [3,] 1 1 1 0 1 0 [4,] 1 1 0 0 1 0 [5,] 1 0 0 1 0 0 [6,] 0 1 1 0 1 0 [7,] 1 1 0 0 1 0 [8,] 0 1 1 1 1 0 [9,] 1 1 1 1 1 1 [10,] 0 1 1 0 1 0 [11,] 1 1 1 0 1 0 [12,] 0 1 1 1 0 0 [13,] 1 1 1 1 1 1 [14,] 1 1 1 0 0 0 [15,] 1 1 1 1 1 1 [16,] 1 1 1 1 1 1 [17,] 1 1 1 1 1 1 [18,] 1 1 1 1 1 1 [19,] 0 1 1 1 1 0 [20,] 0 1 1 1 0 0 . (&#54400;&#51060;8) for&#47928;&#51012; &#54616;&#45208;&#46020; &#49324;&#50857;&#54616;&#51648; &#50506;&#51008; &#54400;&#51060; . - 매트릭스의 각 row에 어떠한 함수를 반복적으로 적용하는 형태임 $ to$ apply . mat = rbinom(1000*5,size=1,prob=0.8) dim(mat)=c(1000,5) head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] 0 1 1 1 1 [2,] 0 1 0 1 1 [3,] 1 1 0 1 1 [4,] 1 1 1 1 1 [5,] 0 1 1 0 0 [6,] 1 1 0 1 1 . sum(apply(mat,1,test)) . [1] 331 . apply(mat,1,test) %&gt;% sum . [1] 331 . mat %&gt;% apply(1,test) %&gt;% sum . [1] 331 . (&#54400;&#51060;9) . - 바이노미알 이용: 어차피 베르누이의 합은 바이노미알이라고 했음 . sum(rbinom(1000,size=5,p=0.8)==5) . [1] 344 . &#49689;&#51228; . 징검다리 문제 . 강화유리와 유리를 랜덤으로 찍는 참가자가 2명 있다고 하자. (따라서 강화유리를 고를 확률이 50%이다.) . (강화유리, 유리)의 징검다리가 3개 있다고 하자. (따라서 총 6개의 유리가 있고, 3번연속으로 강화유리를 고르면 2명 모두 살아남는다) . 8000번의 시뮬레이션을 하였을 경우 아래의 질문에 답하라. . (질문1) 2명 모두 살아남는 경우는 몇번인가? 약 1000번 . (질문2) 1명만 살아남는 경우는 몇번정도인가? 약 3000번 정도.. . (풀이) . 질문1: 확률이 0.5인 시행을 3번하여 3번 모두 성공하는 경우 . sum(rbinom(8000,size=3,p=0.5)==3) . 1034 질문2: 확률이 0.5인 시행을 3번하여 2번 성공하는 경우 . sum(rbinom(8000,size=3,p=0.5)==2) . 3044",
            "url": "https://guebin.github.io/2021IR/2021/11/23/(11%EC%A3%BC%EC%B0%A8)-11%EC%9B%9423%EC%9D%BC.html",
            "relUrl": "/2021/11/23/(11%EC%A3%BC%EC%B0%A8)-11%EC%9B%9423%EC%9D%BC.html",
            "date": " • Nov 23, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "(11주차) 11월18일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8) 지난시간 숙제풀이 . - (2/8) 정적분의 계산 (1) . - (3/8) 정적분의 계산 (2) . - (4/8) 정적분의 계산 (3) . - (5/8) 균등분포, 베르누이분포, 이항분포의 생성 . - (6/8) 샘플링 (1) . - (7/8) 샘플링 (2) . - (8/8) 숙제설명 . &#51221;&#51201;&#48516;&#51032; &#44228;&#49328; (2007&#45380; 9&#50900; &#54217;&#44032;&#50896;) . (문제) $ int_0^2 |x^2(x-1)| dx $ 의 값은? . (1) $ frac{3}{2}$ . (2) $2$ . (3) $ frac{5}{2}$ . (4) $3$ . (5) $ frac{7}{2}$ . (풀이) . x=seq(from=0, to=2, by=0.01) y=abs(x**2 * (x-1)) . plot(x,y,type=&#39;l&#39;) . - 아이디어: (1) 가로가 2 세로가 4인 작사각형에 임의의 점을 뿌린다. (2) 전체점의 수와 함수 아래에 위치한 점의 갯수를 센다. (3) 점의 갯수를 바탕으로 넓이를 추론한다. . xx=runif(10000) # 0~1 사이의 점을 랜덤으로 10000개 뽑음 . xx = xx*2 # 0~2사이의 값을 랜덤으로 10000개 뽑은것과 같은 효과 . yy=runif(10000)*4 # 0~4 사의의 점을 랜덤으로 10000개 뽑음 . plot(xx,yy) . 가로가 2, 세로가 4인 직사각형에 무작위로 점이 흩뿌려져 있다. . plot(xx,yy) lines(x,y,col=&#39;red&#39;,lwd=3) . 붉은선 아래의 점들이 몇개일까? . test = function(xx,yy){ yy &lt; abs(xx**2 * (xx-1)) } . print(c(xx[1],yy[1])) ## xx[1], yy[1] 의 값 = 무작위로 찍힌 값 print(abs(xx[1]**2 *(xx[1]-1))) ## xx[1]에 해당하는 붉은점의 값 test(xx[1],yy[1]) . [1] 0.830618 2.372124 [1] 0.1168611 . [1] FALSE . plot(xx,yy,col=&#39;gray&#39;) lines(x,y,col=&#39;red&#39;,lwd=3) points(xx[1],yy[1],col=&#39;blue&#39;) points(xx[1],abs(xx[1]**2 * (xx[1]-1)),col=&#39;red&#39;) . tst = c() for (i in 1:10000) tst[i] = test(xx[i],yy[i]) . head(tst) . [1] FALSE FALSE FALSE FALSE FALSE FALSE . plot(xx,yy,col=&#39;gray&#39;) lines(x,y,col=&#39;red&#39;,lwd=3) points(xx[tst],yy[tst],col=&#39;red&#39;) . 붉은점들의 갯수는? tst==TRUE인 점들의 수 . sum(tst) . [1] 1829 . 전체 10000개 중에서 1829개정도가 붉은점임. 따라서 . $$ frac{s}{8} approx frac{1829}{10000}$$ . 이므로 구하는 넓이는 대략적으로 . 1829/10000 * 8 . [1] 1.4632 . 따라서 답은 1번 3/2 이다. . - 이와 같은 방법을 몬테카를로 방법이라고 한다. . - 꽤 복잡한 함수에 대하여서도 정적분의 값을 근사적으로 계산해낼 수 있다는 장점이 있음. . (풀이2) . - 사실 그냥 아래와 같이 풀어도 된다. . sum(yy &lt; abs(xx^2 * (xx-1)) ) . [1] 1829 . &#47004;&#45924;&#48320;&#49688; . &#47004;&#45924;&#48320;&#49688;&#47484; &#49373;&#49457;&#54616;&#45716; &#48169;&#48277; . &#50696;&#51228;1: &#44512;&#46321;&#48516;&#54252; . - 목표: 구간 [0,1]에서 하나의 임의의 값을 뽑는것 (이때 구간 [0,1]에서 각 점이 뽑힐 확률은 동일) . runif(1) . [1] 0.7638336 . - 목표: 구간 [0,1]에서 10개의 값을 뽑고 싶다면? . runif(10) . [1] 0.43916197 0.58808151 0.01061738 0.57311258 0.62008149 0.79359762 [7] 0.43567517 0.06111325 0.66865770 0.98463477 . - 10000개의 값을 뽑아보고 평균이 0.5근처인지 체크해보자. . runif(10000) %&gt;% mean . [1] 0.5001962 . &#50696;&#51228;2: &#44512;&#46321;&#48516;&#54252; . - 목표: 구간 [0,2]에서 하나의 값을 임의로 뽑고 싶다. (이때 구간 [0,2]에서 각 점이 뽑힐 확률은 동일) . - 방법1 . runif(n=1,min=0,max=2) . [1] 0.7713044 . - 방법2 . runif(1)*2 . [1] 1.197119 . 왜 방법2처럼 해도되는가? $X sim U(0,1)$ 이면 $2X sim U(0,2)$ 이므로 | 이론적인 내용은 수리통계학에서 배울것임 | . - 10000개의 값을 뽑아보고 평균이 1인지 살펴보자. . runif(n=10000,min=0,max=2) %&gt;% mean . [1] 0.9979827 . (runif(10000)*2) %&gt;% mean . [1] 0.9942539 . &#50696;&#51228;3: &#48288;&#47476;&#45572;&#51060;&#48516;&#54252; ($n=1$&#51064; &#51060;&#54637;&#48516;&#54252;) . - 목표: 동전을 한번 던져서 앞면이 나오는 경우를 생성하고 싶음 (이때 동전은 공평한 동전이라 가정하자. 즉 앞면이 나올 횟수와 뒷면이 나올 횟수는 같다고 하자.) . rbinom(1,size=1,prob=0.5) . [1] 0 . 앞면이 1, 뒷면이 0이라고 생각 | . - 잘 되는것이 맞는지 한번 체크해보자. (10000개 정도의 동전을 던져서 결과를 저장하고 평균이 0.5인지 체크하자) . rbinom(10000,size=1,prob=0.5) %&gt;% mean . [1] 0.5022 . - 동전이 공평하지 않다고 하자. 예를들어 앞면이 나올 확률이 0.8이라고 생각하자. . rbinom(10000,size=1,prob=0.8) %&gt;% mean . [1] 0.8083 . &#50696;&#51228;4: &#51060;&#54637;&#48516;&#54252; . - 목표: 동전을 10회던져 앞면이 나올 총 횟수를 생성하자. . 동전을 10회던져 앞면이 나온 횟수를 $X$라고 하자. $X$를 생성하라. | . rbinom(1,size=10,prob=0.5) . [1] 3 . - 평균적으로 5가 나와야 한다. (10000번 정도 뽑아보고 관찰하자) . rbinom(10000,size=10,prob=0.5) %&gt;% mean . [1] 5.0029 . - 베르누이 분포는 이항분포의 특수한 경우이다. . - 직관적으로 생각하면 아래와 같이 이항분포를 생성해도 될 것 같다. . rbinom(10,size=1,prob=0.5) %&gt;% sum . [1] 4 . X=c() for (i in 1:10000) X[i] = rbinom(10,size=1,prob=0.5) %&gt;% sum . X . [1] 6 5 7 2 2 5 4 5 5 2 3 5 5 4 5 5 4 6 5 5 3 3 5 3 [25] 5 3 9 4 8 3 3 5 5 3 6 4 7 4 7 6 6 4 5 5 7 3 5 2 [49] 6 5 5 5 4 6 8 5 2 4 4 6 6 4 7 5 4 1 4 5 7 7 4 5 [73] 4 5 4 7 4 4 3 4 6 6 5 4 6 5 5 5 6 4 5 6 4 4 8 6 [97] 5 5 3 8 4 4 5 2 4 3 2 3 5 4 5 7 4 4 9 5 4 5 5 5 [121] 7 4 6 6 6 5 3 5 7 6 7 4 3 6 4 3 4 6 5 6 6 5 6 9 [145] 4 6 10 2 6 3 7 3 6 2 2 5 6 6 5 3 3 5 5 7 5 5 5 5 [169] 6 3 5 6 3 6 3 6 4 6 5 5 4 5 6 3 5 6 3 5 6 6 4 7 [193] 5 4 3 8 5 5 5 4 7 5 5 5 5 4 6 6 5 4 3 10 5 4 5 4 [217] 4 5 4 9 4 5 3 4 4 3 5 3 4 4 5 7 3 4 6 5 8 5 4 3 [241] 5 4 4 6 7 5 7 5 4 8 3 6 5 5 3 5 5 3 2 5 5 4 6 6 [265] 6 4 6 5 3 3 6 6 5 5 4 5 5 4 7 6 5 4 3 4 4 4 5 5 [289] 3 6 6 3 6 4 6 7 4 6 3 4 5 3 5 3 5 7 4 2 6 4 5 4 [313] 5 7 8 1 7 4 5 8 5 3 6 6 6 7 5 8 4 6 6 6 4 6 3 6 [337] 5 4 5 6 8 7 3 5 6 6 5 5 4 3 8 4 6 4 3 2 5 8 5 6 [361] 2 4 5 5 5 5 6 5 4 5 4 4 2 6 5 7 3 3 6 6 9 6 4 6 [385] 4 5 8 4 7 5 6 5 5 8 6 4 5 3 6 6 5 7 6 8 3 3 6 7 [409] 8 5 5 5 6 6 5 4 6 3 4 4 5 5 6 6 5 5 8 4 5 6 2 4 [433] 3 1 4 6 7 5 3 5 9 8 5 6 2 4 5 5 6 6 5 5 7 6 6 4 [457] 7 4 4 7 7 2 3 7 3 7 4 5 6 4 4 4 5 7 2 4 8 7 6 6 [481] 5 4 4 6 5 5 3 7 2 3 8 4 4 3 5 3 6 4 6 6 5 4 4 7 [505] 3 6 3 5 2 3 4 5 6 4 3 4 7 5 7 6 4 6 7 2 6 8 5 2 [529] 7 5 3 8 7 6 5 3 6 5 7 2 6 3 5 5 3 4 6 2 2 4 6 3 [553] 5 6 8 4 4 7 5 6 2 8 7 5 6 5 1 7 7 2 5 4 5 7 4 6 [577] 7 3 6 7 6 4 4 7 5 5 5 5 4 1 5 5 5 5 6 1 5 2 3 2 [601] 3 5 6 0 5 4 3 5 6 2 5 3 5 6 6 6 2 4 4 4 3 5 7 5 [625] 4 6 4 9 4 7 4 5 7 8 6 5 5 6 7 3 4 4 4 5 6 5 6 3 [649] 6 7 5 5 3 4 5 3 4 6 3 4 3 7 3 5 6 6 5 6 6 3 3 5 [673] 6 4 2 6 6 6 6 4 5 5 5 3 7 4 6 3 4 6 6 7 3 1 8 1 [697] 7 6 8 7 4 7 3 3 3 4 3 8 4 4 6 3 6 2 2 5 3 5 8 6 [721] 2 6 5 7 6 5 7 4 7 6 3 5 4 4 6 7 5 6 4 5 4 4 6 5 [745] 4 7 6 5 6 7 5 7 2 5 2 5 3 6 5 7 7 6 4 3 2 1 9 6 [769] 5 6 4 8 6 5 4 5 5 3 5 3 5 6 8 5 5 6 2 5 3 5 3 4 [793] 4 5 5 4 4 6 4 4 4 5 5 5 6 7 5 3 7 6 5 7 7 5 6 7 [817] 3 6 4 3 6 5 6 3 7 5 6 6 6 6 4 7 6 5 3 3 6 5 3 5 [841] 5 6 5 4 6 6 5 6 5 4 5 6 3 4 5 5 4 8 3 6 4 5 6 8 [865] 5 6 9 5 7 7 4 4 6 7 4 5 6 4 4 5 6 6 4 5 2 5 6 3 [889] 5 5 5 5 3 5 5 7 3 6 6 7 5 2 5 5 8 4 3 4 6 6 3 5 [913] 7 7 5 6 5 6 4 3 7 4 9 9 7 4 3 6 4 3 4 3 5 6 5 4 [937] 5 5 4 4 2 3 4 7 6 6 4 5 5 7 5 8 6 8 5 5 6 6 4 6 [961] 6 2 5 8 8 5 7 6 6 7 7 8 3 5 3 4 6 6 6 5 7 3 6 4 [985] 1 5 5 2 4 7 4 8 5 6 3 5 4 6 6 5 [ reached getOption(&#34;max.print&#34;) -- omitted 9000 entries ] . 직관적으로 생각하면 X는 rbinom(10000,size=10,prob=0.5) 와 같은 효과 (랜덤성 때문에 같은 값은 아님) 일 것 같은데 이는 실제로 그러하다. (좀 더 엄밀한 증명은 수리통계 시간에 배운다) | . X %&gt;% mean() . [1] 5.0216 . &#50612;&#46496;&#54620; &#51665;&#54633;&#50640;&#49436; &#49368;&#54540;&#47553; . &#50696;&#51228;5: &#48708;&#48373;&#50896;&#52628;&#52636; . - 주머니에서 빨간공 2개와 파란공 3개가 있다고 하자. . set = c(rep(&quot;red&quot;,2),rep(&quot;blue&quot;,3)) set . [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; . - 이러한 집합에서 랜덤으로 3개의 원소를 고르고 싶다면? (단, 뽑은 공은 다시 넣지 않는다) . sample(set,size=3) . [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; . - 50번정도 해보자. . for (i in 1:50) sample(set,size=3) %&gt;% print . [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; . 빨간공을 3번 뽑지는 못함 | . &#50696;&#51228;6: &#48373;&#50896;&#52628;&#52636; . - 뽑은공을 다시 넣는다고 가정한다면? . set = c(rep(&quot;red&quot;,2),rep(&quot;blue&quot;,3)) set . [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; . for (i in 1:50) sample(set, size=3,replace = TRUE) %&gt;% print . [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; . 빨간공을 3번 뽑을 수 있음 | . (&#51064;&#45937;&#49828;,&#54869;&#47456;) &#51221;&#48372;&#44032; &#51452;&#50612;&#51276;&#51012; &#44221;&#50864; &#49368;&#54540;&#47553; . &#50696;&#51228;7: &#50696;&#51228;6&#51032; &#45796;&#47480;&#44396;&#54788; . - 예제6의 코드는 아래와 같다. . set = c(&#39;red&#39;,&#39;blue&#39;) ## 인덱스.. p = c(0.4,0.6) ## 인덱스에 해당하는 확률 . sample(set,size=3, prob=p, replace = T) . [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; . - 아래와 같은 코드로도 응용가능하다. . sample(set,size=20,prob=c(0.95,0.05),replace=T) . [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; [11] &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; . &#51204;&#52404;&#51665;&#54633;&#50640;&#49436; &#49436;&#47196; &#45796;&#47480; &#54869;&#47456;&#47196; &#50896;&#49548;&#44032; &#48977;&#55176;&#45716; &#44221;&#50864; . &#50696;&#51228;8 . - 예제7의 코드에서 replace를 제외한다면? . set = c(&#39;red&#39;,&#39;blue&#39;) ## 인덱스.. . sample(set,size=20,prob=c(0.95,0.05)) . Error in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when &#39;replace = FALSE&#39; Traceback: 1. sample(set, size = 20, prob = c(0.95, 0.05)) 2. sample.int(length(x), size, replace, prob) . 당연히 에러가남 (원소가 2개 있는 set에서 20개를 뽑으라고 하니..) | . - 아래는 에러가 나지 않을 것임 . sample(set,size=2,prob=c(0.95,0.05)) . [1] &#34;red&#34; &#34;blue&#34; . - 의미는? . rslt = matrix(rep(&quot;-&quot;,1000*2),ncol=2) head(rslt) . [,1] [,2] [1,] - - [2,] - - [3,] - - [4,] - - [5,] - - [6,] - - . for (i in 1:1000) rslt[i,] = sample(set,size=2,prob=c(0.95,0.05)) . head(rslt) . [,1] [,2] [1,] red blue [2,] red blue [3,] red blue [4,] red blue [5,] red blue [6,] red blue . sum(rslt[,1]==&#39;red&#39;)/1000 . [1] 0.947 . 대략 95% | . - 첫번째가 붉은 공이 뽑힐 확률은 95%임. 그리고 두번째 공은 첫번째 공과 다른색이 뽑힘 . &#49689;&#51228;: &#51669;&#44160;&#45796;&#47532; &#44148;&#45320;&#44592; . (유리,강화유리)의 쌍으로 이루어진 징검다리가 총 5개 있다고 하자. (따라서 징검다리는 모두 10개이다) . 강화유리로 된 징검다리를 밟으면 살아남지만 유리로 된 징검다리를 밟으면 죽는다. . 따라서 강화유리로 된 징검다리를 계속 골라야 살아남을 수 있다. . A씨는 유리공장에서 20년 근무한 장인으로 유리와 강화유리를 구분할수 있는 능력을 가졌다고 하자. . 그래서 강화유리로 된 징검다리를 고를 확률이 80%라고 하자. . A씨가 살아남을 확률을 시뮬레이션을 통하여 구하여라. . Hint: 총 1000번의 시뮬레이션을 수행하고 그중에서 A씨가 살아남는 케이스가 몇회정도 되는지 찾아라. .",
            "url": "https://guebin.github.io/2021IR/2021/11/18/(11%EC%A3%BC%EC%B0%A8)-11%EC%9B%9418%EC%9D%BC.html",
            "relUrl": "/2021/11/18/(11%EC%A3%BC%EC%B0%A8)-11%EC%9B%9418%EC%9D%BC.html",
            "date": " • Nov 18, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "(10주차) 11월16일",
            "content": "options(jupyter.rich_display=FALSE) . &#44053;&#51032;&#50689;&#49345; . . - (1/5) 리스트 (1) . - (2/5) 리스트 (2) . - (3/5) 리스트 (3) . - (4/5) 리스트 (4) . - (5/5) 리스트 (5) . R&#46020;&#49436; &#52280;&#44256;&#51088;&#47308; . - https://rc2e.com/ . - https://adv-r.hadley.nz/ . - https://r4ds.had.co.nz/ . &#44592;&#47568;&#44256;&#49324; . - 중간고사와 비슷하게 낼 예정. 범위도 거의 비슷. . - 중간고사때 까지의 내용만 극한으로 단련해도 어느정도는 풀 수 있을 거에요. . - 코드를 좀 더 예쁘게 효율적으로 만들기 위한 다양한 문법 및 기능이 필요한데 중간~기말 이후에는 그것을 채우는 과정 . - 수업목표: . 문제상황 (어떠한 것을 계산해야 하는 일이 생길때) 알고리즘을 머리속에 떠올릴 수 있다. | 머리속에 떠올린 알고리즘을 기본적인 제어문과 반복문을 통하여 구현할 수 있다. (이미 한 내용, 그런데 지금부터는 좀 더 예쁘고 효율적으로 구현하는 방법을 설명하겠습니다) | . &#47532;&#49828;&#53944; . - 이상한 자료형 . - 제가 굉장히 많이 사용하는 자료형태.. 그런데 왜 쓰는지 이유를 물어보면 딱히 잘 모르겠어요 . &#50696;&#51228;1 . - 리스트를 선언하는 방법 . lst = list(5:10,c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;),matrix(c(T,T,F,T),ncol=2)) . lst . [[1]] [1] 5 6 7 8 9 10 [[2]] [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; [[3]] [,1] [,2] [1,] TRUE FALSE [2,] TRUE TRUE . 리스트의 첫번째 원소 = 숫자로 이루어진 벡터 | 리스트의 두번째 원소 = 문자로 이루어진 벡터 | 리스트의 세번째 원소 = True / False로 이루어진 매트릭스 | . - 리스트의 각 원소를 추출하는 방법 . lst[[1]] . [1] 5 6 7 8 9 10 . lst[[2]] . [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; . lst[[3]] . [,1] [,2] [1,] TRUE FALSE [2,] TRUE TRUE . lst[[1]]+3 . [1] 8 9 10 11 12 13 . - 리스트의 길이 . length(lst) . [1] 3 . - 왜 리스트를 쓰는가? (1) 함수에서 여러개의 리턴값을 주는 효과 (2) 정리의 효과 . 명확한 이점: 함수의 리턴값을 여러개 | 그외의 이점: 저도 솔직히 잘 모르겠어요. | 벡터, 매트릭스, 데이터프레임와 같이 기능상의 이점이 있는것 같진 않아요. | 그런데 자료를 저장하고 정리하기에 좋아요 (제가 정리하는걸 좋아하는것 같아요) | . &#50696;&#51228;2 . mid = list(c(&#39;hynn&#39;,&#39;iu&#39;,&#39;gd&#39;),c(100,95,100)) mid . [[1]] [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; [[2]] [1] 100 95 100 . names(mid) . NULL . names(mid)&lt;-c(&#39;names&#39;,&#39;score&#39;) . mid . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $score [1] 100 95 100 . - 보기에 깔끔하다. . - 데이터에 접근하기도 좋다. . mid$names . [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . mid$score . [1] 100 95 100 . - 물론 아래와 같이 접근할수도 있다. . mid[[1]] . [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . mid[[2]] . [1] 100 95 100 . - 리스트를 복사후 재생성하기에 좋음 . mid . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $score [1] 100 95 100 . final = mid . final . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $score [1] 100 95 100 . final$score = mid$score - 10 . final$score . [1] 90 85 90 . final . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $score [1] 90 85 90 . - 리스트를 묶어서 새로운 리스트를 또 만들 수도 있음 . IR2021 &lt;- list(mid,final) . IR2021 . [[1]] [[1]]$names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; [[1]]$score [1] 100 95 100 [[2]] [[2]]$names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; [[2]]$score [1] 90 85 90 . - 리스트원소에 이름을 붙여주면 . names(IR2021) . NULL . names(IR2021) &lt;- c(&quot;mid&quot;,&quot;final&quot;) . IR2021 . $mid $mid$names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $mid$score [1] 100 95 100 $final $final$names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $final$score [1] 90 85 90 . IR2021$final$score . [1] 90 85 90 . - 아래와 같이 선언하는 것도 깔끔해보인다. . IR2021 = list(names=mid$names, mid=mid$score, final=final$score) # 리스트의 구성요소와 이름을 동시에 선언 IR2021 . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $mid [1] 100 95 100 $final [1] 90 85 90 . &#47532;&#49828;&#53944;&#51032; &#49436;&#48652;&#49483;&#54021; . IR2021 . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $mid [1] 100 95 100 $final [1] 90 85 90 . [&#50672;&#49328;&#51088;: &#47532;&#49828;&#53944;&#47484; &#47532;&#53556; . IR2021[1] . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . IR2021[1:2] . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $mid [1] 100 95 100 . IR2021[c(1,3)] . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $final [1] 90 85 90 . IR2021[-2] . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $final [1] 90 85 90 . [[ &#50672;&#49328;&#51088;: &#47532;&#49828;&#53944;&#51032; &#50836;&#49548;&#47484; &#52628;&#52636;&#54632; . IR2021[[1]] . [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . IR2021[[2]] . [1] 100 95 100 . - 아래는 동작하지 않음 . IR2021[[-1]] . Error in IR2021[[-1]]: invalid negative subscript in get1index &lt;real&gt; Traceback: . - 아래는 의도와 다르게 동작함 . IR2021[[1:2]] . [1] &#34;iu&#34; . IR2021[[c(1,2)]] . [1] &#34;iu&#34; . IR2021[[1]][2]와 결과가 같음 | . IR2021[[1:3]] . Error in IR2021[[1:3]]: recursive indexing failed at level 2 Traceback: . IR2021[[c(1,3)]] #IR2021[[1]][3] . [1] &#34;gd&#34; . $&#50672;&#49328;&#51088; . IR2021$names . [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . [[&#39;names&#39;]]&#50752; &#44057;&#51008; &#49324;&#50857;&#46020; &#44032;&#45733; . IR2021[[&#39;names&#39;]] . [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . - 언뜻 생각하면 IR2021$names 와 IR2021[[&#39;names&#39;]] 의 기능은 같으므로 이 경우에는 $와 [[를 서로 바꿔도 될것 같다. 하지만 항상 그런 것은 아니다. . IR2021$n . [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . IR2021[[&#39;n&#39;]] . NULL . - 즉 $연산자와 [[연산자의 차이는 파샬매칭(partial matching)을 허용하느냐 하지않느냐의 차이다. . IR2021$n . [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . IR2021$na . [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . IR2021$name . [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . 특히 마지막 IR2021$name은 마치 오타를 허용해주는 느낌이다. | . - 그런데 아래는 동작하지 않음 . IR2021$ames . NULL . IR2021$es . NULL . &#47532;&#49828;&#53944;&#51032; &#51025;&#50857;: &#54632;&#49688;&#51032; return&#51004;&#47196; &#49324;&#50857; . - R에서는 일반적으로 하나의 오브젝트만 리턴함 . - 하지만 리스트를 사용하면 다중리턴을 지원하는 것처럼 느낄 수 있음. . cal= function(x,y){ return(list(add=x+y, sub=x-y, mul=x*y, dic=x/y)) } . cal(2,3) . $add [1] 5 $sub [1] -1 $mul [1] 6 $dic [1] 0.6666667 . - 이런일이 있으면 그냥 cal_add, cal_mul, cal_sub, cal_div 처럼 함수를 4개 구현하면 되는것이 아닌가? $ to$ 물론 그래도 가능하지만 코드가 지저분해 지니까 . - 함수의 결과값을 저장하여 아래와 같이 사용 . rslt = cal(4,3) . rslt$add . [1] 7 . rslt$sub . [1] 1 . - 아래와 같이 쓰지는 않음 . cal(4,3)$add . [1] 7 . cal(4,3)$sub . [1] 1 . &#49689;&#51228; . - 기본적인 자료형 vector, matrix, list에 기능을 스스로 정리해보고 요약해볼것 (제출의무 없음) . 벡터의 길이를 재려면 어떻게 해야하는지? | 매트릭스의 차원은 어떻게 알 수 있는지? | 리스트의 원소에 접근하려면? | $n times 1$ 매트릭스 혹은 $1 times n$ 매트릭스를 쓰면 되는데 왜 굳이 벡터를 만들었을까? | . - 벡터 ${ bf x}$와 벡터 ${ bf y}$를 아래의 코드를 이용해 표준 정규분포에서 생성하라. (표준정규분포를 모른다면 질문하거나 네이버 구글에서 스스로 찾아볼것) . x=rnorm(100) y=rnorm(100) . 아래의 수식을 계산하는 코드를 작성하라. . $$ frac{ sum_{i=1}^{100}(x_i- bar{x})(y_i- bar{y})}{ sqrt{ sum_{i=1}^{100}(x_i- bar{x})^2} sqrt{ sum_{i=1}^{100}(y_i- bar{y})^2}}$$ . 단 $ bar{x}= frac{1}{100} sum_{i=1}^{100}x_i$로 정의한다. . x=rnorm(100) y=rnorm(100) . . 보충학습 . x . [1] -1.34195186 -0.85612995 -1.09994510 -0.52712671 -0.96108745 0.43294735 [7] -0.13052246 -1.65458005 1.55086554 0.88036601 -1.62934144 0.09050529 [13] -0.31266135 0.06725000 0.74022593 -0.09217845 0.94826123 -0.37638526 [19] 1.05201467 0.63982774 -0.16251479 0.60216102 -0.36023578 2.25220656 [25] -0.99538800 -0.76112568 0.90719870 -0.16530389 -0.63598707 -1.56638152 [31] -0.38664357 1.38393375 -1.36055810 0.17380230 0.83021234 0.44171935 [37] 0.96312932 1.15326736 -1.47873860 -1.24613250 -3.26079697 0.59937020 [43] 1.73490956 -0.29685605 0.38467151 -0.68211471 -0.90435763 1.38694961 [49] -0.91639458 -1.04633026 -0.82508397 0.92621767 0.90406879 -0.35989507 [55] -0.77384072 0.46544269 -0.41319154 -0.25227959 -0.55143134 -1.00881100 [61] -0.63920795 0.86356587 -2.00842150 -2.80548750 1.27538116 0.17846435 [67] -0.11627651 -1.95479833 -0.47060548 -2.13113365 1.27101358 -2.11915432 [73] -1.33631120 -0.03854028 -0.01754093 -0.29509103 -0.08825048 1.38765285 [79] 0.02008001 1.49634505 -0.64889609 1.09336952 0.17255440 -0.40512134 [85] 0.89159556 0.68433663 0.33741577 0.44028690 -0.64519602 0.97174893 [91] 1.37073087 -0.35971925 0.34607400 1.03844970 -0.76692713 0.11986849 [97] 1.06544295 -0.73896215 -1.83669247 -0.87349548 . ${ bf x} = (x_1,x_2, dots, x_{100})=(-1.34195186 ,-0.85612995, dots, -0.87349548)$ . $ frac{1}{100} sum_{i=1}^{100} x_i = frac{1}{100}(x_1+x_2+ dots +x_{100})= frac{1}{100}(-1.34195186 + (-0.85612995) + dots (-0.87349548))$ . 코드상으로는 아래와 같이 계산할 수 있겠음 . sum(x)/100 # xbar . [1] -0.1315223 . mean(x) . [1] -0.1315223 . . (풀이) . $$ frac{ sum_{i=1}^{100}(x_i- bar{x})(y_i- bar{y})}{ sqrt{ sum_{i=1}^{100}(x_i- bar{x})^2} sqrt{ sum_{i=1}^{100}(y_i- bar{y})^2}}= frac{A}{BC}$$ . A=0 for (i in 1:100) A=A+(x[i]-mean(x))*(y[i]-mean(y)) A . [1] 8.642164 . B=0 for (i in 1:100) B=B+(x[i]-mean(x))**2 B=sqrt(B) B . [1] 10.53507 . C=0 for (i in 1:100) C=C+(y[i]-mean(y))**2 C=sqrt(C) C . [1] 10.54876 . A/(B*C) . [1] 0.07776485 . (다른풀이) . sum((x-mean(x))*(y-mean(y))) / (sqrt(sum((x-mean(x))**2)) * sqrt(sum((y-mean(y))**2))) . [1] 0.07776485 . (다른풀이2) . 벡터의 내적: ${ bf x}=(x_1, dots,x_{100})$ 라고 하고, ${ bf y}=(y_1, dots,y_{100})$ 라고 할때 두 벡터의 내적은 아래와 같이 계산한다. . $${ bf x} cdot { bf y} = x_1 y_1 + dots + x_{100}y_{100}$$ . x_ &lt;- c(1,2,3) y_ &lt;- c(2,3,4) . x_ %*% y_ . [,1] [1,] 20 . 1*2+ 2*3+ 3*4 . [1] 20 . 이러한 성질을 이용하면 . xx= x-mean(x) yy= y-mean(y) . ((xx %*% yy) / (sqrt(xx %*% xx )* sqrt(yy %*% yy ))) . [,1] [1,] 0.07776485 .",
            "url": "https://guebin.github.io/2021IR/2021/11/16/(10%EC%A3%BC%EC%B0%A8)-11%EC%9B%9416%EC%9D%BC.html",
            "relUrl": "/2021/11/16/(10%EC%A3%BC%EC%B0%A8)-11%EC%9B%9416%EC%9D%BC.html",
            "date": " • Nov 16, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "2021년 2학기 R입문 중간고사 풀이",
            "content": "1. R&#51012; &#51060;&#50857;&#54616;&#50668; &#45796;&#51020;&#51012; &#44228;&#49328;&#54616;&#50668;&#46972;. (3&#51216;) . (a) $2^{-5}+2^{3}$ . (b) $ sqrt{33}$ . (c) $ sum_{k=1}^{100} frac{1}{k^2+2k+1}= sum_{k=1}^{100}(k+1)^{-2}$ . (풀이) . - (c)만 풀겠습니다. . - 방법1: for문을 이용 . ak &lt;-c() for (k in 1:100) ak[k] &lt;- 1/(k**2 + 2*k + 1) sum(ak) . [1] 0.6350819 . - 방법2: 벡터의 연산을 이용한다. . k=1:100 sum(1/(k**2 + 2*k + 1) ) . [1] 0.6350819 . - 수학을 좋아하는 사람? . k=1:100 sum((k+1)^(-2)) . [1] 0.6350819 . - 제 생각에는 방법2가 좋은것 같아요. (계산효율면에서 좋고 디버깅이 편해요) . 1:100 . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 [91] 91 92 93 94 95 96 97 98 99 100 . (1:100)**2 . [1] 1 4 9 16 25 36 49 64 81 100 121 144 [13] 169 196 225 256 289 324 361 400 441 484 529 576 [25] 625 676 729 784 841 900 961 1024 1089 1156 1225 1296 [37] 1369 1444 1521 1600 1681 1764 1849 1936 2025 2116 2209 2304 [49] 2401 2500 2601 2704 2809 2916 3025 3136 3249 3364 3481 3600 [61] 3721 3844 3969 4096 4225 4356 4489 4624 4761 4900 5041 5184 [73] 5329 5476 5625 5776 5929 6084 6241 6400 6561 6724 6889 7056 [85] 7225 7396 7569 7744 7921 8100 8281 8464 8649 8836 9025 9216 [97] 9409 9604 9801 10000 . (1:100)**2 + 2*(1:100) . [1] 3 8 15 24 35 48 63 80 99 120 143 168 [13] 195 224 255 288 323 360 399 440 483 528 575 624 [25] 675 728 783 840 899 960 1023 1088 1155 1224 1295 1368 [37] 1443 1520 1599 1680 1763 1848 1935 2024 2115 2208 2303 2400 [49] 2499 2600 2703 2808 2915 3024 3135 3248 3363 3480 3599 3720 [61] 3843 3968 4095 4224 4355 4488 4623 4760 4899 5040 5183 5328 [73] 5475 5624 5775 5928 6083 6240 6399 6560 6723 6888 7055 7224 [85] 7395 7568 7743 7920 8099 8280 8463 8648 8835 9024 9215 9408 [97] 9603 9800 9999 10200 . (1:100)**2 + 2*(1:100) +1 . [1] 4 9 16 25 36 49 64 81 100 121 144 169 [13] 196 225 256 289 324 361 400 441 484 529 576 625 [25] 676 729 784 841 900 961 1024 1089 1156 1225 1296 1369 [37] 1444 1521 1600 1681 1764 1849 1936 2025 2116 2209 2304 2401 [49] 2500 2601 2704 2809 2916 3025 3136 3249 3364 3481 3600 3721 [61] 3844 3969 4096 4225 4356 4489 4624 4761 4900 5041 5184 5329 [73] 5476 5625 5776 5929 6084 6241 6400 6561 6724 6889 7056 7225 [85] 7396 7569 7744 7921 8100 8281 8464 8649 8836 9025 9216 9409 [97] 9604 9801 10000 10201 . 1 / ((1:100)**2 + 2*(1:100) +1) . [1] 0.2500000000 0.1111111111 0.0625000000 0.0400000000 0.0277777778 [6] 0.0204081633 0.0156250000 0.0123456790 0.0100000000 0.0082644628 [11] 0.0069444444 0.0059171598 0.0051020408 0.0044444444 0.0039062500 [16] 0.0034602076 0.0030864198 0.0027700831 0.0025000000 0.0022675737 [21] 0.0020661157 0.0018903592 0.0017361111 0.0016000000 0.0014792899 [26] 0.0013717421 0.0012755102 0.0011890606 0.0011111111 0.0010405827 [31] 0.0009765625 0.0009182736 0.0008650519 0.0008163265 0.0007716049 [36] 0.0007304602 0.0006925208 0.0006574622 0.0006250000 0.0005948840 [41] 0.0005668934 0.0005408329 0.0005165289 0.0004938272 0.0004725898 [46] 0.0004526935 0.0004340278 0.0004164931 0.0004000000 0.0003844675 [51] 0.0003698225 0.0003559986 0.0003429355 0.0003305785 0.0003188776 [56] 0.0003077870 0.0002972652 0.0002872738 0.0002777778 0.0002687450 [61] 0.0002601457 0.0002519526 0.0002441406 0.0002366864 0.0002295684 [66] 0.0002227668 0.0002162630 0.0002100399 0.0002040816 0.0001983733 [71] 0.0001929012 0.0001876525 0.0001826150 0.0001777778 0.0001731302 [76] 0.0001686625 0.0001643655 0.0001602307 0.0001562500 0.0001524158 [81] 0.0001487210 0.0001451589 0.0001417234 0.0001384083 0.0001352082 [86] 0.0001321178 0.0001291322 0.0001262467 0.0001234568 0.0001207584 [91] 0.0001181474 0.0001156203 0.0001131734 0.0001108033 0.0001085069 [96] 0.0001062812 0.0001041233 0.0001020304 0.0001000000 0.0000980296 . sum(1 / ((1:100)**2 + 2*(1:100) +1)) . [1] 0.6350819 . 2. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (2&#51216;) . (a) &#50500;&#47000;&#50752; &#44057;&#51008; &#49688;&#50676;&#51012; &#49373;&#49457;&#54616;&#46972;. . $$x=(-10,-9.5,-9.0,...,9.0,9.5,10)$$ . (b) &#49373;&#49457;&#46108; &#49688;&#50676;&#50640; &#45824;&#54616;&#50668; &#50500;&#47000;&#47484; &#47564;&#51313;&#54616;&#45716; $y$&#47484; &#44228;&#49328;&#54616;&#46972;. . $$y= begin{cases} x &amp; |x|&gt;5 0 &amp; |x| leq 2 5 &amp; o.w. end{cases}$$ (풀이) . - 그냥 예제문제 . seq(-10,10,0.5) . [1] -10.0 -9.5 -9.0 -8.5 -8.0 -7.5 -7.0 -6.5 -6.0 -5.5 -5.0 -4.5 [13] -4.0 -3.5 -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 [25] 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 [37] 8.0 8.5 9.0 9.5 10.0 . x=seq(-10,10,0.5) . ifelse(abs(x)&gt;5,x, ifelse(abs(x)&lt;=2,0,5)) . [1] -10.0 -9.5 -9.0 -8.5 -8.0 -7.5 -7.0 -6.5 -6.0 -5.5 5.0 5.0 [13] 5.0 5.0 5.0 5.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [25] 0.0 5.0 5.0 5.0 5.0 5.0 5.0 5.5 6.0 6.5 7.0 7.5 [37] 8.0 8.5 9.0 9.5 10.0 . - 검산 . cbind(x,ifelse(abs(x)&gt;5,x, ifelse(abs(x)&lt;=2,0,5))) . x [1,] -10.0 -10.0 [2,] -9.5 -9.5 [3,] -9.0 -9.0 [4,] -8.5 -8.5 [5,] -8.0 -8.0 [6,] -7.5 -7.5 [7,] -7.0 -7.0 [8,] -6.5 -6.5 [9,] -6.0 -6.0 [10,] -5.5 -5.5 [11,] -5.0 5.0 [12,] -4.5 5.0 [13,] -4.0 5.0 [14,] -3.5 5.0 [15,] -3.0 5.0 [16,] -2.5 5.0 [17,] -2.0 0.0 [18,] -1.5 0.0 [19,] -1.0 0.0 [20,] -0.5 0.0 [21,] 0.0 0.0 [22,] 0.5 0.0 [23,] 1.0 0.0 [24,] 1.5 0.0 [25,] 2.0 0.0 [26,] 2.5 5.0 [27,] 3.0 5.0 [28,] 3.5 5.0 [29,] 4.0 5.0 [30,] 4.5 5.0 [31,] 5.0 5.0 [32,] 5.5 5.5 [33,] 6.0 6.0 [34,] 6.5 6.5 [35,] 7.0 7.0 [36,] 7.5 7.5 [37,] 8.0 8.0 [38,] 8.5 8.5 [39,] 9.0 9.0 [40,] 9.5 9.5 [41,] 10.0 10.0 . 3. $x=(-10,-9,-8, dots,8,9,10)$&#51032; &#44033; &#50896;&#49548;&#50640; &#45824;&#54616;&#50668; $h(g(f(x)))$&#51032; &#44228;&#49328;&#44208;&#44284;&#47484; &#44396;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. (10&#51216;) . 단, $f(x)$,$g(x)$, $h(x)$의 정의는 각각 아래와 같다. . $f(x)=2x+3 $ | $g(x)= frac{e^x}{1+e^x}$ | $h(x)=max(x,0)$ | . (풀이) . - 문제 의도가 좀 왜곡되었어요.. $x=(-10,-9,-8, dots, 8,9,10)$의 각 원소에 대하여! 로 바꿔야합니다. . library(tidyverse) . f = function(x) 2*x +3 g = function(x) exp(x) / (1+exp(x)) h = function(x) max(x,0) -10:10 %&gt;% f %&gt;% g %&gt;% h . [1] 1 . - 원래 의도는 이거였습니다. . f = function(x) 2*x +3 g = function(x) exp(x) / (1+exp(x)) h = function(x) ifelse(y&gt;0,y,0) -10:10 %&gt;% f %&gt;% g %&gt;% h . [1] 4.139938e-08 3.059022e-07 2.260324e-06 1.670142e-05 1.233946e-04 [6] 9.110512e-04 6.692851e-03 4.742587e-02 2.689414e-01 7.310586e-01 [11] 9.525741e-01 9.933071e-01 9.990889e-01 9.998766e-01 9.999833e-01 [16] 9.999977e-01 9.999997e-01 1.000000e+00 1.000000e+00 1.000000e+00 [21] 1.000000e+00 . 4. &#50500;&#47000;&#51473; &#50739;&#51008;&#44163;&#51008;? (O / X &#47196; &#45813;&#50504;&#51648;&#47484; &#50416;&#44256; &#45813;&#51032; &#44540;&#44144;&#44032; &#46104;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54624;&#44163;) (10&#51216;) . (a) $1= frac{1}{2}+ frac{1}{4} + frac{1}{8} dots $ . (b) $e^x= 1+x+x^2+x^3+ dots $ . (풀이) . sum=0 for (i in 1:10){ sum=sum+(1/2)**i print(sum) } . [1] 0.5 [1] 0.75 [1] 0.875 [1] 0.9375 [1] 0.96875 [1] 0.984375 [1] 0.9921875 [1] 0.9960938 [1] 0.9980469 [1] 0.9990234 . 1에 점점 가까워짐 | . 5. &#45796;&#51020;&#51012; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (10&#51216;) . 다음은 어느 회사의 연봉에 대한 규정이다. . (가) 입사 첫째 해 연봉은 $a$원이고, 입사 19년째 해까지의 연봉은 해마다 직전 연봉에서 8%씩 인상된다. . (나) 입사 20년째 해부터의 연봉은 입사 19년째 해 연봉의 75%로 한다. . 이 회사에 입사한 사람이 28년동안 근무하여 받는 연봉의 총합은? . 6. &#45796;&#51020; &#47928;&#51109;&#51012; &#51069;&#44256; &#52280;&#44144;&#51667;&#51012; &#54032;&#45800;&#54616;&#49884;&#50724;. (10&#51216;) . (a) _a&#45716; &#48320;&#49688;&#51060;&#47492;&#51004;&#47196; &#44032;&#45733;&#54616;&#45796;. . (b) &#48289;&#53552;&#51032; &#50896;&#49548;&#45716; &#49688;&#52824;&#54805;(numeric)&#47564; &#44032;&#45733;&#54616;&#45796;. . (c) &#45436;&#47532;&#54805;(logical)&#48320;&#49688;&#45716; &#49688;&#52824;&#54805; &#48320;&#49688;&#47196; &#48320;&#54872;&#54624; &#49688; &#50630;&#45796;. . (d) R&#50640;&#49436; {}&#45716; ()&#47196; &#48148;&#44992; &#49688; &#51080;&#45796;. . 7. 100&#44060;&#51032; &#46972;&#52964; (15&#51216;) . 복도에 100개의 라커가 있다. 복도를 어떤 남자가 100개의 라커 문을 전부 연다. 그리고 나서 짝수 번호의 라커를 전부 닫는다. 그 다음에는 번호가 3의 배수인 라커를 순서대로 찾아다니며 열려 있으면 닫고, 닫혀 있으면 연다. 그 다음에는 번호가 4의 배수인 라커를 순서대로 찾아다니며 열려있으면 닫고, 닫혀있으면 연다. 이후에 5의 배수, 6의 배수 .. 인 라커를 순서대로 찾아다니며 행동을 반복한다. 이런식으로 복도를 100번 지나가면 열린 라커의 문은 몇개가 되겠는가? . (풀이1) . - 문을 모두 닫은 상태로 둔다. . x= rep(FALSE, 100) . x . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [97] FALSE FALSE FALSE FALSE . - 문을 여는 함수를 만든다. (닫혀있으면 열고, 열려있으면 닫는함수) . f&lt;- function(x) !x . 10월7일강의 논리연산자 예제1 | . x %&gt;% f . [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE . 문이 잘 열린다. | . - 2,3,4,5 ... 의 배수를 찾아서 문을 열자. . Step1: 2,3,4,5의 배수에 해당하는 원소를 뽑는 코드를 작성한다. | Step2: Step1에서 나온 원소에 한정하여 문을 열거나 닫는다. | . - 2의 배수 구현예시 . (1:100) %% 2 == 0 . [1] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [13] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [25] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [37] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [49] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [61] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [73] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [85] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [97] FALSE TRUE FALSE TRUE . 짝이면 TRUE, 홀이면 FALSE 인 벡터 | . x[(1:100) %% 2 == 0 ] . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] FALSE FALSE . 1~100까지의 라커중 짝수에 해당하는 라커만 추출 | . x[(1:100) %% 2 == 0 ] %&gt;% f . [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [46] TRUE TRUE TRUE TRUE TRUE . 1~100까지의 라커중 짝수에 해당하는 라커만 추출 $ to$ 그 라커들은 문을 열었음 | . x[(1:100) %% 2 == 0 ] &lt;- x[(1:100) %% 2 == 0 ] %&gt;% f x . [1] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [13] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [25] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [37] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [49] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [61] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [73] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [85] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [97] FALSE TRUE FALSE TRUE . 결과를 저장 | . - 3의 배수 구현예시 . x[(1:100) %% 3 == 0 ] &lt;- x[(1:100) %% 3 == 0 ] %&gt;% f . - 4의 배수.. 5의 배수.. $ to$ 함수를 만들자. . g=function(x,a){ n=length(x) x[(1:n) %% a == 0 ] &lt;- x[(1:n) %% a == 0 ] %&gt;% f ## 연산 x ## 결과를 리턴 } . - 검산을 해보자. (검산을 쉽게하기 위해서 10개정도의 라커만 고려하자.) . x=rep(FALSE, 10) x . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE . x %&gt;% f . [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE . x %&gt;% f %&gt;% g(2) . [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE . x %&gt;% f %&gt;% g(2) %&gt;% g(3) . [1] TRUE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE . - 잘 되는것 같습니다. 이제 일반화해서 답을 구해보면 . x=rep(FALSE, 100) # x를 선언, FALSE의 의미는 문이 닫혀있다. x=f(x) # 1회 복도를 지나가면서 모든 문을 열어요 for (i in 2:100){ # 2회부터 100회까지 지나가면서 x=g(x,i) # (1) 2,3,4,5 ... , 100의 배수에 해당하는 문을 선택 (2) 문이 열려있으면 닫고, 닫혀있으면 열어요 } . - 결과는 아래와 같다. . x . [1] TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE [13] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [61] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [97] FALSE FALSE FALSE TRUE . sum(x) . [1] 10 . (풀이2) . x=rep(TRUE,100) for (i in 2:100) x[(1:100) %% i ==0] = !( x[(1:100) %% i ==0] ) sum(x) . [1] 10 . 시험제출용 코드입니다. 공부용은 아니에요 | 차근차근 디버깅을 하고 코드를 확인해가면서 혹시 모를 실수를 방지할 수 있는 풀이 1이 좋아요. | 코드 중간결과를 시각화해서 내가 잘 구현하고 있는지 끊임없이 확인해야 합니다. | 그 다음에 코드를 효율적으로 정리합니다. | . 8. &#47924;&#44417;&#54868; &#44867;&#51060; &#54588;&#50632;&#49845;&#45768;&#45796;. (25&#51216;) . 총 456명의 참가자가 &#39;무궁화 꽃이 피었습니다&#39; 게임에 참가한다. 기본적인 게임의 규칙은 아래와 같다. . 술래는 총 10회간 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39; 를 외친다. . | 참가자는 술래가 있는 곳 까지 이동해야 살 수 있다. . | 술래는 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39;를 외치다가 구호가 끝남과 동시에 뒤를 돌아본다. 이때 움직이는 사람은 죽는다 . | . 따라서 참가자는 술래가 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39;를 외치는 동안만 이동할 수 있다. 욕심을 부려 더 이동하고자 하면 죽을 수 있다. 반대로 죽는 것을 지나치게 두려워한 나머지 매턴마다 조금씩만 이동한다면 10회의 제한횟수 내에 술래에게 도달하지 못하여 죽는다. . 게임환경과 관련된 세부적인 설정은 아래와 같다. . 술래와 참가자의 거리는 35이다. . | 술래는 처음 벽을 보고 $x$초간 무궁화 꽃이 피었습니다를 외친다. . | 모든 참가자는 1초에 거리1이상 움직일 수 없다고 가정한다. (예를들어 2.4초 동안은 최대 2.4의 거리를 이동할 수 있다. 반면 이동을 원치않으면 0의 거리만큼 움직이므로 0~2.4사이의 거리를 움직일 수 있다) . | . 술래와 참가자에 대한 설정값은 아래와 같다. . 술래에 대한 설정값 . 처음에는 술래가 10초간 무궁화 꽃이 피었습니다를 외친다. . | 그 다음에는 술래가 9.5초간 무궁화 꽃이 피었습니다를 외친다. . | 그 다음에도 0.5초씩 구호를 외치는 시간을 줄인다. 이것을 10회 반복한다. . | . 참가자에 대한 설정값 . 처음에는 참가자가 &quot;본인의번호/100&quot;을 계산하여 나온 숫자만큼 움직인다. 즉 10번 참가자는 0.1의 거리를 움직이고 456번 참가자는 4.56의 거리를 움직인다. . | 그 다음은 처음에 본인이 이동했던 거리에 1씩 더하여 움직인다. 즉 10번 참가자는 1.1의 거리를 움직이고 456번 참가자는 5.56의 거리를 움직인다. . | . - 예시1 . 300번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 3 | 4 | 5 | 6 | 7 | 7.5 | . 참가자의 총 이동거리 | 3 | 7 | 12 | 18 | 25 | 32.5 | . 생존할 수 없다. (6회에서 32.5까지 이동후 사망) . - 예시2 . 350번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 3.5 | 4.5 | 5.5 | 6.5 | 7.5 | 7.5 | . 참가자의 총 이동거리 | 3.5 | 8 | 13.5 | 20 | 27.5 | 35 | . 생존 할 수 있다. (6회에서 정확하게 7.5초간 이동하고 살아남는다) . - 예시3 . 400번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 4 | 5 | 6 | 7 | 8 | 5 | . 참가자의 총 이동거리 | 4 | 9 | 15 | 22 | 30 | 35 | . 생존 할 수 있다. (6회에서 5초간만 이동하면 35만큼 이동하므로 살아남는다) . (a) 1&#48264;, 67&#48264;, 218&#48264;, 456&#48264; &#52280;&#44032;&#51088;&#51032; &#49373;&#51316;&#50668;&#48512;&#47484; &#54869;&#51064;&#54616;&#45716; &#54632;&#49688;&#47484; &#51089;&#49457;&#54616;&#46972;. . (b) &#51204;&#52404; &#49373;&#51316;&#51088;&#51473; &#47751;&#47749;&#51060; &#49332;&#50500;&#45224;&#45716;&#51648; &#44228;&#49328;&#54616;&#46972;. . (풀이) . - 전략: 각 플레이어별로 죽느냐 사느냐를 판단하는 로직을 구현하고 for문을 돌리면 된다. . - 죽느냐 사느냐를 판단하는 방법: 살아있는 동안 이동한 총거리 &gt;= 35 . - 살아있는 동안 이동한 총거리를 계산하는 방법: . 죽을위험이 없는 횟수에서 이동한 총거리 + 죽을위험이 있는 횟수에서 술래의 외침시간 동안 이동한 거리 | . - 죽을위험이 없는 횟수에서 이동한 총거리 . num=350 x= seq(10,5.5,by=-.5) ## 술래의 외침시간 steps = num/100 + 0:9 ## 참가자가 이동하려는 거리 . x&gt;=steps . [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE . sum(steps[x&gt;=steps]) . [1] 27.5 . - 죽을 위험이 있는 횟수에서 이동한 거리 . x[x&lt;steps][1] . [1] 7.5 . - 더하면? . sum(steps[x&gt;=steps]) + x[x&lt;steps][1] ## 총이동거리 . [1] 35 . - 총이동거리 &gt;= 35 이면 살아남을 수 있음 . sum(steps[x&gt;=steps]) + x[x&lt;steps][1] &gt;= 35 . [1] TRUE . - 정리하면 . x=seq(10,5.5,by= -0.5) surv&lt;-c() for (num in 1:456){ steps = num/100 + 0:9 surv[num] &lt;- sum(steps[x&gt;=steps]) + x[x&lt;steps][1] &gt;= 35 } sum(surv) . [1] 85 . 9. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#49884;&#44033;&#54868; &#54616;&#46972;. (15&#51216;) . 다음은 인터넷에서 어떠한 자료를 다운받아 매트릭스로 저장하는 코드이다. . df=read.csv(&quot;https://raw.githubusercontent.com/miruetoto/yechan/master/_notebooks/round2.csv&quot;) mat=as.matrix(df) . 매트릭스는 mat이라는 변수에 저장되어 있다. . df=read.csv(&quot;https://raw.githubusercontent.com/miruetoto/yechan/master/_notebooks/round2.csv&quot;) mat=as.matrix(df) . (a) mat&#51032; &#52395;&#48264;&#51704; &#50676;&#51012; $x$, &#46160;&#48264;&#51704;&#50676;&#51012; $y$&#47196; &#49373;&#44033;&#54616;&#44256; plot&#54632;&#49688;&#47484; &#53685;&#54616;&#50668; &#50500;&#47000;&#50752; &#44057;&#51008; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. . plot(mat[,1],mat[,2]) . plot(mat) . R은 알아서 해석해서 해주는 것이 좀 많아요.. | 이것은 프로그램 만든 사람이 편의성을 위해 &quot;만들어준&quot; 기능입니다. | 이러한 기능을 이용한 풀이는 좋은 풀이가 아닌데 그 이유는 프로그램을 만든 사람의 마음에 따라서 시각화가 가능하기도 하고 불가능하기도 합니다. | . (b) &#47588;&#53944;&#47533;&#49828;&#51032; &#52395;&#48264;&#51704; &#54665;(first row)&#47484; &#52636;&#47141;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . - 힌트: 출력결과는 (12,313)이 나와야 한다. . mat[1,] . x y 12 313 . (c) (b)&#51032; &#44208;&#44284;&#50640; &#50500;&#47000;&#51032; &#50672;&#49328;&#51012; &#49688;&#54665;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . $$ begin{bmatrix} 0 &amp; -1 -1 &amp; 0 end{bmatrix} begin{bmatrix} 12 313 end{bmatrix} $$ f = function(X){ dim(X)=c(2,1) X } . rbind(c(0,-1),c(-1,0)) %*% f(mat[1,]) . [,1] [1,] -313 [2,] -12 . (d) (b)-(c) &#44284;&#51221;&#51012; mat&#51032; &#47784;&#46304;&#54665;&#50640; &#48152;&#48373;&#54616;&#50668; &#49352;&#47196;&#50868; &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46308;&#50612;&#46972;. . - 힌트: 아래의 과정을 따른다. . (i) mat와 동일한 dim을 가진 mat2를 만든다. | (ii) mat의 첫번째 행에 (b)-(c)의 과정을 적용하여 길이가 2인 벡터를 얻는다. | (iii) (ii)의 과정에서 얻은 벡터를 새로운 매트릭스의 첫번째 행에 넣는다. | (iv) mat의 두번째 행에 대하여 (ii)-(iii)의 과정을 반복한다. 이후 세번째, 네번째 행에 대하여 (ii)-(iii)의 과정을 반복한다. | . g = function(X){ dim(X)=c(1,2) X } . dim(mat2) . [1] 5513 2 . mat2 = mat*0 for (i in 1:5513) mat2[i,] = rbind(c(0,-1),c(-1,0)) %*% f(mat[i,]) %&gt;% g . (e) (d)&#51032; &#44208;&#44284;&#47196; &#49373;&#49457;&#46104; &#47588;&#53944;&#47533;&#49828;&#51032; &#52395;&#48264;&#51704; &#50676;&#51012; x, &#46160;&#48264;&#51704; &#50676;&#51012; y&#47196; &#54616;&#44256; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. (&#51216;&#51032; &#49353;&#51008; &#48521;&#51008;&#49353;&#51004;&#47196; &#54616;&#46972;) . - 힌트: 아래와 같은 그림이 나와야 한다. . plot(mat2[,1],mat2[,2],col=&#39;red&#39;) . (풀이) . - 사실 아래는 같음 . rbind(c(0,-1),c(-1,0)) %*% c(12,312) ## c(12,313) 벡터 . [,1] [1,] -312 [2,] -12 . rbind(c(0,-1),c(-1,0)) %*% matrix(c(12,312),nrow=2) . [,1] [1,] -312 [2,] -12 . - 그리고 아래도 같음 . c(12,313) %*% rbind(c(0,-1),c(-1,0)) . [,1] [,2] [1,] -313 -12 . matrix(c(12,313),nrow=1) %*% rbind(c(0,-1),c(-1,0)) . [,1] [,2] [1,] -313 -12 . - c(12,313)이 때로는 벡터로, 때로는 $n times 1$인 매트릭스로 생각할 수 있고, 때로는 $1 times n$ 매트릭스로 해석할 수도 있음. . - 따라서 아래와 같이 풀어도 가능함. . mat2 = mat*0 for (i in 1:5513) mat2[i,] = rbind(c(0,-1),c(-1,0)) %*% mat[i,] . plot(mat2,col=&#39;red&#39;) . (풀이3) . - 매트릭스의 곱셈을 잘 이해했다면? . head(mat) . x y [1,] 12 313 [2,] 12 314 [3,] 13 279 [4,] 13 311 [5,] 13 312 [6,] 13 313 . rbind(c(0,-1),c(-1,0)) %*% c(12,313) . [,1] [1,] -313 [2,] -12 . rbind(c(0,-1),c(-1,0)) %*% c(12,314) . [,1] [1,] -314 [2,] -12 . cbind(c(12,313),c(12,314)) . [,1] [,2] [1,] 12 12 [2,] 313 314 . rbind(c(0,-1),c(-1,0)) %*% cbind(c(12,313),c(12,314)) . [,1] [,2] [1,] -313 -314 [2,] -12 -12 . - 응용하면 . rbind(c(0,-1),c(-1,0)) %*% t(mat) %&gt;% t %&gt;% plot(col=&#39;red&#39;) . - 매트릭스 A,B의 곱에서 뒷부분을 임의의 칼럼으로 쪼개서 각각 연산한뒤 합쳐도 성립한다. . - 매트릭스 A,B의 곱에서 앞부분을 임의의 로우로 쪼개서 각각 연산한뒤 합쳐도 성립한다. .",
            "url": "https://guebin.github.io/2021IR/2021/11/11/2021%EB%85%84-1%ED%95%99%EA%B8%B0-R%EC%9E%85%EB%AC%B8%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%ED%92%80%EC%9D%B4.html",
            "relUrl": "/2021/11/11/2021%EB%85%84-1%ED%95%99%EA%B8%B0-R%EC%9E%85%EB%AC%B8%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%ED%92%80%EC%9D%B4.html",
            "date": " • Nov 11, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "2021년 2학기 R입문 중간고사",
            "content": "1. R&#51012; &#51060;&#50857;&#54616;&#50668; &#45796;&#51020;&#51012; &#44228;&#49328;&#54616;&#50668;&#46972;. (3&#51216;) . (a) $2^{-5}+2^{3}$ . (b) $ sqrt{33}$ . (c) $ sum_{k=1}^{100} frac{1}{k^2+2k+1}$ . 2. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (2&#51216;) . (a) &#50500;&#47000;&#50752; &#44057;&#51008; &#49688;&#50676;&#51012; &#49373;&#49457;&#54616;&#46972;. . $$x=(-10,-9.5,-9.0,...,9.0,9.5,10)$$ . (b) &#49373;&#49457;&#46108; &#49688;&#50676;&#50640; &#45824;&#54616;&#50668; &#50500;&#47000;&#47484; &#47564;&#51313;&#54616;&#45716; $y$&#47484; &#44228;&#49328;&#54616;&#46972;. . $$y= begin{cases} x &amp; |x|&gt;5 0 &amp; |x| leq 2 5 &amp; o.w. end{cases}$$ 3. $x=(-10,-9,-8, dots,8,9,10)$&#50640; &#45824;&#54616;&#50668; $h(g(f(x)))$&#51032; &#44228;&#49328;&#44208;&#44284;&#47484; &#44396;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. (10&#51216;) . 단, $f(x)$,$g(x)$, $h(x)$의 정의는 각각 아래와 같다. . $f(x)=2x+3 $ | $g(x)= frac{e^x}{1+e^x}$ | $h(x)=max(x,0)$ | . 4. &#50500;&#47000;&#51473; &#50739;&#51008;&#44163;&#51008;? (O / X &#47196; &#45813;&#50504;&#51648;&#47484; &#50416;&#44256; &#45813;&#51032; &#44540;&#44144;&#44032; &#46104;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54624;&#44163;) (10&#51216;) . (a) $1= frac{1}{2}+ frac{1}{4} + frac{1}{8} dots $ . (b) $e^x= 1+x+x^2+x^3+ dots $ . 5. &#45796;&#51020;&#51012; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (10&#51216;) . 다음은 어느 회사의 연봉에 대한 규정이다. . (가) 입사 첫째 해 연봉은 $a$원이고, 입사 19년째 해까지의 연봉은 해마다 직전 연봉에서 8%씩 인상된다. . (나) 입사 20년째 해부터의 연봉은 입사 19년째 해 연봉의 75%로 한다. . 이 회사에 입사한 사람이 28년동안 근무하여 받는 연봉의 총합은? . 6. &#45796;&#51020; &#47928;&#51109;&#51012; &#51069;&#44256; &#52280;&#44144;&#51667;&#51012; &#54032;&#45800;&#54616;&#49884;&#50724;. (10&#51216;) . (a) _a&#45716; &#48320;&#49688;&#51060;&#47492;&#51004;&#47196; &#44032;&#45733;&#54616;&#45796;. . (b) &#48289;&#53552;&#51032; &#50896;&#49548;&#45716; &#49688;&#52824;&#54805;(numeric)&#47564; &#44032;&#45733;&#54616;&#45796;. . (c) &#45436;&#47532;&#54805;(logical)&#48320;&#49688;&#45716; &#49688;&#52824;&#54805; &#48320;&#49688;&#47196; &#48320;&#54872;&#54624; &#49688; &#50630;&#45796;. . (d) R&#50640;&#49436; {}&#45716; ()&#47196; &#48148;&#44992; &#49688; &#51080;&#45796;. . 7. 100&#44060;&#51032; &#46972;&#52964; (15&#51216;) . 복도에 100개의 라커가 있다. 복도를 어떤 남자가 100개의 라커 문을 전부 연다. 그리고 나서 짝수 번호의 라커를 전부 닫는다. 그 다음에는 번호가 3의 배수인 라커를 순서대로 찾아다니며 열려 있으면 닫고, 닫혀 있으면 연다. 그 다음에는 번호가 4의 배수인 라커를 순서대로 찾아다니며 열려있으면 닫고, 닫혀있으면 연다. 이후에 5의 배수, 6의 배수 .. 인 라커를 순서대로 찾아다니며 행동을 반복한다. 이런식으로 복도를 100번 지나가면 열린 라커의 문은 몇개가 되겠는가? . 8. &#47924;&#44417;&#54868; &#44867;&#51060; &#54588;&#50632;&#49845;&#45768;&#45796;. (25&#51216;) . 총 456명의 참가자가 &#39;무궁화 꽃이 피었습니다&#39; 게임에 참가한다. 기본적인 게임의 규칙은 아래와 같다. . 술래는 총 10회간 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39; 를 외친다. . | 참가자는 술래가 있는 곳 까지 이동해야 살 수 있다. . | 술래는 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39;를 외치다가 구호가 끝남과 동시에 뒤를 돌아본다. 이때 움직이는 사람은 죽는다 . | . 따라서 참가자는 술래가 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39;를 외치는 동안만 이동할 수 있다. 욕심을 부려 더 이동하고자 하면 죽을 수 있다. 반대로 죽는 것을 지나치게 두려워한 나머지 매턴마다 조금씩만 이동한다면 10회의 제한횟수 내에 술래에게 도달하지 못하여 죽는다. . 게임환경과 관련된 세부적인 설정은 아래와 같다. . 술래와 참가자의 거리는 35이다. . | 술래는 처음 벽을 보고 $x$초간 무궁화 꽃이 피었습니다를 외친다. . | 모든 참가자는 1초에 거리1이상 움직일 수 없다고 가정한다. (예를들어 2.4초 동안은 최대 2.4의 거리를 이동할 수 있다. 반면 이동을 원치않으면 0의 거리만큼 움직이므로 0~2.4사이의 거리를 움직일 수 있다) . | . 술래와 참가자에 대한 설정값은 아래와 같다. . 술래에 대한 설정값 . 처음에는 술래가 10초간 무궁화 꽃이 피었습니다를 외친다. . | 그 다음에는 술래가 9.5초간 무궁화 꽃이 피었습니다를 외친다. . | 그 다음에도 0.5초씩 구호를 외치는 시간을 줄인다. 이것을 10회 반복한다. . | . 참가자에 대한 설정값 . 처음에는 참가자가 &quot;본인의번호/100&quot;을 계산하여 나온 숫자만큼 움직인다. 즉 10번 참가자는 0.1의 거리를 움직이고 456번 참가자는 4.56의 거리를 움직인다. . | 그 다음은 처음에 본인이 이동했던 거리에 1씩 더하여 움직인다. 즉 10번 참가자는 1.1의 거리를 움직이고 456번 참가자는 5.56의 거리를 움직인다. . | . - 예시2 . 300번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 3 | 4 | 5 | 6 | 7 | 7.5 | . 참가자의 총 이동거리 | 3 | 7 | 12 | 18 | 25 | 32.5 | . 생존할 수 없다. (6회에서 32.5까지 이동후 사망) . - 예시2 . 350번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 3.5 | 4.5 | 5.5 | 6.5 | 7.5 | 7.5 | . 참가자의 총 이동거리 | 3.5 | 8 | 13.5 | 20 | 27.5 | 35 | . 생존 할 수 있다. (6회에서 정확하게 7.5초간 이동하고 살아남는다) . - 예시3 . 400번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 4 | 5 | 6 | 7 | 8 | 5 | . 참가자의 총 이동거리 | 4 | 9 | 15 | 22 | 30 | 35 | . 생존 할 수 있다. (6회에서 5초간만 이동하면 35만큼 이동하므로 살아남는다) . (a) 1&#48264;, 67&#48264;, 218&#48264;, 456&#48264; &#52280;&#44032;&#51088;&#51032; &#49373;&#51316;&#50668;&#48512;&#47484; &#54869;&#51064;&#54616;&#45716; &#54632;&#49688;&#47484; &#51089;&#49457;&#54616;&#46972;. . (b) &#51204;&#52404; &#49373;&#51316;&#51088;&#51473; &#47751;&#47749;&#51060; &#49332;&#50500;&#45224;&#45716;&#51648; &#44228;&#49328;&#54616;&#46972;. . 9. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#49884;&#44033;&#54868; &#54616;&#46972;. (15&#51216;) . 다음은 인터넷에서 어떠한 자료를 다운받아 매트릭스로 저장하는 코드이다. . df=read.csv(&quot;https://raw.githubusercontent.com/guebin/2021IR/master/_notebooks/round2.csv&quot;) mat=as.matrix(df) . 매트릭스는 mat이라는 변수에 저장되어 있다. . (a) mat&#51032; &#52395;&#48264;&#51704; &#50676;&#51012; $x$, &#46160;&#48264;&#51704;&#50676;&#51012; $y$&#47196; &#49373;&#44033;&#54616;&#44256; plot&#54632;&#49688;&#47484; &#53685;&#54616;&#50668; &#50500;&#47000;&#50752; &#44057;&#51008; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. . . (b) &#47588;&#53944;&#47533;&#49828;&#51032; &#52395;&#48264;&#51704; &#54665;(first row)&#47484; &#52636;&#47141;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . - 힌트: 출력결과는 (12,313)이 나와야 한다. . (c) (b)&#51032; &#44208;&#44284;&#50640; &#50500;&#47000;&#51032; &#50672;&#49328;&#51012; &#49688;&#54665;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . $$ begin{bmatrix} 0 &amp; -1 -1 &amp; 0 end{bmatrix} begin{bmatrix} 12 313 end{bmatrix} $$ (d) (b)-(c) &#44284;&#51221;&#51012; mat&#51032; &#47784;&#46304;&#54665;&#50640; &#48152;&#48373;&#54616;&#50668; &#49352;&#47196;&#50868; &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46308;&#50612;&#46972;. . - 힌트: 아래의 과정을 따른다. . (i) mat와 동일한 dim을 가진 mat2를 만든다. | (ii) mat의 첫번째 행에 (b)-(c)의 과정을 적용하여 길이가 2인 벡터를 얻는다. | (iii) (ii)의 과정에서 얻은 벡터를 새로운 매트릭스의 첫번째 행에 넣는다. | (iv) mat의 두번째 행에 대하여 (ii)-(iii)의 과정을 반복한다. 이후 세번째, 네번째 행에 대하여 (ii)-(iii)의 과정을 반복한다. | . (e) (d)&#51032; &#44208;&#44284;&#47196; &#49373;&#49457;&#46104; &#47588;&#53944;&#47533;&#49828;&#51032; &#52395;&#48264;&#51704; &#50676;&#51012; x, &#46160;&#48264;&#51704; &#50676;&#51012; y&#47196; &#54616;&#44256; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. (&#51216;&#51032; &#49353;&#51008; &#48521;&#51008;&#49353;&#51004;&#47196; &#54616;&#46972;) . - 힌트: 아래와 같은 그림이 나와야 한다. . .",
            "url": "https://guebin.github.io/2021IR/2021/11/09/2021%EB%85%84-1%ED%95%99%EA%B8%B0-R%EC%9E%85%EB%AC%B8%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC.html",
            "relUrl": "/2021/11/09/2021%EB%85%84-1%ED%95%99%EA%B8%B0-R%EC%9E%85%EB%AC%B8%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC.html",
            "date": " • Nov 9, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "시험관련 안내사항",
            "content": "&#49884;&#54744;&#50976;&#54805; . - 오픈북: 강의노트, 본인이 정리한 노트, 인터넷 검색 가능 . - 비대면: Zoom을 활용하여 응시 . &#49884;&#54744;&#49884;&#44036; . - 일시: LMS를 통해 공지한 날의 수업시간 . - 시험시간 중 처음 30분은 장비점검시간으로 활용함 (단, 모든 사람이 준비될 경우 30분을 기다리지 않고 시작) . . Note: 따라서 2시간 수업일 경우 실질적으로 문제를 풀고 답안을 제출할때 까지 쓸 수 있는 시간은 1시간30분입니다. . &#49884;&#54744;&#49892; &#51077;&#51109; . - LMS $ to$ 강의대화 $ to$ Zoom 화상강의 바로 가기로 입장 . &#49884;&#54744;&#47928;&#51228; &#44277;&#44060;&#48169;&#49885; . - LMS 공지사항을 통하여 시험문제의 URL을 공개 . &#51228;&#52636;&#48169;&#49885; . - LMS의 레포트 메뉴를 활용하여 답안지를 제출 (종료시간 이전에 미리 제출가능) . &#51456;&#48708;&#47932; . - 컴퓨터 및 노트북: 시험지 확인 및 문제풀이 용도 . - 핸드폰: Zoom을 통하여 주변상황을 및 컴퓨터 화면을 촬영하는 용도 . . Note: 중간에 핸드폰 및 노트북이 꺼지지 않도록 배터리 충전기를 준비한다. . &#49884;&#54744;&#51204; &#51456;&#48708;&#49324;&#54637; . - 시험준비시간 동안 핸드폰을 아래와 같이 배치하여 학생의 컴퓨터 화면 및 주변상황이 보이도록 함 . . Note: 적절한 각도를 설정하기 어려운 경우 주변환경보다 컴퓨터의 화면이 잘 보이도록 설정할 것 . - 학생증을 준비하여 시험 시작 직전에 본인의 얼굴과 학생증을 함께 촬영한다. (5초간) . &#50976;&#51032;&#49324;&#54637; . - 줌의 대화명은 이름과 학번을 모두 적는다. (예시: 최규빈_202143052) . . Note: 동명이인이 있을 수 있으므로 학번을 같이 적으세요 . - 질문은 카카오톡 채널 혹은 줌의 채팅기능을 이용한다. . - Zoom에서 스피커 음소거를 하지 않는다. (전체 공지사항등이 있을때 음성으로 공지함) . - 핸드폰으로 Zoom참가 중 전화가 오면 거절하고 받지 않는다. (전화통화시 Zoom연결이 종료되므로 부정행위로 의심할 수 있음) . &#44592;&#53440; &#52280;&#44256;&#49324;&#54637; . - 핸드폰과 피씨를 이용하여 줌에 동시접속할 경우 . 최규빈_202143052_핸드폰 | 최규빈_202143052_컴퓨터 | . 와 같이 기기를 분리하여 적는다. . - 시험문제는 코랩으로 풀어도 무방하며 시험문제를 다운받아 개인 주피터노트북 등으로 풀어도 무방하다. . - 제출형식은 주피터 노트북파일을 권장한다. 하지만 풀이 및 코드를 알아볼 수 있는 어떠한 형식으로 제출하여도 무방하다. (ex: txt, hwp, pdf..) .",
            "url": "https://guebin.github.io/2021IR/2021/11/02/%EC%8B%9C%ED%97%98%EA%B4%80%EB%A0%A8-%EC%95%88%EB%82%B4%EC%82%AC%ED%95%AD.html",
            "relUrl": "/2021/11/02/%EC%8B%9C%ED%97%98%EA%B4%80%EB%A0%A8-%EC%95%88%EB%82%B4%EC%82%AC%ED%95%AD.html",
            "date": " • Nov 2, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "(8주차) 11월2일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) 중간고사 대비 설명 (1) . - (2/4) 중간고사 대비 설명 (2) . - (3/4) 백터/매트릭스의 결합 . - (4/4) 매트릭스 원소선택, 벡터관련 연산, 매트릭스 관련연산, 티블(데이터프레임) . %&gt;% . - tidyverse중 하나의 dplyr의 기능 . library(dplyr) . - 예시1 . f&lt;-function(x) x+2 . f(2) . [1] 4 . 2 %&gt;% f . [1] 4 . - 예시2 . f&lt;-function(x,y) x**2+y . f(2,3) . [1] 7 . 2 %&gt;% f(3) . [1] 7 . 3 %&gt;% f(2) . [1] 11 . - 포인트: 함수의 첫번째 입력이 %&gt;% 의 왼쪽의 결과로 생각한다. . 하나의 입력만 받는 함수라면 함수이름만 쓸 수 있다! | 첫입력을 생략한다는 것이 포인트! | . &#46160; &#44060; &#51060;&#49345;&#51032; &#48289;&#53552;, &#54665;&#47148;&#51012; &#44208;&#54633; . &#48289;&#53552;&#51032; &#44208;&#54633; . - 예제1 . x&lt;-c(1,2,3) y&lt;-c(1,2,3,4) . x . [1] 1 2 3 . y . [1] 1 2 3 4 . c(x,y) . [1] 1 2 3 1 2 3 4 . c(y,x) . [1] 1 2 3 4 1 2 3 . c(x,2,2,2,y) . [1] 1 2 3 2 2 2 1 2 3 4 . c는 사실 결합하라라는 의미를 가짐 | . - 예제2 . x&lt;-c(1,2,3) y&lt;-c(4,4,4) . cbind(x,y) . x y [1,] 1 4 [2,] 2 4 [3,] 3 4 . - 예제2-1 . x&lt;-c(1,2,3,4) y&lt;-c(1,2) cbind(x,y) . x y [1,] 1 1 [2,] 2 2 [3,] 3 1 [4,] 4 2 . - 예제2-2 . x&lt;-c(1,2,3,4) cbind(1,x) . x [1,] 1 1 [2,] 1 2 [3,] 1 3 [4,] 1 4 . - 예제3 . x&lt;-c(1,2,3,4) y&lt;-c(1,2) rbind(x,y) . [,1] [,2] [,3] [,4] x 1 2 3 4 y 1 2 1 2 . - 예제4 . x&lt;-c(1,2,3) y&lt;-c(4,5) . cbind(1,c(x,y)) . [,1] [,2] [1,] 1 1 [2,] 1 2 [3,] 1 3 [4,] 1 4 [5,] 1 5 . &#47588;&#53944;&#47533;&#49828;&#51032; &#44208;&#54633; . - 예제1 . X&lt;-rbind(1:5,6:10) y&lt;-c(1,2) . X . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 . y . [1] 1 2 . cbind(X,y,y,X) . y y [1,] 1 2 3 4 5 1 1 1 2 3 4 5 [2,] 6 7 8 9 10 2 2 6 7 8 9 10 . * 이름을 지우기 위해서는 아래와 같이 하면 된다. . XyyX= cbind(X,y,y,X) colnames(XyyX)= NULL XyyX . [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [1,] 1 2 3 4 5 1 1 1 2 3 4 5 [2,] 6 7 8 9 10 2 2 6 7 8 9 10 . - 예제2 . X&lt;-rbind(1:5,6:10) rbind(X,1) . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 [3,] 1 1 1 1 1 . - 예제3 . X &lt;- rbind(1:5,6:10,1:5) Y &lt;- cbind(1:3,4:6,7:9) . X . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 [3,] 1 2 3 4 5 . Y . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . cbind(X,Y) . [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [1,] 1 2 3 4 5 1 4 7 [2,] 6 7 8 9 10 2 5 8 [3,] 1 2 3 4 5 3 6 9 . rbind(X,Y) . Error in rbind(X, Y): number of columns of matrices must match (see arg 2) Traceback: 1. rbind(X, Y) . 드디어 에러!! | . &#47588;&#53944;&#47533;&#49828; &#50896;&#49548; &#49440;&#53469; . X&lt;-rbind(1:5,6:10,1:5) X . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 [3,] 1 2 3 4 5 . - 예제1 . X[,1] . [1] 1 6 1 . 선택된 것은 자동으로 벡터화 된다. | . x=X[,1] . x . [1] 1 6 1 . dim(x) . NULL . dim(x)&lt;-c(3,1) . x . [,1] [1,] 1 [2,] 6 [3,] 1 . - 예제2 . X[,1:2] . [,1] [,2] [1,] 1 2 [2,] 6 7 [3,] 1 2 . - 예제3 . X[,-1] . [,1] [,2] [,3] [,4] [1,] 2 3 4 5 [2,] 7 8 9 10 [3,] 2 3 4 5 . - 예제4 . X[,-(1:2)] . [,1] [,2] [,3] [1,] 3 4 5 [2,] 8 9 10 [3,] 3 4 5 . - 예제5 . X[1:2,] . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 . - 예제6 . X[1:2,1:3] . [,1] [,2] [,3] [1,] 1 2 3 [2,] 6 7 8 . - 예제7 . X[1:2, -1] . [,1] [,2] [,3] [,4] [1,] 2 3 4 5 [2,] 7 8 9 10 . &#48289;&#53552;&#44288;&#47144; &#50672;&#49328; . - 예제1 . c(1,2,5) %in% c(1,2,3,4) . [1] TRUE TRUE FALSE . - 예제2 . union(c(1,1,2,2),c(2,3,4)) . [1] 1 2 3 4 . - 예제3 . intersect(1:5,2:6) . [1] 2 3 4 5 . - 예제4 . x=1:5 . x %*% x . [,1] [1,] 55 . - 예제5 . x=1:5 . x %o% x . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 2 4 6 8 10 [3,] 3 6 9 12 15 [4,] 4 8 12 16 20 [5,] 5 10 15 20 25 . &#47588;&#53944;&#47533;&#49828; &#44288;&#47144;&#50672;&#49328; . - 예제1: 트랜스포즈 . A=cbind(c(1,2,3),c(4,5,6),c(7,8,9)) . A . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . t(A) . [,1] [,2] [,3] [1,] 1 2 3 [2,] 4 5 6 [3,] 7 8 9 . - 예제2: 상수 곱하기 . A=cbind(c(1,2,3),c(4,5,6),c(7,8,9)) A . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . -A . [,1] [,2] [,3] [1,] -1 -4 -7 [2,] -2 -5 -8 [3,] -3 -6 -9 . A*2 . [,1] [,2] [,3] [1,] 2 8 14 [2,] 4 10 16 [3,] 6 12 18 . - 예제3: 덧셈, 뺄셈 . A=cbind(c(1,2,3),c(4,5,6),c(7,8,9)) B=cbind(1:3,1:3,2:4) . A . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . B . [,1] [,2] [,3] [1,] 1 1 2 [2,] 2 2 3 [3,] 3 3 4 . A+B . [,1] [,2] [,3] [1,] 2 5 9 [2,] 4 7 11 [3,] 6 9 13 . - 예제4: 행렬곱셈 . A=cbind(1:2,2:3) A . [,1] [,2] [1,] 1 2 [2,] 2 3 . A %*% A . [,1] [,2] [1,] 5 8 [2,] 8 13 . - 예제5: 역행렬 . A=rbind(c(0,1),c(2,0)) A . [,1] [,2] [1,] 0 1 [2,] 2 0 . solve(A) . [,1] [,2] [1,] 0 0.5 [2,] 1 0.0 . A %*% solve(A) . [,1] [,2] [1,] 1 0 [2,] 0 1 . &#54000;&#48660; &#47564;&#46300;&#45716; &#48169;&#48277; . - 보통 초보단계에서는 일부러 만들기보다 만들어져 있는 경우가 많아요 . - 벡터로 만들기 . x&lt;-c(1,2,3) y&lt;-c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) . tb=tibble(x=x,y=y) . tb . x y 1 1 a 2 2 b 3 3 c . tb$x . [1] 1 2 3 . tb$y . [1] &#34;a&#34; &#34;b&#34; &#34;c&#34; . - 매트릭스로 만들기 . X=cbind(1:10,31:40) X . [,1] [,2] [1,] 1 31 [2,] 2 32 [3,] 3 33 [4,] 4 34 [5,] 5 35 [6,] 6 36 [7,] 7 37 [8,] 8 38 [9,] 9 39 [10,] 10 40 . tb=as_tibble(X) . tb . V1 V2 1 1 31 2 2 32 3 3 33 4 4 34 5 5 35 6 6 36 7 7 37 8 8 38 9 9 39 10 10 40 . &#54000;&#48660;&#51012; &#50416;&#45716; &#51060;&#50976;? . mutate . tb %&gt;% mutate(V3=V1**2+V2,V4=-V3, V5=V4-1) . V1 V2 V3 V4 V5 1 1 31 32 -32 -33 2 2 32 36 -36 -37 3 3 33 42 -42 -43 4 4 34 50 -50 -51 5 5 35 60 -60 -61 6 6 36 72 -72 -73 7 7 37 86 -86 -87 8 8 38 102 -102 -103 9 9 39 120 -120 -121 10 10 40 140 -140 -141 . 열간의 결합으로 새로운 열을 만들기 편리함 | . tb . V1 V2 1 1 31 2 2 32 3 3 33 4 4 34 5 5 35 6 6 36 7 7 37 8 8 38 9 9 39 10 10 40 . 연산을 해도 원래 데이터 프레임은 변화하지 않음. 변화를 위해서는 아래를 해야함. | . tb &lt;- tb %&gt;% mutate(V3=V1**2+V2,V4=-V3, V5=V4-1) . - 아래와 같은코드임 . mutate(tb, V3=V1**2+V2,V4=-V3, V5=V4-1) . V1 V2 V3 V4 V5 1 1 31 32 -32 -33 2 2 32 36 -36 -37 3 3 33 42 -42 -43 4 4 34 50 -50 -51 5 5 35 60 -60 -61 6 6 36 72 -72 -73 7 7 37 86 -86 -87 8 8 38 102 -102 -103 9 9 39 120 -120 -121 10 10 40 140 -140 -141 . filter . tb2 &lt;- tb %&gt;% mutate(V3=V1**2+V2,V4=-V3, V5=V4-1) . tb2 . V1 V2 V3 V4 V5 1 1 31 32 -32 -33 2 2 32 36 -36 -37 3 3 33 42 -42 -43 4 4 34 50 -50 -51 5 5 35 60 -60 -61 6 6 36 72 -72 -73 7 7 37 86 -86 -87 8 8 38 102 -102 -103 9 9 39 120 -120 -121 10 10 40 140 -140 -141 . tb2 %&gt;% filter(V1&gt;5, V3&lt;100) . V1 V2 V3 V4 V5 1 6 36 72 -72 -73 2 7 37 86 -86 -87 . mutate + filter &#44032;&#45733; . tb . V1 V2 1 1 31 2 2 32 3 3 33 4 4 34 5 5 35 6 6 36 7 7 37 8 8 38 9 9 39 10 10 40 . tb %&gt;% mutate(V3=(V1-mean(V1))/sd(V1)) . V1 V2 V3 1 1 31 -1.4863011 2 2 32 -1.1560120 3 3 33 -0.8257228 4 4 34 -0.4954337 5 5 35 -0.1651446 6 6 36 0.1651446 7 7 37 0.4954337 8 8 38 0.8257228 9 9 39 1.1560120 10 10 40 1.4863011 . tb %&gt;% mutate(V3=(V1-mean(V1))/sd(V1)) %&gt;% filter(V3&gt;0.5) . V1 V2 V3 1 8 38 0.8257228 2 9 39 1.1560120 3 10 40 1.4863011 .",
            "url": "https://guebin.github.io/2021IR/2021/11/02/(8%EC%A3%BC%EC%B0%A8)-11%EC%9B%942%EC%9D%BC.html",
            "relUrl": "/2021/11/02/(8%EC%A3%BC%EC%B0%A8)-11%EC%9B%942%EC%9D%BC.html",
            "date": " • Nov 2, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "(A2) 매트릭스",
            "content": "&#44053;&#51032;&#50689;&#49345; . . &#54665;&#47148;&#44284; &#50672;&#47549;&#51068;&#52264;&#48169;&#51221;&#49885; . - 예를들어 아래와 같은 문제가 있다고 하자. . $ begin{cases} w+2x+3y+4z=1 2w+2x+y=9 x-y=4 3w+x-y+3y=7 end{cases}$ . - 매트릭스 형태로 위의 식을 표현하면 아래와 같다. . $ begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix} begin{bmatrix} w x y z end{bmatrix}= begin{bmatrix} 1 9 4 7 end{bmatrix}$ . - 양변에 . $ begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix}$ . 의 역행렬을 취하면 . $ begin{bmatrix} w x y z end{bmatrix}= begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix}^{-1} begin{bmatrix} 1 9 4 7 end{bmatrix}$ . R&#47196; &#44396;&#54788; . - 방법1 . A=rbind(c(1,2,3,4),c(2,2,1,0),c(0,1,-1,0),c(3,1,-1,3)) A . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 2 2 1 0 [3,] 0 1 -1 0 [4,] 3 1 -1 3 . b=c(1,9,4,7) dim(b)=c(4,1) b . [,1] [1,] 1 [2,] 9 [3,] 4 [4,] 7 . solve(A) %*% b . [,1] [1,] 2 [2,] 3 [3,] -1 [4,] -1 . solve(A): $A^{-1}$ | %*% : 매트릭스의 곱셈을 해주는 연산자. | . 따라서 $(w,x,y,z)=(2,3,-1,-1)$ 이다. . - 방법2 . A=rbind(c(1,2,3,4),c(2,2,1,0),c(0,1,-1,0),c(3,1,-1,3)) A . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 2 2 1 0 [3,] 0 1 -1 0 [4,] 3 1 -1 3 . b=c(1,9,4,7) b . [1] 1 9 4 7 . solve(A)%*%b . [,1] [1,] 2 [2,] 3 [3,] -1 [4,] -1 .",
            "url": "https://guebin.github.io/2021IR/2021/10/29/(A2)-%EB%A7%A4%ED%8A%B8%EB%A6%AD%EC%8A%A4.html",
            "relUrl": "/2021/10/29/(A2)-%EB%A7%A4%ED%8A%B8%EB%A6%AD%EC%8A%A4.html",
            "date": " • Oct 29, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "(8주차) 10월28일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/6) 볼링공 문제풀이 (1) . - (2/6) 볼링공 문제풀이 (2) . - (3/6) 자료형 . - (4/6) 형변환 . - (5/6) 벡터, 매트릭스(1) . - (6/6) 매트릭스 (2) . &#48380;&#47553;&#44277;&#47928;&#51228; (2019 SW&#47560;&#50640;&#49828;&#53944;&#47196; &#51077;&#54617; &#53580;&#49828;&#53944;) . A,B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 합니다. 볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다. 또한 같은 무게의 공이 여러개 있을 수 있지만, 서로 다른 공으로 간주합니다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다. . 예를들어 N이 5이고, M이 3이며 각각의 무게가 차례대로 1,3,2,3,2일 때 각 공의 번호가 차례대로 1번부터 5번까지 부여됩니다. 이때 두 사람이 고를 수 있는 볼링공 번호의 조합을 구하면 다음과 같습니다. . (1번,2번), (1번,3번), (1번,4번), (1번,5번), (2번,3번), (2번,5번), (3번,4번), (4번,5번) . 결과적으로 두 사람이 공을 고르는 경우의 수는 8가지입니다. N개의 공의 무게가 각각 주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요. . 입력예시 | . 입력 5 3 1 3 2 3 2 출력 8 . &#47928;&#51228;&#51032; &#49688;&#54617;&#51201;&#54364;&#54788; . $N$개의 볼링공의 무게를 각각 $x_1, dots,x_N$ 이라고 하자. (단, $x_1, dots, x_N$은 $ {1, dots, M }$사의 자연수의 값을 가지며 서로 같은 값을 가질 수 있다) . 예시 $(a_1, dots, a_5)=(1,3,2,3,2)$ 일 경우 가능한 조합의 집합은 아래와 같다. $(a_1,a_2), (a_1,a_3), (a_1,a_4), (a_1,a_5), (a_2,a_3), (a_2,a_5), (a_3,a_4), (a_4,a_5)$ . &#54400;&#51060;7 . a&lt;-c(1,3,2,3,2) . a1&lt;-a a2&lt;-a . dim(a1)&lt;-c(5,1) dim(a2)&lt;-c(1,5) . a1 . [,1] [1,] 1 [2,] 3 [3,] 2 [4,] 3 [5,] 2 . a2 . [,1] [,2] [,3] [,4] [,5] [1,] 1 3 2 3 2 . a1 %*% a2 . [,1] [,2] [,3] [,4] [,5] [1,] 1 3 2 3 2 [2,] 3 9 6 9 6 [3,] 2 6 4 6 4 [4,] 3 9 6 9 6 [5,] 2 6 4 6 4 . %*% 연산자: 매트릭스의 곱셈을 가능하게 해준다. (중요함) | . A = a1 %*% a2 . A . [,1] [,2] [,3] [,4] [,5] [1,] 1 3 2 3 2 [2,] 3 9 6 9 6 [3,] 2 6 4 6 4 [4,] 3 9 6 9 6 [5,] 2 6 4 6 4 . upper.tri(A) . [,1] [,2] [,3] [,4] [,5] [1,] FALSE TRUE TRUE TRUE TRUE [2,] FALSE FALSE TRUE TRUE TRUE [3,] FALSE FALSE FALSE TRUE TRUE [4,] FALSE FALSE FALSE FALSE TRUE [5,] FALSE FALSE FALSE FALSE FALSE . upper.tri(): 그렇게 중요하진 않음 | . A[upper.tri(A)] . [1] 3 2 6 3 9 6 2 6 4 6 . 매트릭스 인덱싱: 중요함 | . A[upper.tri(A)] %in% c(4,9) . [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE . %in%연산자: 중요함 | . sum(!(A[upper.tri(A)] %in% c(4,9))) . [1] 8 . -- . 보총학습 %in% 연산자 . a_ = c(1,2,3,4,4,4,5,6,7,8,9,9,9) a_ %in% c(4,5,9) # _a의 모든원소를 조사하여, 그 원소가 4 혹은 9 이면 True, 아니면 False . [1] FALSE FALSE FALSE TRUE TRUE TRUE TRUE FALSE FALSE FALSE TRUE TRUE [13] TRUE . &#54400;&#51060;8 . a&lt;-c(1,3,2,3,2) . A=outer(a,a) A . [,1] [,2] [,3] [,4] [,5] [1,] 1 3 2 3 2 [2,] 3 9 6 9 6 [3,] 2 6 4 6 4 [4,] 3 9 6 9 6 [5,] 2 6 4 6 4 . sum(!(A[upper.tri(A)] %in% c(4,9) )) . [1] 8 . sum(!(outer(a,a)[upper.tri(outer(a,a))] %in% a**2 )) . [1] 32 . &#54400;&#51060; 6,7,8 . - 풀이6: 데이터프레임 활용 $ to$ 사용하기 쉽고 확장성이 좋음 . - 풀이7,8: 코드가 간결함 / 에러가 발생할 수 있음 . &#45936;&#51060;&#53552;&#54805; . - R에서 데이터를 구성하는 세가지 기본형 . - 수치형(numeric): 정수, 실수, 지수등을 나타내며 실수가 기본형 . a=345 mode(a) . [1] &#34;numeric&#34; . a=34.4455 mode(a) . [1] &#34;numeric&#34; . - 논리형(logical): 논리적 참과 거짓을 나타낸다. . a=T mode(a) . [1] &#34;logical&#34; . a=TRUE mode(a) . [1] &#34;logical&#34; . a=F mode(a) . [1] &#34;logical&#34; . a=FALSE mode(a) . [1] &#34;logical&#34; . - 문자형 . a=&#39;asdf&#39; mode(a) . [1] &#34;character&#34; . a=&#39;TRUE&#39; mode(a) . [1] &#34;character&#34; . a=&#39;1&#39; mode(a) . [1] &#34;character&#34; . - 참고: storgae.mode() . a=pi a . [1] 3.141593 . mode(a) . [1] &#34;numeric&#34; . storage.mode(a) . [1] &#34;double&#34; . a=1:2 a . [1] 1 2 . storage.mode(a) . [1] &#34;integer&#34; . &#54805; &#48320;&#54872; . &#48169;&#48277;1 . a=&quot;331&quot; mode(a) . [1] &#34;character&#34; . - 이것을 수치형으로 바꾸고 싶다. . mode(a) . [1] &#34;character&#34; . 결과가 &quot;character&quot;이 아니라 &quot;numeric&quot;으로 나오면 좋겠다. . mode(a)&lt;-&quot;numeric&quot; . mode(a) . [1] &#34;numeric&#34; . a . [1] 331 . &#48169;&#48277;2 . a=&quot;331&quot; mode(a) . [1] &#34;character&#34; . a . [1] 331 . as.numeric(a) . [1] 331 . a=as.numeric(a) a . [1] 331 . &#50696;&#51228;1: logical -&gt; numeric . a=F . as.numeric(a) . [1] 0 . &#50696;&#51228;2: numeric -&gt; logical . a=1 as.logical(a) . [1] TRUE . a=0 as.logical(a) . [1] FALSE . - 그런데 0,1 이외의 숫자를 바꾸면 어떻게 되는가? . a= -1 as.logical(a) . [1] TRUE . a= 2 as.logical(a) . [1] TRUE . a= 2.222 as.logical(a) . [1] TRUE . &#50696;&#51228;3 . a=&#39;asdfasdfasdf&#39; a=as.numeric(a) . Warning message in eval(expr, envir, enclos): “NAs introduced by coercion” . mode(a) . [1] &#34;numeric&#34; . a=&#39;asdfasdfasdf&#39; a=as.logical(a) . mode(a) . [1] &#34;logical&#34; . mode&#44032; &#49436;&#47196; &#45796;&#47480; &#50896;&#49548;&#47196; &#51060;&#47336;&#50612;&#51652; &#48289;&#53552;&#44032; &#51080;&#45796;&#47732;, &#51060; &#48289;&#53552;&#51032; mode&#45716; &#47924;&#50631;&#51068;&#44620;? . - 예시1 . a&lt;-c(1,T,&#39;1&#39;) a . [1] &#34;1&#34; &#34;TRUE&#34; &#34;1&#34; . mode(a) . [1] &#34;character&#34; . - 예시2 . a&lt;-c(1,T) a . [1] 1 1 . mode(a) . [1] &#34;numeric&#34; . - 결국 mode가 서로 다른 원소로 이루어진 벡터는 없다. . - 서로 다른 기본형을 가지는 원소로 벡터를 만들게 된다면 한가지 형으로 자동 형 변환이 된다. . &#54665;&#47148; . - 행렬도 벡터와 같이 동일한 형의 원소로 구성된다. . - 행렬의 속성 . A=cbind(c(1,2,3,4),c(4,5,6,7),c(2,3,4,1)) A . [,1] [,2] [,3] [1,] 1 4 2 [2,] 2 5 3 [3,] 3 6 4 [4,] 4 7 1 . length(A) . [1] 12 . mode(A) . [1] &#34;numeric&#34; . dim(A) . [1] 4 3 . dimnames(A) . NULL . - 지금은 이름이 없지만 아래와 같이 이름이 있는 경우도 있다. . x=c(1,2,3,4) y=c(2,2,3,4) z=c(3,2,3,4) A=cbind(x,y,z) A . x y z [1,] 1 2 3 [2,] 2 2 2 [3,] 3 3 3 [4,] 4 4 4 . a=T mode(a)&lt;-&quot;character&quot; . dimnames(A) . [[1]] NULL [[2]] [1] &#34;x&#34; &#34;y&#34; &#34;z&#34; . A=rbind(x,y,z) A . [,1] [,2] [,3] [,4] x 1 2 3 4 y 2 2 3 4 z 3 2 3 4 . dimnames(A) . [[1]] [1] &#34;x&#34; &#34;y&#34; &#34;z&#34; [[2]] NULL . &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46300;&#45716; &#48169;&#48277;1: matrix &#54632;&#49688;&#47484; &#51060;&#50857;&#54616;&#45716; &#48169;&#48277; . - 예제1 . matrix(1:12,ncol=2) . [,1] [,2] [1,] 1 7 [2,] 2 8 [3,] 3 9 [4,] 4 10 [5,] 5 11 [6,] 6 12 . - 예제2 . matrix(1:12,ncol=3) . [,1] [,2] [,3] [1,] 1 5 9 [2,] 2 6 10 [3,] 3 7 11 [4,] 4 8 12 . - 예제3 . matrix(1:12,nrow=1) . [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [1,] 1 2 3 4 5 6 7 8 9 10 11 12 . - 예제4 . matrix(1:12,nrow=2) . [,1] [,2] [,3] [,4] [,5] [,6] [1,] 1 3 5 7 9 11 [2,] 2 4 6 8 10 12 . - 예제5 . matrix(1:12,ncol=2,byrow=T) . [,1] [,2] [1,] 1 2 [2,] 3 4 [3,] 5 6 [4,] 7 8 [5,] 9 10 [6,] 11 12 . - 예제6 . matrix(1:12) . [,1] [1,] 1 [2,] 2 [3,] 3 [4,] 4 [5,] 5 [6,] 6 [7,] 7 [8,] 8 [9,] 9 [10,] 10 [11,] 11 [12,] 12 . &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46300;&#45716; &#48169;&#48277;2: rbind &#54632;&#49688;&#47484; &#51060;&#50857;&#54616;&#45716; &#48169;&#48277; . - 예제1 . rbind(1:6,rep(c(1,2),3)) . [,1] [,2] [,3] [,4] [,5] [,6] [1,] 1 2 3 4 5 6 [2,] 1 2 1 2 1 2 . - 예제2 . rbind(1:5,5:1,1:3) . Warning message in rbind(1:5, 5:1, 1:3): “number of columns of result is not a multiple of vector length (arg 3)” . [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 5 4 3 2 1 [3,] 1 2 3 1 2 . - 예제3 . rbind(1:4,4:1,1:2) . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 4 3 2 1 [3,] 1 2 1 2 . - 예제4 . rbind(&quot;row1&quot;=1:4,&quot;row2&quot;=4:1,&quot;row3&quot;=1:2) . [,1] [,2] [,3] [,4] row1 1 2 3 4 row2 4 3 2 1 row3 1 2 1 2 . &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46300;&#45716; &#48169;&#48277;3: cbind &#54632;&#49688;&#47484; &#51060;&#50857;&#54616;&#45716; &#48169;&#48277; . - 예제1 . cbind(1:5,5:1,1:3) . Warning message in cbind(1:5, 5:1, 1:3): “number of rows of result is not a multiple of vector length (arg 3)” . [,1] [,2] [,3] [1,] 1 5 1 [2,] 2 4 2 [3,] 3 3 3 [4,] 4 2 1 [5,] 5 1 2 . - 예제2 . cbind(&quot;col1&quot;=1:6,&quot;col2&quot;=6:1,&quot;col3&quot;=1:3) . col1 col2 col3 [1,] 1 6 1 [2,] 2 5 2 [3,] 3 4 3 [4,] 4 3 1 [5,] 5 2 2 [6,] 6 1 3 . &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46300;&#45716; &#48169;&#48277;4: dim &#54632;&#49688;&#47484; &#51060;&#50857;&#54616;&#45716; &#48169;&#48277; . - 예시1 . mat= 1:6 . dim(mat) . NULL . dim(mat)&lt;-c(2,3) . dim(mat) . [1] 2 3 . mat . [,1] [,2] [,3] [1,] 1 3 5 [2,] 2 4 6 . - 참고: 동일한 문법논리를 사용해서 이미 만들어진 매트릭스를 벡터로 바꾸는 것도 가능하다. . dim(mat)&lt;- NULL . dim(mat) . NULL . mat . [1] 1 2 3 4 5 6 . &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46300;&#45716; &#48169;&#48277;5: array&#54632;&#49688;&#47484; &#51060;&#50857;&#54616;&#45716; &#48169;&#48277; . - 예시1 . array(1:12,dim=c(6,2)) . [,1] [,2] [1,] 1 7 [2,] 2 8 [3,] 3 9 [4,] 4 10 [5,] 5 11 [6,] 6 12 . - 예시2 . array(1:12,dim=c(3,4)) . [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 . - 예시3 . array(1:2,dim=c(3,4)) . [,1] [,2] [,3] [,4] [1,] 1 2 1 2 [2,] 2 1 2 1 [3,] 1 2 1 2 . - 예시4 (이건 매트릭스가 아니다!) . array(1:2,dim=c(3,4,2)) . , , 1 [,1] [,2] [,3] [,4] [1,] 1 2 1 2 [2,] 2 1 2 1 [3,] 1 2 1 2 , , 2 [,1] [,2] [,3] [,4] [1,] 1 2 1 2 [2,] 2 1 2 1 [3,] 1 2 1 2 . - 예시5 (이건 매트릭스가 아니다!) . array(1:2,dim=6) . [1] 1 2 1 2 1 2 . &#48176;&#50676; (array) . - 배열은 동일한 형의 원소를 p개의 차원으로 구성한 데이터 객체이다. . - 행렬은 2차원배열의 일종이다. $p=2$ . - 배열을 선언하는 예시 . array(1:2,dim=c(3,4,2)) . , , 1 [,1] [,2] [,3] [,4] [1,] 1 2 1 2 [2,] 2 1 2 1 [3,] 1 2 1 2 , , 2 [,1] [,2] [,3] [,4] [1,] 1 2 1 2 [2,] 2 1 2 1 [3,] 1 2 1 2 . &#49689;&#51228; . 아래와 같은 메트릭스를 만들고 . $A= begin{bmatrix} 1 &amp; 2 &amp; 3 4 &amp; 5 &amp; 6 7 &amp; 8&amp; 9 end{bmatrix}$ . $B= begin{bmatrix} -1 &amp; -2 &amp; -3 -4 &amp; -5 &amp; -6 -7 &amp; -8 &amp; -10 end{bmatrix}$ . $A+B$를 계산하라. . A=asdf B=asdf A+B .",
            "url": "https://guebin.github.io/2021IR/2021/10/28/(8%EC%A3%BC%EC%B0%A8)-10%EC%9B%9428%EC%9D%BC.html",
            "relUrl": "/2021/10/28/(8%EC%A3%BC%EC%B0%A8)-10%EC%9B%9428%EC%9D%BC.html",
            "date": " • Oct 28, 2021"
        }
        
    
  
    
        ,"post19": {
            "title": "(7주차) 10월26일",
            "content": ". - (1/5) 볼링공 문제풀이 (1) . - (2/5) 볼링공 문제풀이 (2) . - (3/5) 볼링공 문제풀이 (3) . - (4/5) 볼링공 문제풀이 (4) . - (5/5) 과제설명 . &#48380;&#47553;&#44277;&#47928;&#51228; (2019 SW&#47560;&#50640;&#49828;&#53944;&#47196; &#51077;&#54617; &#53580;&#49828;&#53944;) . A,B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 합니다. 볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다. 또한 같은 무게의 공이 여러개 있을 수 있지만, 서로 다른 공으로 간주합니다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다. . 예를들어 N이 5이고, M이 3이며 각각의 무게가 차례대로 1,3,2,3,2일 때 각 공의 번호가 차례대로 1번부터 5번까지 부여됩니다. 이때 두 사람이 고를 수 있는 볼링공 번호의 조합을 구하면 다음과 같습니다. . (1번,2번), (1번,3번), (1번,4번), (1번,5번), (2번,3번), (2번,5번), (3번,4번), (4번,5번) . 결과적으로 두 사람이 공을 고르는 경우의 수는 8가지입니다. N개의 공의 무게가 각각 주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요. . 입력예시 | . 입력 5 3 1 3 2 3 2 출력 8 . &#47928;&#51228;&#51032; &#49688;&#54617;&#51201;&#54364;&#54788; . $N$개의 볼링공의 무게를 각각 $x_1, dots,x_N$ 이라고 하자. (단, $x_1, dots, x_N$은 $ {1, dots, M }$사의 자연수의 값을 가지며 서로 같은 값을 가질 수 있다) . 예시 $(a_1, dots, a_5)=(1,3,2,3,2)$ 일 경우 가능한 조합의 집합은 아래와 같다. $(a_1,a_2), (a_1,a_3), (a_1,a_4), (a_1,a_5), (a_2,a_3), (a_2,a_5), (a_3,a_4), (a_4,a_5)$ . &#54400;&#51060;1 . a=c(1,3,2,3,2) . a . [1] 1 3 2 3 2 . count=0 for (i in 1:5){ for (j in 1:5){ if(a[i]!=a[j]) count=count+1 } } count . [1] 16 . 중복이 계산이 되어서 16이라는 값이 나왔다. (원래는 8이 나와야 한다.) | . - 아래와 같이 수정하면 된다. . count=0 for (i in 1:5){ for (j in 1:5){ if ((a[i]!=a[j]) &amp; (j&gt;i)) count=count+1 } } count . [1] 8 . &#54400;&#51060;2 . - ((a[i]!=a[j]) &amp; (j&gt;i)) 에서 (j&gt;i) 는 for문 선언부에서 처리할 수 있다. . count=0 for (i in 1:5){ for (j in i:5){ if (a[i]!=a[j]) count=count+1 } } count . [1] 8 . &#54400;&#51060;3 . a=c(1,3,2,3,2) A=rep(0,25*2) dim(A)=c(25,2) A . [,1] [,2] [1,] 0 0 [2,] 0 0 [3,] 0 0 [4,] 0 0 [5,] 0 0 [6,] 0 0 [7,] 0 0 [8,] 0 0 [9,] 0 0 [10,] 0 0 [11,] 0 0 [12,] 0 0 [13,] 0 0 [14,] 0 0 [15,] 0 0 [16,] 0 0 [17,] 0 0 [18,] 0 0 [19,] 0 0 [20,] 0 0 [21,] 0 0 [22,] 0 0 [23,] 0 0 [24,] 0 0 [25,] 0 0 . k=1 for (i in 1:5){ for (j in 1:5){ A[k,]&lt;- c(a[i],a[j]) k=k+1 } } . A . [,1] [,2] [1,] 1 1 [2,] 1 3 [3,] 1 2 [4,] 1 3 [5,] 1 2 [6,] 3 1 [7,] 3 3 [8,] 3 2 [9,] 3 3 [10,] 3 2 [11,] 2 1 [12,] 2 3 [13,] 2 2 [14,] 2 3 [15,] 2 2 [16,] 3 1 [17,] 3 3 [18,] 3 2 [19,] 3 3 [20,] 3 2 [21,] 2 1 [22,] 2 3 [23,] 2 2 [24,] 2 3 [25,] 2 2 . - (1) 무게가 같은 것을 뽑지 않고 (2) 중복되는 경우를 제외 . 중복되는 경우를 제외한다는 말은 1번공-2번공 뽑는 경우와 2번공-1번공을 뽑는경우중 하나만 고려한다는 것을 의미 | . vec1&lt;-c() vec2&lt;-c() for(i in 1:25){ vec1[i] &lt;- A[i,1] != A[i,2] vec2[i] &lt;- A[i,1] &gt; A[i,2] } . vec1 . [1] FALSE TRUE TRUE TRUE TRUE TRUE FALSE TRUE FALSE TRUE TRUE TRUE [13] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE TRUE TRUE FALSE TRUE [25] FALSE . vec2 . [1] FALSE FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE TRUE TRUE FALSE [13] FALSE FALSE FALSE TRUE FALSE TRUE FALSE TRUE TRUE FALSE FALSE FALSE [25] FALSE . sum(vec1 &amp; vec2) . [1] 8 . &#54400;&#51060;4 . - vec1, vec2를 굳이 for문으로 구할필요가 없을것 같다. . a=c(1,3,2,3,2) A=rep(0,25*2) dim(A)=c(25,2) k=1 for (i in 1:5){ for (j in 1:5){ A[k,]&lt;- c(a[i],a[j]) k=k+1 } } . A . [,1] [,2] [1,] 1 1 [2,] 1 3 [3,] 1 2 [4,] 1 3 [5,] 1 2 [6,] 3 1 [7,] 3 3 [8,] 3 2 [9,] 3 3 [10,] 3 2 [11,] 2 1 [12,] 2 3 [13,] 2 2 [14,] 2 3 [15,] 2 2 [16,] 3 1 [17,] 3 3 [18,] 3 2 [19,] 3 3 [20,] 3 2 [21,] 2 1 [22,] 2 3 [23,] 2 2 [24,] 2 3 [25,] 2 2 . vec1&lt;- A[,1]!=A[,2] . vec2&lt;- A[,1]&gt;A[,2] . sum(vec1&amp;vec2) . [1] 8 . &#54400;&#51060;5 . - 생각해보니까 단순히 첫번째 열이 두번쨰 열보다 큰지만 체크해도 된다. . a=c(1,3,2,3,2) A=rep(0,25*2) dim(A)=c(25,2) k=1 for (i in 1:5){ for (j in 1:5){ A[k,]&lt;- c(a[i],a[j]) k=k+1 } } . sum(A[,1]&gt;A[,2]) . [1] 8 . &#54788;&#51116;&#44620;&#51648;&#51032; &#54400;&#51060;&#51221;&#47532; . - 풀이1-2: 매트릭스를 사용하지 않음. . - 풀이3-5: 매트릭스를 사용함. . - 현재까지는 풀이2가 가장 간결하고 루프도 적게돌아간다. 하지만 가장 중요한 일은 틀리지 않는 것인데 풀이2는 틀리기 쉬움 . - 하지만 풀이2와 같은 접근법은 디버깅이 어렵다. $ to$ 예외사항을 처리하기 어려움. . - 특히 삼성에서 실시하는 코딩테스트 문제의 경우 예외사항을 잘 처리해야 하는 문제가 주로 출제된다고 한다. . &#54400;&#51060;6 . - 사실 A를 구해주는 함수가 R에 존재함. . a=c(1,3,2,3,2) A=expand.grid(a,a) A . Var1 Var2 1 1 1 2 3 1 3 2 1 4 3 1 5 2 1 6 1 3 7 3 3 8 2 3 9 3 3 10 2 3 11 1 2 12 3 2 13 2 2 14 3 2 15 2 2 16 1 3 17 3 3 18 2 3 19 3 3 20 2 3 21 1 2 22 3 2 23 2 2 24 3 2 25 2 2 . expand.grid(): 벡터를 입렵으로 받아서 그 벡터의 원소가 만들어내는 순서쌍 조합을 데이터프레임 형태로 리턴함 | 데이터프레임 | . library(tidyverse) . ── Attaching packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse 1.3.1 ── ✔ ggplot2 3.3.5 ✔ purrr 0.3.4 ✔ tibble 3.1.5 ✔ dplyr 1.0.7 ✔ tidyr 1.1.4 ✔ stringr 1.4.0 ✔ readr 2.0.2 ✔ forcats 0.5.1 ── Conflicts ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ✖ dplyr::filter() masks stats::filter() ✖ dplyr::lag() masks stats::lag() . A %&gt;% mutate(C= Var1&gt; Var2) . Var1 Var2 C 1 1 1 FALSE 2 3 1 TRUE 3 2 1 TRUE 4 3 1 TRUE 5 2 1 TRUE 6 1 3 FALSE 7 3 3 FALSE 8 2 3 FALSE 9 3 3 FALSE 10 2 3 FALSE 11 1 2 FALSE 12 3 2 TRUE 13 2 2 FALSE 14 3 2 TRUE 15 2 2 FALSE 16 1 3 FALSE 17 3 3 FALSE 18 2 3 FALSE 19 3 3 FALSE 20 2 3 FALSE 21 1 2 FALSE 22 3 2 TRUE 23 2 2 FALSE 24 3 2 TRUE 25 2 2 FALSE . mutate(): 데이터프레임에서 새로운 column을 추가하는 기능 (기존의 컬럼을 활용하여 새로운 파생되는 칼럼을 쉽게 만들 수 있다) | . A %&gt;% mutate(C= Var1&gt; Var2) %&gt;% filter(C == TRUE) . Var1 Var2 C 1 3 1 TRUE 2 2 1 TRUE 3 3 1 TRUE 4 2 1 TRUE 5 3 2 TRUE 6 3 2 TRUE 7 3 2 TRUE 8 3 2 TRUE . filter(): 데이터프레임에서 특정조건을 만족하는 행을 필터링 하는 기능 | . A %&gt;% mutate(C= Var1&gt; Var2) %&gt;% filter(C == TRUE) %&gt;% count . n 1 8 . count(): 데이터프레임의 행의 숫자를 세어주는 기능 | . - 결과가 데이터프레임으로 나옴 $ to$ 숫자가 하나인데 굳이 데이터프레임이 자료형일 이유는 없음 (다루기 불편) . A %&gt;% mutate(C= Var1&gt; Var2) %&gt;% filter(C == TRUE) %&gt;% count -&gt; rslt . rslt+20 . n 1 28 . 1:8 . [1] 1 2 3 4 5 6 7 8 . 1:rslt . Error in 1:rslt: NA/NaN argument Traceback: . - 숫자로 만들기 위해서 as.numeric() 함수를 사용하면 된다. . as.numeric(rslt) . [1] 8 . A %&gt;% mutate(C= Var1&gt; Var2) %&gt;% filter(C == TRUE) %&gt;% count %&gt;% as.numeric . [1] 8 . &#49689;&#51228; . A %&gt;% mutate(C= Var1 -Var2) . Var1 Var2 C 1 1 1 0 2 3 1 2 3 2 1 1 4 3 1 2 5 2 1 1 6 1 3 -2 7 3 3 0 8 2 3 -1 9 3 3 0 10 2 3 -1 11 1 2 -1 12 3 2 1 13 2 2 0 14 3 2 1 15 2 2 0 16 1 3 -2 17 3 3 0 18 2 3 -1 19 3 3 0 20 2 3 -1 21 1 2 -1 22 3 2 1 23 2 2 0 24 3 2 1 25 2 2 0 .",
            "url": "https://guebin.github.io/2021IR/2021/10/26/(7%EC%A3%BC%EC%B0%A8)-10%EC%9B%9426%EC%9D%BC.html",
            "relUrl": "/2021/10/26/(7%EC%A3%BC%EC%B0%A8)-10%EC%9B%9426%EC%9D%BC.html",
            "date": " • Oct 26, 2021"
        }
        
    
  
    
        ,"post20": {
            "title": "(7주차) 10월22일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) 프로그래밍의 중요성 . - (2/4) 숫자 카드 게임 apply함수를 이용한 풀이, 매트릭스 선언방법, 매트릭스에서 원소를 추출하는 방법 . - (3/4) 매트릭스를 사용할시 얻는 이점, apply함수 사용법 (1) . - (4/4) apply함수 사용법 (2), for와 apply코드시간비교, 과제설명 . &#49707;&#51088; &#52852;&#46300; &#44172;&#51076; (2019 &#44397;&#44032; &#44368;&#50977;&#44592;&#44288; &#53076;&#46377;&#53580;&#49828;&#53944;) . 숫자 카드 게임은 여러개의 숫자중에서 가장 높은 숫자가 쓰인 카드를 한장 뽑는 게임이다. . 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다. . 숫자가 쓰인 카드들이 N$ times$M 형태로 놓여 있다. | 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다. | 그 다음 선택된 행에 포함된 카드들 중에서 가장 숫자가 낮은 카드를 뽑아야 한다. | 따라서 처음에 카드를 골라낼 행을 선택할때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다. | . - 예시1 . 입력 3 1 2 4 1 4 2 2 2 출력 2 . - 예시2 . 입력 7 3 1 8 3 3 3 4 출력 3 . &#49689;&#51228; . 입력구조가 . 3 4 5 1 7 7 7 2 8 1 8 2 3 3 4 5 . 와 같을 때 출력을 구하는 코드를 작성하시오. . (숙제풀이) . library(tidyverse) . ── Attaching packages ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse 1.3.1 ── ✔ ggplot2 3.3.5 ✔ purrr 0.3.4 ✔ tibble 3.1.3 ✔ dplyr 1.0.7 ✔ tidyr 1.1.3 ✔ stringr 1.4.0 ✔ readr 1.4.0 ✔ forcats 0.5.1 ── Conflicts ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ✖ dplyr::filter() masks stats::filter() ✖ dplyr::lag() masks stats::lag() . A=rbind(c(3,4,5,1),c(7,7,7,2),c(8,1,8,2),c(3,3,4,5)) A . [,1] [,2] [,3] [,4] [1,] 3 4 5 1 [2,] 7 7 7 2 [3,] 8 1 8 2 [4,] 3 3 4 5 . step1 apply 함수를 사용하여 각 row의 min을 구한다. . apply(A,1,min) # A=입력매트릭스, 1=입력매트릭스의 각 row에 어떠한 함수를 적용 . [1] 1 2 1 3 . A %&gt;% apply(1,min) . [1] 1 2 1 3 . step2. step1의 결과에 max를 취한다. . max(apply(A,1,min)) . [1] 3 . A %&gt;% apply(1,min) %&gt;% max . [1] 3 . &#52852;&#46300;&#48977;&#44592; &#54400;&#51060;&#50640;&#49436; &#50864;&#47532;&#44032; &#50619;&#51012;&#47564;&#54620; &#54532;&#47196;&#44536;&#47000;&#48141; &#47928;&#48277;&#46308; . &#47588;&#53944;&#47533;&#49828;&#47484; &#49440;&#50616;&#54616;&#45716; &#48169;&#48277; . - 방법1: 벡터를 만들고, 그것을 row-vector로 해석한뒤 $ to$ bind . rbind(c(1,2,3,4),c(2,3,4,5)) . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 2 3 4 5 . - 방법2: 벡터를 만들고, 그것을 col-vector로 해석한뒤 $ to$ bind . cbind(c(1,2,3,4),c(2,2,3,4)) . [,1] [,2] [1,] 1 2 [2,] 2 2 [3,] 3 3 [4,] 4 4 . 참고: 만들어진 매트릭스의 차원을 살펴보는 방법 . A=rbind(c(1,2,3,4),c(2,3,4,5)) . dim(A) . [1] 2 4 . A=cbind(c(1,2,3,4),c(2,2,3,4)) . dim(A) . [1] 4 2 . - 방법3: 벡터를 선언하고 dim()을 이용하여 차원을 강제셋팅 . A = 1:8 . A . [1] 1 2 3 4 5 6 7 8 . dim(A) . NULL . dim(A) &lt;- c(2,4) . dim(A) . [1] 2 4 . A . [,1] [,2] [,3] [,4] [1,] 1 3 5 7 [2,] 2 4 6 8 . dim(A) &lt;- c(4,2) . A . [,1] [,2] [1,] 1 5 [2,] 2 6 [3,] 3 7 [4,] 4 8 . dim(A) &lt;- c(3,3) . Error in dim(A) &lt;- c(3, 3): dims [product 9] do not match the length of object [8] Traceback: . - 일단 이정도 까지만.. . &#47588;&#53944;&#47533;&#49828;&#51032; &#50896;&#49548;&#47484; &#48977;&#45716; &#48169;&#48277; . - 아래와 같은 매트릭스가 있다고 하자. . A=rbind(c(1,2,3,4),c(5,6,7,8),c(9,10,11,12)) A . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 [3,] 9 10 11 12 . - 1열을 뽑고싶다. . A[,1] . [1] 1 5 9 . - 1열,4열을 뽑고싶다. . A[,c(1,4)] . [,1] [,2] [1,] 1 4 [2,] 5 8 [3,] 9 12 . - 2행을 뽑고싶다. . A[2,] . [1] 5 6 7 8 . - 1행과 2행을 뽑고싶다. . A[c(1,2),] . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 . - 2행3열의 원소를 뽑고싶다. 즉 (2,3)의 위치에 있는 원소를 뽑고싶다. . A[2,3] . [1] 7 . - 일단 이정도만.. . &#47588;&#53944;&#47533;&#49828;&#47484; &#50780; &#50024;&#50556;&#54616;&#45716;&#44032;? . - 바둑판구조의 자료형을 표현하기 위해서 = 자료를 바둑판 구조로 저장하기 위해서 . - 자료를 바둑판(2d-array), 나아가 큐브형태(3d-array)로 저장하면 어떠한 이점이 있는가? . - 자료를 벡터(1d-array)로 저장하면 어떠한 이점이 있는가? 와 같은 질문 . 프로그래밍 구조상의 이점 | 계산상의 이점 | . (예시) 초항이 1이고 공차가 2인 등차수열을 100개 만들어라. . (풀이1) . a&lt;-c() for (n in 1:100) a[n] = 2*n-1 a . [1] 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 [19] 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 [37] 73 75 77 79 81 83 85 87 89 91 93 95 97 99 101 103 105 107 [55] 109 111 113 115 117 119 121 123 125 127 129 131 133 135 137 139 141 143 [73] 145 147 149 151 153 155 157 159 161 163 165 167 169 171 173 175 177 179 [91] 181 183 185 187 189 191 193 195 197 199 . 위와 같은 간단한 코드도 결국 벡터형태로 자료를 저장하고 관리하기 때문에 for를 쓸 수 있는것임 . (풀이2) . n=1:100 2*n-1 . [1] 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 [19] 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 [37] 73 75 77 79 81 83 85 87 89 91 93 95 97 99 101 103 105 107 [55] 109 111 113 115 117 119 121 123 125 127 129 131 133 135 137 139 141 143 [73] 145 147 149 151 153 155 157 159 161 163 165 167 169 171 173 175 177 179 [91] 181 183 185 187 189 191 193 195 197 199 . 이것역시 벡터의 개념이 있기 때문에 가능함 . - 자료를 벡터로 관리하면 어떠한 이점이 생기듯이 자료를 매트릭스로 관리해도 이점이 생긴다. . apply &#54632;&#49688; . - 우선 아래를 기억하자. . apply(매트릭스,1,특정함수) . 를 쓰면 어떠한 특정함수가 각각의 row에 적용되어서 결과가 array로 저장된다. . - 여기에서 특정함수는 &quot;벡터입력-스칼라출력&quot; 이라 생각하자. 즉 벡터입력-스칼라출력인 함수만 apply가 가능하다고 생각하자. (사실 그렇지는 않음) 예를들면 아래와 같다. . sum(c(1,2,3,4)) . [1] 10 . mean(c(1,2,3,4)) . [1] 2.5 . - 아래와 같은 함수는 벡터입력-벡터출력 이므로 조건에 해당하지 않는다. . sqrt(c(1,2,3,4)) . [1] 1.000000 1.414214 1.732051 2.000000 . - 이제 매트릭스 A에 다양한 함수를 적용해보자. . A . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 [3,] 9 10 11 12 . apply(A,1,sum) . [1] 10 26 42 . apply(A,1,mean) . [1] 2.5 6.5 10.5 . apply(A,1,min) . [1] 1 5 9 . apply(A,1,max) . [1] 4 8 12 . 사용자가 임의로 정의한 함수도 가능하다. . f = function(a) (min(a)+1)**2-3 . apply(A,1,f) . [1] 1 33 97 . - 숫자1을 2로 바꾸면 특정함수가 각각의 col에 적용되어서 결과가 array로 저장된다. . A . [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 [3,] 9 10 11 12 . apply(A,2,sum) . [1] 15 18 21 24 . apply(A,2,mean) . [1] 5 6 7 8 . apply(A,2,min) . [1] 1 2 3 4 . apply(A,2,max) . [1] 9 10 11 12 . apply(A,2,f) . [1] 1 6 13 22 . %&gt;% &#50672;&#49328;&#51088; ($ star star star$) . . Note: 진짜 중요한 문법입니다. 너무편해요. . - 아래는 같은코드이다. . sum(1:10) . [1] 55 . 1:10 %&gt;% sum() . [1] 55 . 1:10 %&gt;% sum . [1] 55 . - 아래와 같이 2개의 입력을 받는 함수를 생각하자. . myfun = function(x,y) x**2+y . myfun(2,3) . [1] 7 . - 아래는 같은코드이다. . myfun(2,3) . [1] 7 . 2 %&gt;% myfun(3) . [1] 7 . - 동일한 논리로 아래도 같은코드이다. . myfun(3,2) . [1] 11 . 3 %&gt;% myfun(2) . [1] 11 . - 입력이 3개인 함수를 만들자. . myfun2= function(x,y,z) x**2 + y*z . - 아래는 같은코드이다. . myfun2(2,1,1) . [1] 5 . 2 %&gt;% myfun2(1,1) . [1] 5 . - 왜 이러한 일을 해야하는가? (합성함수 처리에 유리) . 2:5 %&gt;% log %&gt;% sqrt %&gt;% sum %&gt;% myfun2(1,1) %&gt;% sqrt . [1] 4.440805 . sqrt(myfun2(sum(sqrt(log(2:5))),1,1)) . [1] 4.440805 . 2:5 %&gt;% log %&gt;% myfun(3) %&gt;% sqrt %&gt;% sum %&gt;% myfun2(1,1) %&gt;% sqrt . [1] 8.558202 . sqrt(myfun2(sum(sqrt(myfun(log(2:5),3))),1,1)) . [1] 8.558202 . - 아래의 개념차이 . $g(h(f(x)))$ | $x to f to h to g$ | . &#49884;&#44036;&#48708;&#44368; . - 시간비교하는 방법 . t1=Sys.time() . t2=Sys.time() . t2-t1 . Time difference of 4.949846 secs . - 큰 매트릭스 만듬 . A=sample(1:9,size=100*2000000,replace=TRUE) . dim(A)&lt;-c(2000000,100) A . [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [1,] 4 5 1 3 4 3 7 9 2 3 ⋯ 2 7 [2,] 8 2 6 9 9 9 7 2 5 5 ⋯ 7 4 [3,] 6 9 2 6 5 8 2 3 6 7 ⋯ 7 4 [4,] 5 8 2 4 6 3 6 8 1 8 ⋯ 3 7 [5,] 5 2 6 2 1 6 5 8 9 5 ⋯ 1 7 [6,] 1 8 8 3 5 2 8 4 9 6 ⋯ 5 8 [7,] 2 9 2 9 8 4 5 2 9 4 ⋯ 6 1 [8,] 4 5 4 4 9 8 1 3 6 2 ⋯ 2 8 [9,] 2 6 3 9 7 1 6 7 1 4 ⋯ 7 1 [10,] 2 1 4 3 3 1 9 8 2 8 ⋯ 7 4 [11,] 7 7 3 1 1 3 7 9 6 2 ⋯ 5 6 [12,] 4 5 2 3 8 3 5 7 9 1 ⋯ 2 3 [13,] 3 9 5 9 2 5 2 7 2 8 ⋯ 9 3 [14,] 1 5 9 2 9 9 4 3 1 2 ⋯ 8 6 [15,] 8 5 1 9 9 2 1 1 2 7 ⋯ 8 5 [16,] 9 4 1 8 9 4 7 7 6 1 ⋯ 8 4 [17,] 1 4 1 1 2 7 6 4 2 1 ⋯ 7 9 [18,] 3 1 9 5 7 5 4 2 3 9 ⋯ 7 7 [19,] 7 3 4 1 2 9 8 1 6 6 ⋯ 1 2 [20,] 4 8 7 7 3 4 3 7 3 6 ⋯ 7 7 [21,] 9 5 6 2 8 4 7 8 7 1 ⋯ 4 4 [22,] 7 5 1 5 3 7 8 3 9 5 ⋯ 6 1 [23,] 4 8 7 7 4 3 1 5 9 4 ⋯ 9 5 [24,] 2 1 9 1 4 7 2 9 2 8 ⋯ 7 2 [25,] 5 2 9 8 5 3 5 7 2 7 ⋯ 7 7 [26,] 5 2 3 6 3 5 4 3 7 2 ⋯ 5 3 [27,] 1 9 5 2 6 3 8 3 2 6 ⋯ 6 6 [28,] 6 3 5 5 2 5 7 7 9 8 ⋯ 3 1 [29,] 8 8 7 5 2 2 7 3 1 7 ⋯ 5 5 [30,] 7 3 8 6 4 4 6 4 4 5 ⋯ 5 8 [31,] ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋱ ⋮ ⋮ [32,] 8 4 7 5 5 4 9 4 6 7 ⋯ 3 8 [33,] 5 5 5 1 9 7 9 1 2 4 ⋯ 7 1 [34,] 3 8 1 9 8 8 6 1 5 1 ⋯ 9 6 [35,] 3 8 2 6 6 6 4 5 1 2 ⋯ 9 7 [36,] 8 3 7 5 3 9 9 5 5 8 ⋯ 9 1 [37,] 3 3 8 3 4 9 1 4 8 9 ⋯ 3 1 [38,] 6 6 2 6 7 1 7 9 5 3 ⋯ 9 1 [39,] 8 6 2 2 7 6 3 1 9 2 ⋯ 2 9 [40,] 7 3 7 7 2 2 6 6 4 8 ⋯ 4 2 [41,] 9 1 1 9 7 1 5 3 5 2 ⋯ 9 1 [42,] 8 4 2 1 3 3 7 9 5 9 ⋯ 3 1 [43,] 9 6 7 1 4 8 5 4 9 8 ⋯ 5 6 [44,] 8 7 8 1 9 5 1 8 6 7 ⋯ 7 8 [45,] 3 3 4 8 6 1 6 9 3 1 ⋯ 5 3 [46,] 2 1 6 7 1 2 8 1 1 6 ⋯ 3 4 [47,] 5 2 1 7 7 1 7 6 3 1 ⋯ 6 8 [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [1,] 1 1 3 2 4 7 3 5 [2,] 4 8 7 7 8 1 2 5 [3,] 8 8 2 3 9 4 9 4 [4,] 1 7 9 3 9 9 6 8 [5,] 9 6 3 6 2 8 8 5 [6,] 9 2 9 7 7 9 2 2 [7,] 2 4 3 8 3 3 6 5 [8,] 7 3 8 6 8 4 4 1 [9,] 4 4 6 6 8 8 1 8 [10,] 3 7 6 9 2 2 8 3 [11,] 4 3 4 3 5 5 4 3 [12,] 2 1 4 5 1 3 2 4 [13,] 5 7 7 7 8 9 3 9 [14,] 8 9 6 2 3 2 6 2 [15,] 4 1 2 4 8 7 5 3 [16,] 4 1 9 4 1 1 3 5 [17,] 9 9 4 2 5 3 3 5 [18,] 7 8 5 5 4 1 6 4 [19,] 5 2 4 6 3 6 9 6 [20,] 2 8 1 2 5 7 6 8 [21,] 2 6 5 3 3 7 4 3 [22,] 9 9 8 1 6 2 2 6 [23,] 3 8 1 6 1 1 9 9 [24,] 1 2 1 3 9 9 3 8 [25,] 6 9 5 4 7 6 3 3 [26,] 6 3 9 9 8 4 3 5 [27,] 1 8 4 8 4 3 2 7 [28,] 9 7 2 2 7 2 9 6 [29,] 8 1 7 5 2 5 5 2 [30,] 1 3 8 2 5 9 4 7 [31,] ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ [32,] 8 9 6 2 6 8 4 3 [33,] 8 1 6 2 7 6 7 4 [34,] 4 8 9 8 9 8 8 1 [35,] 5 1 2 6 3 6 2 7 [36,] 1 9 4 6 1 6 5 6 [37,] 8 4 1 9 6 8 5 5 [38,] 1 3 8 6 8 9 1 9 [39,] 2 8 5 3 6 6 7 1 [40,] 7 1 6 2 3 1 6 8 [41,] 9 9 8 9 1 2 1 3 [42,] 6 3 5 3 8 3 6 7 [43,] 2 4 3 9 9 4 1 6 [44,] 7 9 9 2 6 2 2 9 [45,] 9 2 7 3 3 3 8 7 [46,] 5 2 4 7 6 4 2 3 [47,] 2 7 7 8 5 6 3 4 [ reached getOption(&#34;max.print&#34;) -- omitted 14 rows ] . t1=Sys.time() A %&gt;% apply(1,min) %&gt;% max t2=Sys.time() t2-t1 . [1] 2 . Time difference of 4.850609 secs . t1=Sys.time() vec&lt;-c() for(i in 1:(dim(A)[1])) vec[i]&lt;-min(A[i,]) max(vec) t2=Sys.time() t2-t1 . [1] 2 . Time difference of 3.032909 secs . - for문이 좀더 빠르지만 코드는 apply가 더 간결해보인다. . &#49689;&#51228; . - 아래의 코드를 실행하고 실행결과를 제출 . t1=Sys.time() A %&gt;% apply(1,min) %&gt;% max t2=Sys.time() t2-t1 . [1] 2 . Time difference of 4.850609 secs . t1=Sys.time() vec&lt;-c() for(i in 1:(dim(A)[1])) vec[i]&lt;-min(A[i,]) max(vec) t2=Sys.time() t2-t1 . [1] 2 . Time difference of 3.032909 secs .",
            "url": "https://guebin.github.io/2021IR/2021/10/21/(7%EC%A3%BC%EC%B0%A8)-10%EC%9B%9421%EC%9D%BC.html",
            "relUrl": "/2021/10/21/(7%EC%A3%BC%EC%B0%A8)-10%EC%9B%9421%EC%9D%BC.html",
            "date": " • Oct 21, 2021"
        }
        
    
  
    
        ,"post21": {
            "title": "(6주차) 10월19일",
            "content": "&#44053;&#51032;&#45432;&#53944; . . - (1/1) 숫자 카드 게임 . &#49707;&#51088; &#52852;&#46300; &#44172;&#51076; (2019 &#44397;&#44032; &#44368;&#50977;&#44592;&#44288; &#53076;&#46377;&#53580;&#49828;&#53944;) . 숫자 카드 게임은 여러개의 숫자중에서 가장 높은 숫자가 쓰인 카드를 한장 뽑는 게임이다. . 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다. . 숫자가 쓰인 카드들이 N $ times $M 형태로 놓여 있다. | 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다. | 그 다음 선택된 행에 포함된 카드들 중에서 가장 숫자가 낮은 카드를 뽑아야 한다. | 따라서 처음에 카드를 골라낼 행을 선택할때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다. | . - 예시1 . 입력 3 1 2 4 1 4 2 2 2 출력 2 . - 예시2 . 입력 7 3 1 8 3 3 3 4 출력 3 . (풀이) . (전략회의) . a1=c(3,1,2) a2=c(4,1,4) a3=c(2,2,2) . 우리는 일단 아래와 같은 모양을 만들어야함 . 3 1 2 4 1 4 2 2 2 . a1,a2,a3을 각각 row-vector 로 해석하고 bind 하면된다. . A = rbind(a1,a2,a3) . A . [,1] [,2] [,3] a1 3 1 2 a2 4 1 4 a3 2 2 2 . A= rbind(c(3,1,2),c(4,1,4),c(2,2,2)) . 입력이 A일경우 출력이 2가 나와야한다. . 전략: . A의 각 행(row)을 돌아가면서 가장 작은 숫자를 찾아 기록한다. | 기록한 숫자들을 모아서 벡터로 만든다. | 벡터의 최대값을 구한다. | 할수있어야 하는것 . A의 1번째 행, 2번째행, 3번째행을 순서대로 뽑을 수 있어야 한다. | . (실질적풀이) . A= rbind(c(3,1,2),c(4,1,4),c(2,2,2)) . vec&lt;-c() for (i in 1:3) vec[i]&lt;- min(A[i,]) . max(vec) . [1] 2 . - 입력이 아래와 같은 경우 . 7 3 1 8 3 3 3 4 . A=rbind(c(7,3,1,8),c(3,3,3,4)) . vec&lt;-c() for (i in 1:2) vec[i]&lt;- min(A[i,]) . max(vec) . [1] 3 . &#49689;&#51228; . 입력구조가 . 3 4 5 1 7 7 7 2 8 1 8 2 3 3 4 5 . 와 같을 때 출력을 구하는 코드를 작성하시오. .",
            "url": "https://guebin.github.io/2021IR/2021/10/19/(6%EC%A3%BC%EC%B0%A8)-10%EC%9B%9419%EC%9D%BC.html",
            "relUrl": "/2021/10/19/(6%EC%A3%BC%EC%B0%A8)-10%EC%9B%9419%EC%9D%BC.html",
            "date": " • Oct 19, 2021"
        }
        
    
  
    
        ,"post22": {
            "title": "(6주차) 10월14일 -- 특강",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/3) 아나콘다와 가상환경 (1) . - (2/3) 아나콘다와 가상환경 (2) . - (3/3) 아나콘다와 가상환경 (3) .",
            "url": "https://guebin.github.io/2021IR/2021/10/14/(6%EC%A3%BC%EC%B0%A8)-10%EC%9B%9414%EC%9D%BC-%ED%8A%B9%EA%B0%95.html",
            "relUrl": "/2021/10/14/(6%EC%A3%BC%EC%B0%A8)-10%EC%9B%9414%EC%9D%BC-%ED%8A%B9%EA%B0%95.html",
            "date": " • Oct 14, 2021"
        }
        
    
  
    
        ,"post23": {
            "title": "(5주차) 10월12일",
            "content": ". - (1/4) 기타연산자 (1) . - (1/4) 기타연산자 (2) . - (3/4) 기타연산자 (3) . - (4/4) 숙제해설 . &#54624;&#45817;&#50672;&#49328;&#51088; . - 예제1 . a&lt;-1 . a . [1] 1 . a=10 . a . [1] 10 . - 예제2 . 2 -&gt; a . a . [1] 2 . - 잘못된사용 . 2 = a . Error in 2 = a: invalid (do_set) left-hand side to assignment Traceback: . - 예제3 . a&lt;-b&lt;-3 . c(a,b) . [1] 3 3 . a=b=4 . c(a,b) . [1] 4 4 . - 잘못된사용 . a&lt;-3&lt;-b . Error in 3 &lt;- b: invalid (do_set) left-hand side to assignment Traceback: . 3&lt;-b . Error in 3 &lt;- b: invalid (do_set) left-hand side to assignment Traceback: . - 잘못된사용 . a=3=b . Error in 3 = b: invalid (do_set) left-hand side to assignment Traceback: . - 예제4 . a&lt;- 5 -&gt; b . c(a,b) . [1] 5 5 . - 예제5 . f &lt;- function(x) x**2 . f(100) . [1] 10000 . f = function(x) x**2 . f(8) . [1] 64 . - 개인적으로는 &lt;- 를 없애고 = 할당만 있는것도 좋을것 같다. 왜냐하면 . a=-2 . a&lt; -3 . [1] FALSE . a&lt;-3 . a . [1] 3 . 와 같이 헷갈리는 상황이 종종 발생하기 때문 . :&#50672;&#49328;&#51088; . - 예제1 . 4:6 . [1] 4 5 6 . 6:4 . [1] 6 5 4 . ()&#50672;&#49328;&#51088; . - 예제1 . 3+4*3 . [1] 15 . (3+4)*3 . [1] 21 . - 예제2: 표현식을 만들때 연산자 우선순위에 대한 자신이 없는 경우 사용 . 1:3*2 . [1] 2 4 6 . (1:3)*2 . [1] 2 4 6 . 1:(3*2) . [1] 1 2 3 4 5 6 . {}&#50672;&#49328;&#51088;: &#50668;&#47084;&#44060;&#51032; &#54364;&#54788;&#49885;&#51012; &#54616;&#45208;&#51032; &#54364;&#54788;&#49885;&#52376;&#47100;! . - 주로 if, for, function과 함께 사용된다. . - 예제1 . x&lt;-6 if(x&gt;5){ x&lt;-10 y&lt;-20 } . c(x,y) . [1] 10 20 . []&#50672;&#49328;&#51088;: &#50896;&#49548;&#52280;&#51312; &#50672;&#49328;&#51088; . - 예제1 . a&lt;- 6:-2 a . [1] 6 5 4 3 2 1 0 -1 -2 . a[2] . [1] 5 . - 예제2 . a[a&gt;2] . [1] 6 5 4 3 . - 예제3 . a[c(1,2)] . [1] 6 5 . - 예제4 . a[-c(1,2)] . [1] 4 3 2 1 0 -1 -2 . -c(1,2) . [1] -1 -2 . - 아래와 같이 사용할수는 없다. . a[c(-1,2)] . Error in a[c(-1, 2)]: only 0&#39;s may be mixed with negative subscripts Traceback: . #&#50672;&#49328;&#51088;: &#51452;&#49437;&#50672;&#49328;&#51088; . . 틀린코드이지만 어차피 아무것도 실행되지 않아서 에러가 나지는 않음 | . - 블락단위로 주석을 만드는 방법 . 주피터: 컨트롤 + / | Rstudio: 컨트롤 + 쉬프트 + c | . # asdfasdfasdf # asdfasdfasdfasdf # sdfasdfasdf . ?&#50672;&#49328;&#51088;: &#46020;&#50880;&#47568; &#50672;&#49328;&#51088; . ;&#50672;&#49328;&#51088;: &#50672;&#44208;&#50672;&#49328;&#51088; . - 예제1: 두개의 표현식은 원래 한줄에 쓸 수 없다. 그런데 ; 를 사용하면 쓸 수 있다. . a=1, b=2 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:4: unexpected &#39;,&#39; 1: a=1, ^ Traceback: . a=1;b=2 . c(a,b) . [1] 1 2 . - 아래와 같이 표현식의 마지막이 세미콜론으로 끝나도 괜찮음 . a=3;b=4; . c(a,b) . [1] 3 4 . &#50672;&#49328;&#51088; &#50864;&#49440;&#49692;&#50948; . - 예제1 . 1:3**2 . [1] 1 2 3 4 5 6 7 8 9 . - 좀 더 명확하게 아래와 같이 쓰자. . 1:(3**2) . [1] 1 2 3 4 5 6 7 8 9 . (1:3)**2 . [1] 1 4 9 . - 예제2 . 2^2:-1 . [1] 4 3 2 1 0 -1 . - 명확하게 . (2^2):-1 . [1] 4 3 2 1 0 -1 . 2^(2:-1) . [1] 4.0 2.0 1.0 0.5 .",
            "url": "https://guebin.github.io/2021IR/2021/10/12/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%9412%EC%9D%BC.html",
            "relUrl": "/2021/10/12/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%9412%EC%9D%BC.html",
            "date": " • Oct 12, 2021"
        }
        
    
  
    
        ,"post24": {
            "title": "(5주차) 10월7일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) while, break, ifelse . - (2/4) switch, reapeat, next . - (3/4) 산술연산자, 논리연산자 . - (4/4) 비교연산자, 과제설명 . &#51312;&#44148;, &#48152;&#48373;, &#47336;&#54532;&#53448;&#52636; . while . - 예제1 . tot = 0 i = 1 while(i&lt;=100){ tot=tot+i i = i+1 } . tot . [1] 5050 . - 예제1의 다른구현(1) . tot=0 for (i in 1:100) tot = tot +i . tot . [1] 5050 . - 예제1의 다른구현(2) . tot = 0 i = 1 while(TRUE){ tot = tot+i i=i+1 if (i&gt;100) break } . tot . [1] 5050 . - 예제1의 다른구현(3) . tot = 0 i = 1 while(TRUE){ tot = tot+i if (i&gt;=100) break i=i+1 } . tot . [1] 5050 . - 저는 while을 싫어합니다. . - 어쩔수 없이 써야할때가 있어서 알고있는 것입니다. . break . - 예제1 . for (i in 1:10){ print(i) if(i==3) break } . [1] 1 [1] 2 [1] 3 . - 예제2 . for (i in 1:10){ for (j in 1:10){ print(c(i,j)) if(j==3) break } if(i==5) break } . [1] 1 1 [1] 1 2 [1] 1 3 [1] 2 1 [1] 2 2 [1] 2 3 [1] 3 1 [1] 3 2 [1] 3 3 [1] 4 1 [1] 4 2 [1] 4 3 [1] 5 1 [1] 5 2 [1] 5 3 . ifelse . - 예제1 . x= -2:2 x . [1] -2 -1 0 1 2 . ifelse(x&gt;0,x,-x) . [1] 2 1 0 1 2 . - 예제1의 다른구현 . length(x) . [1] 5 . y_ = x*0 y_ . [1] 0 0 0 0 0 . for (i in 1:length(x)){ if (x[i]&gt;0) y_[i] = x[i] else y_[i] = -x[i] } . y_ . [1] 2 1 0 1 2 . - 예제2 . x= -5:5 x . [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 . y=ifelse(x&lt;0, 0, ifelse(x&gt;2,x,1)) . y . [1] 0 0 0 0 0 1 1 1 3 4 5 . plot(x,x) points(x,y,col=2,pch=16) . - 예제2의 다른구현 . x= -5:5 x . [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 . y=x*0 y . [1] 0 0 0 0 0 0 0 0 0 0 0 . n=length(x) n . [1] 11 . for(i in 1:n){ if(x[i]&lt;0) y[i]=0 else if (x[i]&gt;2) y[i]=x[i] else y[i]=1 } . y . [1] 0 0 0 0 0 1 1 1 3 4 5 . - ifelse와 if~else는 성격이 조금 다름 . ifelse: 조건에 부합하는 새로운 벡터를 생성하는데 특화되어있음 | if~else: 조건에 따라 코드의 실행흐름을 제어하는 성격의 문법 | . switch . - 예제1 . switch(1, 10,20,30) . [1] 10 . switch(2, 10,20,30) . [1] 20 . switch(3, 10,20,30) . [1] 30 . - 예제2 . switch(1, c(1,2,3),20,c(30,40)) . [1] 1 2 3 . switch(2, c(1,2,3),20,c(30,40)) . [1] 20 . switch(3, c(1,2,3),20,c(30,40)) . [1] 30 40 . - 예제3 . switch(&#39;a1&#39;, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 1 2 3 . switch(&#39;a2&#39;, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 20 . switch(&#39;a3&#39;, a1=c(1,2,3),a2=20,a3=c(30,40)) . [1] 30 40 . - 예제4 . (예비학습) . x=1:10 x . [1] 1 2 3 4 5 6 7 8 9 10 . c( mean(x), mean(x**2), mean((x-mean(x))**2) ) . [1] 5.50 38.50 8.25 . 38.50 - 5.50**2 . [1] 8.25 . (예제시작) . switch(&quot;f1&quot;, f1=mean(x), f2=mean(x**2), f3=mean((x-mean(x))**2) ) . [1] 5.5 . switch(&quot;f2&quot;, f1=mean(x), f2=mean(x**2), f3=mean((x-mean(x))**2) ) . [1] 38.5 . switch(&quot;f3&quot;, f1=mean(x), f2=mean(x**2), f3=mean((x-mean(x))**2) ) . [1] 8.25 . - 예제5 . myfun&lt;-function(x,f){ switch(f, meann=mean(x), sqmeann=mean(x**2), varr=mean((x-mean(x))**2) ) } . x=1:5 myfun(x,&quot;meann&quot;) myfun(x,&quot;sqmeann&quot;) myfun(x,&quot;varr&quot;) . [1] 3 . [1] 11 . [1] 2 . repeat . - 예제1 . tot=0 i=1 repeat{ tot=tot+i i=i+1 if (i&gt;100) break } . tot . [1] 5050 . - 잘못된 예제1 . tot=0 i=1 repeat{ tot=tot+i i=i+1 } . next . - 예제1 . for(i in 1:5){ if(i==3) next else print(i) } . [1] 1 [1] 2 [1] 4 [1] 5 . break와 비교 . for(i in 1:5){ if(i==3) break else print(i) } . [1] 1 [1] 2 . - 예제2 . i=0 repeat{ i=i+1 if (i&gt;5) break if (i==3) next print(i) } . [1] 1 [1] 2 [1] 4 [1] 5 . &#50836;&#50557; . - 조건: if, if~else / ifelse, switch . - 반복: for, while, repeat . - 루프탈출: break, next . &#50672;&#49328;&#51088; . &#49328;&#49696;&#50672;&#49328;&#51088; . - 예제1 . 5+2 . [1] 7 . 6-2 . [1] 4 . 3*4 . [1] 12 . 6/5 . [1] 1.2 . - 예제2 . 2^3 . [1] 8 . 2**3 . [1] 8 . - 예제3 . 31%%3 . [1] 1 . 31%/%3 . [1] 10 . &#45436;&#47532;&#50672;&#49328;&#51088; . - 예제1 . x=c(T,T,F,F,T) y=c(TRUE,FALSE,TRUE,FALSE,TRUE) . x . [1] TRUE TRUE FALSE FALSE TRUE . y . [1] TRUE FALSE TRUE FALSE TRUE . print(x) print(!x) . [1] TRUE TRUE FALSE FALSE TRUE [1] FALSE FALSE TRUE TRUE FALSE . print(y) print(!y) . [1] TRUE FALSE TRUE FALSE TRUE [1] FALSE TRUE FALSE TRUE FALSE . . Note: TRUE, FALSE 로 구성된 열을 잘 다루면 인덱싱에 유리하다. . - 예제2: 예제1의 응용 . x=1:30 x . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 . x%%3 . [1] 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 . x[x%%3==0] # 3의 배수인것만 출력 . [1] 3 6 9 12 15 18 21 24 27 30 . x[!(x%%3==0)] # 3의 배수가 아닌것만 출력 . [1] 1 2 4 5 7 8 10 11 13 14 16 17 19 20 22 23 25 26 28 29 . - 예제2의 다른구현 (논리연산자와 TRUE/FALSE 로 이루어진 열을 다루는데 익숙하지 않다면 고생스러울 때가 있음) . x&lt;-c() j=1 for (i in 1:30){ if (i%%3 == 0) { x[j]= i j=j+1 } } . x . [1] 3 6 9 12 15 18 21 24 27 30 . x&lt;-c() j=1 for (i in 1:30){ if (i%%3 != 0) { x[j]= i j=j+1 } } . x . [1] 1 2 4 5 7 8 10 11 13 14 16 17 19 20 22 23 25 26 28 29 . - 예제3 . x=c(T,T,F,F,T) y=c(T,F,T,F,T) . print(x) print(y) print(x&amp;y) ## and 연산자, 하나라도 FALSE이면 FALSE . [1] TRUE TRUE FALSE FALSE TRUE [1] TRUE FALSE TRUE FALSE TRUE [1] TRUE FALSE FALSE FALSE TRUE . - 예제4: 예제3의 응용 . x=1:50 . x[(x&gt;30) &amp; (x%%3==0)] # 30보다크고, 3의 배수인것들 . [1] 33 36 39 42 45 48 . x[(x&gt;30) &amp; !(x%%3==0)] . [1] 31 32 34 35 37 38 40 41 43 44 46 47 49 50 . - 예제5 . x=c(T,T,F,F,T) y=c(T,F,T,F,T) . print(x) print(y) print(x|y) ## or 연산자, 하나라도 TRUE이면 TRUE . [1] TRUE TRUE FALSE FALSE TRUE [1] TRUE FALSE TRUE FALSE TRUE [1] TRUE TRUE TRUE FALSE TRUE . - 예제6: 예제5를 응용 . x=1:50 x . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 . x&gt;30 | x&lt;10 . [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE [37] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [49] TRUE TRUE . x[x&gt;30 | x&lt;10] . [1] 1 2 3 4 5 6 7 8 9 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 [26] 47 48 49 50 . - 예제7 . x=c(T,F,T,T,F) y=c(F,T,F,F,T) . print(x) print(y) print(x&amp;&amp;y) . [1] TRUE FALSE TRUE TRUE FALSE [1] FALSE TRUE FALSE FALSE TRUE [1] FALSE . x&amp;&amp;y 와 (x&amp;y)[1]는 거의 같음 | . - 예제8 . x=c(T,F,T,T,F) y=c(F,T,F,F,T) . print(x) print(y) print(x||y) . [1] TRUE FALSE TRUE TRUE FALSE [1] FALSE TRUE FALSE FALSE TRUE [1] TRUE . x||y 와 (x|y)[1]는 거의 같음 | . &#48708;&#44368;&#50672;&#49328;&#51088; . - 예제1 . x=c(1,2,3,4,5) y=c(2,2,3,2,1) . x==y . [1] FALSE TRUE TRUE FALSE FALSE . x!=y . [1] TRUE FALSE FALSE TRUE TRUE . !(x==y) . [1] TRUE FALSE FALSE TRUE TRUE . - 예제1의 잘못된 적용 (1) . x=c(1,2,3,4,5) y=c(2,2,3,2,1) . x=y . x . [1] 2 2 3 2 1 . - 예제1의 잘못된 적용 (2) . x=c(1,2,3,4,5) y=c(2,2,3,2,1) . x=!y . x . [1] FALSE FALSE FALSE FALSE FALSE . ???? 왜 이런결과가? | . (잘못된 결과의 분석) . !y . [1] FALSE FALSE FALSE FALSE FALSE . !c(1,1,0,0) . [1] FALSE FALSE TRUE TRUE . !c(2,2,0,0) . [1] FALSE FALSE TRUE TRUE . - 예제2 . x=c(1,2,3,4,5) y=c(2,2,3,2,1) . x&gt;y . [1] FALSE FALSE FALSE TRUE TRUE . x&lt;y . [1] TRUE FALSE FALSE FALSE FALSE . x&gt;=y . [1] FALSE TRUE TRUE TRUE TRUE . x&lt;=y . [1] TRUE TRUE TRUE FALSE FALSE . - 예제2의 잘못된 사용 . x=&gt;y . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:3: unexpected &#39;&gt;&#39; 1: x=&gt; ^ Traceback: . x=&lt;y . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:3: unexpected &#39;&lt;&#39; 1: x=&lt; ^ Traceback: . &#49689;&#51228; . x= -100:100/10 . x . [1] -10.0 -9.9 -9.8 -9.7 -9.6 -9.5 -9.4 -9.3 -9.2 -9.1 -9.0 -8.9 [13] -8.8 -8.7 -8.6 -8.5 -8.4 -8.3 -8.2 -8.1 -8.0 -7.9 -7.8 -7.7 [25] -7.6 -7.5 -7.4 -7.3 -7.2 -7.1 -7.0 -6.9 -6.8 -6.7 -6.6 -6.5 [37] -6.4 -6.3 -6.2 -6.1 -6.0 -5.9 -5.8 -5.7 -5.6 -5.5 -5.4 -5.3 [49] -5.2 -5.1 -5.0 -4.9 -4.8 -4.7 -4.6 -4.5 -4.4 -4.3 -4.2 -4.1 [61] -4.0 -3.9 -3.8 -3.7 -3.6 -3.5 -3.4 -3.3 -3.2 -3.1 -3.0 -2.9 [73] -2.8 -2.7 -2.6 -2.5 -2.4 -2.3 -2.2 -2.1 -2.0 -1.9 -1.8 -1.7 [85] -1.6 -1.5 -1.4 -1.3 -1.2 -1.1 -1.0 -0.9 -0.8 -0.7 -0.6 -0.5 [97] -0.4 -0.3 -0.2 -0.1 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 [109] 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 [121] 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3.0 3.1 [133] 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 4.0 4.1 4.2 4.3 [145] 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 5.5 [157] 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 [169] 6.8 6.9 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 [181] 8.0 8.1 8.2 8.3 8.4 8.5 8.6 8.7 8.8 8.9 9.0 9.1 [193] 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0 . 아래와 같은 $y$를 생성하라. . $y= begin{cases} x &amp; |x|&gt;5 0 &amp; |x| leq 2 5 &amp; o.w. end{cases}$ . 힌트: ifelse를 중첩, abs()함수를 이용 . ifelse(abs(x)&gt;5,x,ifelse(abs(x)&lt;=2,0,5)) . [1] -10.0 -9.9 -9.8 -9.7 -9.6 -9.5 -9.4 -9.3 -9.2 -9.1 -9.0 -8.9 [13] -8.8 -8.7 -8.6 -8.5 -8.4 -8.3 -8.2 -8.1 -8.0 -7.9 -7.8 -7.7 [25] -7.6 -7.5 -7.4 -7.3 -7.2 -7.1 -7.0 -6.9 -6.8 -6.7 -6.6 -6.5 [37] -6.4 -6.3 -6.2 -6.1 -6.0 -5.9 -5.8 -5.7 -5.6 -5.5 -5.4 -5.3 [49] -5.2 -5.1 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 [61] 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 [73] 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 0.0 0.0 0.0 0.0 [85] 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [97] 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [109] 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [121] 0.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 [133] 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.0 [145] 5.0 5.0 5.0 5.0 5.0 5.0 5.0 5.1 5.2 5.3 5.4 5.5 [157] 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 [169] 6.8 6.9 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 [181] 8.0 8.1 8.2 8.3 8.4 8.5 8.6 8.7 8.8 8.9 9.0 9.1 [193] 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0 .",
            "url": "https://guebin.github.io/2021IR/2021/10/07/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%947%EC%9D%BC.html",
            "relUrl": "/2021/10/07/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%947%EC%9D%BC.html",
            "date": " • Oct 7, 2021"
        }
        
    
  
    
        ,"post25": {
            "title": "(4주차) 10월5일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/3) 2007년(나) 9월/평가원 16(고3) 풀이 (1) . - (2/3) 2007년(나) 9월/평가원 16(고3) 풀이 (2) . - (3/3) 2007년(나) 9월/평가원 16(고3) 풀이 (3), for+break, while, 과제설명 . 2007(&#45208;) 9&#50900;/&#54217;&#44032;&#50896; 16(&#44256;3) . 자연수 $n$에 대하여 점 $P_n$을 다음 규칙에 따라 정한다. . (가) 점 $P_1$의 좌표는 $(1,1)$이다. . (나) 점 $P_n$의 좌표가 $(a,b)$일때, . $b&lt;2^a$이면 점 $P_{n+1}$의 좌표는 $(a,b+1)$이고 | $b=2^a$이면 점 $P_{n+1}$의 좌표는 $(a+1,1)$이다. | . 점 $P_n$의 좌표가 $(10,2^{10})$일 때, $n$의 값은? . (1) $2^{10}-2$ . (2) $2^{10}+2$ . (3) $2^{11}-2$ . (4) $2^{11}$ . (5) $2^{11}+2$ . (풀이전략) . - $P_1$로부터 $P_2$를 구한다. . - $P_2=(10,2^{10})$인지 체크 . 맞다면 $n=2$ | 아니라면 아래를 진행 | . - $P_2$에서 $P_3$을 구한다. . - $P_3=(10,2^{10})$인지 체크 . 맞다면 n=3 | 아니라면 아래를 진행 | . - ... . 그래서 아래와 같은 로직이면 좋겠다. . - for $n=1,2, dots, 2^{11}+2$까지 아래를 반복함 (단, $P_n=(10,2^{10})$인 경우에는 반복중지) . if Pn==(10,2^(10)) 인 경우: 반복문 탈출 else 반복할내용 . (풀이) . a=c() b=c() a[1]=1 b[1]=1 for(n in 1:2^12){ if ((a[n]==10)&amp;(b[n]==2^10)){ print(n) break }else{ ## 탈출못했을때 실행되는 코드 (실질적인 문제풀이 if(b[n]&lt;2^(a[n])){ a[n+1]=a[n] b[n+1]=b[n]+1 }else{ if(b[n]==2^(a[n])){ a[n+1]=a[n]+1 b[n+1]=1 } } } } . [1] 2046 . c(2^10-2 , 2^10+2 , 2^11-2 , 2^11 , 2^11+2) . [1] 1022 1026 2046 2048 2050 . 답은 3번 . &#48152;&#48373;&#47928;&#51012; &#51201;&#45817;&#54620; &#51312;&#44148;&#54616;&#50640;&#47564; &#49688;&#54665;&#54616;&#45716; &#48169;&#48277; . (1) 방법1: for + break 를 적절하게 활용 . (2) 방법2: while 을 이용 . x= -5 while(x&lt;0){ print(&#39;x는음수&#39;) x= x+1 } . [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; . &#49689;&#51228; . - for + break를 활용하여 위와 같은 결과가 나오도록 코드를 작성하라. . for (x in -5:10){ if (????){ break }else{ print(&#39;x는음수&#39;) #x=x+1 } } . [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; [1] &#34;x는음수&#34; .",
            "url": "https://guebin.github.io/2021IR/2021/10/05/(4%EC%A3%BC%EC%B0%A8)-10%EC%9B%945%EC%9D%BC.html",
            "relUrl": "/2021/10/05/(4%EC%A3%BC%EC%B0%A8)-10%EC%9B%945%EC%9D%BC.html",
            "date": " • Oct 5, 2021"
        }
        
    
  
    
        ,"post26": {
            "title": "(4주차) 9월30일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/1) if문 . - (2/4) if - else 문 . - (3/4) 중첩 (1) . - (4/4) 중첩 (2), 과제설명 . if . - 아래와 같이 if (조건문) 표현식의 형태로 사용한다. (표현식은 컴퓨터에게 내가 내리는 명령어이다) . a= 2 if (a&gt;0) print(&#39;a는 양수&#39;) . [1] &#34;a는 양수&#34; . - space를 임의로 넣어도 상관없다. . a=10 if (a&gt;0) print(&#39;a는 양수&#39;) . [1] &#34;a는 양수&#34; . a=10 if (a&gt;0) print(&#39;a는 양수&#39;) . [1] &#34;a는 양수&#34; . - enter를 넣어도 상관없긴하다. . a=10 if (a&gt;0) print(&#39;a는양수&#39;) . [1] &#34;a는양수&#34; . a=10 if (a&gt;0) print(&#39;a는양수&#39;) . [1] &#34;a는양수&#34; . a=10 if (a&gt;0) print(&#39;a는양수&#39;) . [1] &#34;a는양수&#34; . - 컴퓨터에게 내릴 명령이 2개이상일 경우? $ to$ {}을 이용한다. . &#51096;&#47803;&#46108;&#50696;&#51228; . a=10 if (a&gt;0) print(&#39;a는양수&#39;) print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) . [1] &#34;a는양수&#34; [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] 10 . a=-10 if (a&gt;0) print(&#39;a는양수&#39;) ## print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) . [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] -10 . 에러메시지가 뜨지는 않았지만 잘못된 코드이다. | . &#50732;&#48148;&#47480; &#49324;&#50857;&#48277;: {}&#47484; &#51060;&#50857;&#54616;&#50668; &#47749;&#47161;&#46308;&#51012; &#47926;&#45716;&#45796;. . a=10 if (a&gt;0){ print(&#39;a는양수&#39;) print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) } . [1] &#34;a는양수&#34; [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] 10 . a=-10 if (a&gt;0){ print(&#39;a는양수&#39;) ## print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) } . - 아래와 같이 중괄호를 묶어도 상관없다. . a=10 if (a&gt;0) { print(&#39;a는양수&#39;) print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) } . [1] &#34;a는양수&#34; [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] 10 . a=10 if (a&gt;0) { print(&#39;a는양수&#39;) print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a)} . [1] &#34;a는양수&#34; [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] 10 . a=10 if (a&gt;0){ print(&#39;a는양수&#39;) print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) } . [1] &#34;a는양수&#34; [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] 10 . 위와같이 코드를 작성하면 안된다. | . - if (조건문) 표현식 . a=c(10,-10) a . [1] 10 -10 . a&gt;0 . [1] TRUE FALSE . 이 문장이 참일까 거짓일까? $ to$ R은 첫번째 원소가 참이면 참이라고 판단한다. | . a=c(10,-10) if (a&gt;0){ print(&#39;a는 양수이다&#39;) print(&#39;양수인 a의 값은 아래와 같다.&#39;) print(a) } . Warning message in if (a &gt; 0) {: “the condition has length &gt; 1 and only the first element will be used” . [1] &#34;a는 양수이다&#34; [1] &#34;양수인 a의 값은 아래와 같다.&#34; [1] 10 -10 . 이러한 코드를 작성하지 말자. | . if~else . - 아래와 같이 if (조건문) 표현식1 else 표현식2의 형태로 실행한다. . x=2 if (x&gt;0) log(x) else print(&#39;x는양수이어야함&#39;) . [1] 0.6931472 . x=1 if (x&gt;0) log(x) else print(&#39;x는양수이어야함&#39;) . [1] 0 . x=0 if (x&gt;0) log(x) else print(&#39;x는양수이어야함&#39;) . [1] &#34;x는양수이어야함&#34; . x=-1 if (x&gt;0) log(x) else print(&#39;x는양수이어야함&#39;) . [1] &#34;x는양수이어야함&#34; . - if 문과 if~else 문은 다른기능이다. . x=10 if (x&gt;0) log(x) else print(&#39;x는 양수이어야함&#39;) . Error in parse(text = x, srcfile = src): &lt;text&gt;:4:1: unexpected &#39;else&#39; 3: log(x) 4: else ^ Traceback: . ?? 왜 에러가 나는가? | . - 아래는 잘 실행된다. . if (x&gt;0) log(x) else print(&#39;x는양수이어야함&#39;) . [1] &#34;x는양수이어야함&#34; . if (x&gt;0) log(x) else print(&#39;x는양수이어야함&#39;) . [1] &#34;x는양수이어야함&#34; . - 보통은 아래와 같이 사용한다. . x=0 if(x&gt;0){ log(x) }else{ print(&#39;x는 양수이어야함&#39;) } . [1] &#34;x는 양수이어야함&#34; . - 결국 한줄에 다 말하거나, {}를 적절하게 활용하면 된다. . - 아래와 같은것들도 가능 . x=0 if (x&gt;0){ log(x) }else{ print(&#39;x는 양수이어야함&#39;) } . [1] &#34;x는 양수이어야함&#34; . - 아래는 불가능 (무조건 중괄호를 친다고 해결되는것이 아님) . x=0 if (x&gt;0){ log(x) } else{ print(&#39;x는 양수이어야함&#39;) } . Error in parse(text = x, srcfile = src): &lt;text&gt;:5:1: unexpected &#39;else&#39; 4: } 5: else ^ Traceback: . - 결국 아래와 같은 코드를 권장함. (주피터보다 Rstudio가 더 쓰기편하다) . x=0 if(x&gt;0){ log(x) }else{ print(&#39;x는 양수이어야함&#39;) } . [1] &#34;x는 양수이어야함&#34; . &#51473;&#52393; . - 예제시작 . x=10 if (x&gt;0){ print(log(x)) }else{ if(x==0){ x=1e-100 print(&#39;x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.&#39;) log(x) }else{ print(&#39;x가음수입니다.&#39;) } } . [1] 2.302585 . x=0 if (x&gt;0){ print(log(x)) }else{ if(x==0){ x=1e-100 print(&#39;x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.&#39;) log(x) }else{ print(&#39;x가음수입니다.&#39;) } } . [1] &#34;x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.&#34; . [1] -230.2585 . x=-1 if (x&gt;0){ print(log(x)) }else{ if(x==0){ x=1e-100 print(&#39;x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.&#39;) log(x) }else{ print(&#39;x가음수입니다.&#39;) } } . [1] &#34;x가음수입니다.&#34; . - 보통은 아래와 같이 함수 형태로 사용한다. (중괄호지옥 $ to$ Rstudio가 좀더 편리함) . mylogfun&lt;-function(x){ if (x&gt;0){ print(log(x)) }else{ if(x==0){ x=1e-100 print(&#39;x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.&#39;) log(x) }else{ print(&#39;x가음수입니다.&#39;) } } } . mylogfun(0) . [1] &#34;x=0에서는 log(x)가 정의되지 않으므로 x=1e-100의 값으로 바꾸어 계산하겠습니다.&#34; . [1] -230.2585 . &#49689;&#51228; . mysqrtfun()를 만들고 . (1) x&gt;=0 --&gt; sqrt(x) . (2) x&lt;0 --&gt; &#39;x는 양수이어야합니다&#39; . mysqrtfun(-2), mysqrtfun(2) 의 출력결과를 스크린샷으로 제출 .",
            "url": "https://guebin.github.io/2021IR/2021/09/30/(4%EC%A3%BC%EC%B0%A8)-9%EC%9B%9430%EC%9D%BC.html",
            "relUrl": "/2021/09/30/(4%EC%A3%BC%EC%B0%A8)-9%EC%9B%9430%EC%9D%BC.html",
            "date": " • Sep 30, 2021"
        }
        
    
  
    
        ,"post27": {
            "title": "(3주차) 9월28일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/2) for문, 2007(나) 6월 평가원 14 (고3) . - (2/2) 2007(나) 6월 평가원 14 (고3), 2004(인)/수능(홀) 19(고3), 2010(나)/수능(홀) 30(고3), if문 . for&#47928; . - 문제: 1~4까지 모두 더하면? . s=0 for(i in c(1,2,3,4)){ ## i=1,2,3,4에 대하여 아래를 반복하라. s=s+i ## 반복할 내용 } s . [1] 10 . - 위의 코드는 아래와 동일하다. . s=0 i=1 s=s+i i=2 s=s+i i=3 s=s+i i=4 s=s+i s . [1] 10 . 2007(&#45208;) 6&#50900;/&#54217;&#44032;&#50896; 14(&#44256;3) . 다음은 어느 회사의 연봉에 대한 규정이다. . (가) 입사 첫째 해 연봉은 $a$원이고, 입사 19년째 해까지의 연봉은 해마다 직전 연봉에서 8%씩 인상된다. . (나) 입사 20년째 해부터의 연봉은 입사 19년째 해 연봉의 2/3로 한다. . 이 회사에 입사한 사람이 28년동안 근무하여 받는 연봉의 총합은? (단, $1.08^{18}=4$로 계산한다) . (1) $ frac{101}{2}a$ . (2) $ frac{111}{2}a$ . (3) $ frac{121}{2}a$ . (4) $ frac{131}{2}a$ . (5) $ frac{141}{2}a$ . (풀이) . sal&lt;-c() sal[1]&lt;- 1 ## 첫해의 연봉은 1로 하자. . for(i in 2:19){ sal[i] = sal[i-1] * 1.08 } . sal . [1] 1.000000 1.080000 1.166400 1.259712 1.360489 1.469328 1.586874 1.713824 [9] 1.850930 1.999005 2.158925 2.331639 2.518170 2.719624 2.937194 3.172169 [17] 3.425943 3.700018 3.996019 . for(i in 20:28){ sal[i] = sal[19]*2/3 } . sal . [1] 1.000000 1.080000 1.166400 1.259712 1.360489 1.469328 1.586874 1.713824 [9] 1.850930 1.999005 2.158925 2.331639 2.518170 2.719624 2.937194 3.172169 [17] 3.425943 3.700018 3.996019 2.664013 2.664013 2.664013 2.664013 2.664013 [25] 2.664013 2.664013 2.664013 2.664013 . sum(sal) . [1] 65.42238 . c(101/2,111/2,121/2,131/2,141/2) . [1] 50.5 55.5 60.5 65.5 70.5 . 답은4번이다. . 2004(&#51064;)/&#49688;&#45733;(&#54848;) 19(&#44256;3) . 자료 $x_1,x_2, dots, x_{100}$에 대하여 다음 과정을 순서대로 시행하였다. . (가) 처음 두 수 $x_1$과 $x_2$의 평균을 구한다. . (나) $x_3$을 추가하여 $x_1, x_2, x_3$의 평균을 구한다. . (다) $x_4$을 추가하여 $x_1, x_2, x_3, x_4$의 평균을 구한다. . ... . $x_{100}$을 추가하여 $x_1, x_2, x_3 , dots , x_{100}$의 평균을 구한다. . 위의 과정을 시행할 결과, $x_1$과 $x_2$의 평균이 5이고, 자료 하나가 추가될때 마다 평균이 1씩 증가하였다. 이때 $x_{100}$의 값은? . (1) 194 . (2) 196 . (3) 198 . (4) 200 . (5) 202 . (풀이) . x&lt;-c() x[1]=5 x[2]=5 . for(n in 3:100){ temp_ = mean(x[1:(n-1)])+1 ## temp_ : 1~n까지의 평균 sum_ = temp_ * n # 1~n까지의 합 x[n] = sum_ - sum(x[1:(n-1)]) } . x . [1] 5 5 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 [19] 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 [37] 76 78 80 82 84 86 88 90 92 94 96 98 100 102 104 106 108 110 [55] 112 114 116 118 120 122 124 126 128 130 132 134 136 138 140 142 144 146 [73] 148 150 152 154 156 158 160 162 164 166 168 170 172 174 176 178 180 182 [91] 184 186 188 190 192 194 196 198 200 202 . 따라서 답은 5번 . 2010(&#45208;)/&#49688;&#45733;(&#54848;) 30(&#44256;3) . 수열 $ {a_n }$에 대하여 첫째항부터 제 $n$항까지의 합을 $S_n$이라고 하자. 수열 $ {S_{2n-1} }$은 공차가 -3인 등차수열이고, 수열 $ {S_{2n} }$은 공차가 2인 등차수열이다. $a_2=1$일 때, $a_8$의 값을 구하시오. . (풀이) . a&lt;-c() a[1]=222 # 첫째항은 222이라고 하자. a[2]=1 # 문제에서 a2=1이라고 하였음 . - $S_n$은 $n$이 짝수이냐, 홀수이냐에 따라서 정의가 달라짐 . $S_3=S_1-3$ . $S_5=S_3-3$ . ... . $S_4=S_2+2$ . $S_6=S_4+2$ . ... . S&lt;-c() S[1]=a[1] S[2]=a[1]+a[2] . (1:5) %% 3 . [1] 1 2 0 1 2 . n %% 2 . [1] 0 . for(n in 3:100){ ### n이 홀수라면?? (n %% 2)==1 if(n%%2 ==1){ S[n]=S[n-2]-3 }else{ ### n이 짝수라면?? (n%%2) == 0 S[n]=S[n-2]+2 } } . S . [1] 222 223 219 225 216 227 213 229 210 231 207 233 204 235 201 237 198 239 [19] 195 241 192 243 189 245 186 247 183 249 180 251 177 253 174 255 171 257 [37] 168 259 165 261 162 263 159 265 156 267 153 269 150 271 147 273 144 275 [55] 141 277 138 279 135 281 132 283 129 285 126 287 123 289 120 291 117 293 [73] 114 295 111 297 108 299 105 301 102 303 99 305 96 307 93 309 90 311 [91] 87 313 84 315 81 317 78 319 75 321 . S[8]-S[7] . [1] 16 . &#49689;&#51228; . - 2010(나)/수능(홀) 30(고3)의 문제풀이에서 a[1]의 값을 0, 222 이외의 값으로 설정하고 $a_8$을 구하라. .",
            "url": "https://guebin.github.io/2021IR/2021/09/28/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9428%EC%9D%BC.html",
            "relUrl": "/2021/09/28/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9428%EC%9D%BC.html",
            "date": " • Sep 28, 2021"
        }
        
    
  
    
        ,"post28": {
            "title": "(3주차) 9월16일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/2): 2010(나) 6월/평가원 4 (고3) . - (2/2): 2021(가) 9월/평가원 10 (고3), for문 . - 추가영상: 주피터랩, Rstudio . 2010(&#45208;) 6&#50900;/&#54217;&#44032;&#50896; 4 (&#44256;3) . (문제) 실수 $a$가 $ frac{2^a+2^{-a}}{2^{a}-2^{-a}}=-2$를 만족시킬때, $4^a+4^{-a}$의 값은? . (보기) (1) $ frac{5}{2}$ (2) $ frac{10}{3}$ (3) $ frac{17}{4}$ (4) $ frac{26}{5}$ (5) $ frac{37}{6}$ . (풀이) . - 먼저 $ frac{2^{a}+2^{-a}}{2^a-2^{-a}}=-2$를 만족하는 $a$를 찾아보자. . - $f(a)= frac{2^{a}+2^{-a}}{2^a-2^{-a}}$라고 두고 $f(a)=-2$를 만족하는 $a$를 찾으면 된다. . - 함수를 선언하자. . ### 이렇게 한다고 함수가 선언되지는 않는다. f(a) = (2^a + 2^(-a)) / (2^(a)-2^(-a)) . f&lt;-function(a){ (2^a + 2^(-a)) / (2^(a)-2^(-a)) } . - 잘 선언되었는지 확인: $a=1$을 넣으면 $f(a)= frac{2+0.5}{2-0.5}= frac{2.5}{1.5}$ . print(f(1)) print(2.5/1.5) . [1] 1.666667 [1] 1.666667 . 잘 선언된 것 같다. | . - $f(a)$의 그래프를 그리고 $f(a)=-2$에 해당하는 수평선을 그려서 대략적으로 값을 유추하여 보자. . a=seq(from=-5,to=5,by=0.1) . plot(a,f(a)) abline(h=-2,col=&#39;red&#39;) . - 우선 $-2 &lt; a&lt; 0$ 인 것 같다. 범위를 좁히고, by옵션을 사용하여 더 촘촘히 다시 그려보자. . a = seq(from=-2, to=0, by=0.0001) . plot(a,f(a)) abline(h=-2,col=&#39;red&#39;) . ?? | 함수모양을 보니 $a=0$이면 $f(a)$의 분모가 0이 되어서 정의되지 않음. | . - 범위를 $-2 &lt; a&lt; -0.1$ 로 수정해보자. . a = seq(from=-2, to=-0.1, by=0.0001) plot(a,f(a),type=&#39;l&#39;,lwd=4) abline(h=-2,col=2,lty=2,lwd=4) . col: 칼라조정 (2=빨강, &#39;red&#39;=빨강 // 4=파랑, &#39;blue&#39;=파랑) | lty: 점선의 type조정 | lwd: 선의 두께 조정 | . - 이제 해를 찾아보자. $f(a)=-2$를 찾아야 하므로 f(a)== -2를 조건식으로 걸자. . f(a)== -2 . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [805] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [817] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [829] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [841] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [853] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [865] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [877] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [889] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [901] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [913] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [925] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [937] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [949] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [961] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [973] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [985] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [997] FALSE FALSE FALSE FALSE [ reached getOption(&#34;max.print&#34;) -- omitted 18001 entries ] . - 이중에 적당한 값이 있어야 한다. 보이진 않지만 (너무 많아서 눈으로 찾을수는 없지만) 어딘가에 TRUE가 하나는 있을것이다. . - TRUE가 있는지 체크할 수 있는 방법은 없을까? . . &#48372;&#52649;&#54617;&#49845;: &#52980;&#54504;&#53552;&#44032; TRUE, FALSE&#47484; &#51060;&#54644;&#54616;&#45716; &#48169;&#49885; . - 컴퓨터가 TRUE, FALSE를 1,0으로 각각 인식함. . - 아래 예제를 관찰 . TRUE + FALSE . [1] 1 . TRUE*2 . [1] 2 . TRUE+(FALSE-1) * 2 . [1] -1 . 2*c(TRUE, FALSE, TRUE) # 2*c(1,0,1) . [1] 2 0 2 . sum(c(TRUE,FALSE,TRUE)) . [1] 2 . . - 그럼 이제 f(a)==-2의 결과에서 TRUE가 진짜 있는지 찾아보자. . sum(f(a)==-2) . [1] 0 . - ??? 없음.. . - 사실 컴퓨터는 근사계산을 하였으므로 $f(a)=-2$인 $a$를 정확하게 찾기는 힘들다. 따라서 적당히 $f(a) approx -2$인 $a$를 찾는게 더 합리적이다. . - $f(a) approx -2 $ 인 $a$를 찾는건 $f(a)+2 approx 0$인 $a$를 찾는것과 같다. . - 목표: 즉 $f(a)+2$ 의 &quot;절대값&quot;이 0에 가까운 원소를 고르면 된다. . * 참고: 절대값을 구하는 방법 . abs(c(1,2,-2,3,-4)) . [1] 1 2 2 3 4 . - 위를 응용하면 . min(abs(f(a)+2)) # f(a)의 절대값중 가장 작은 값 . [1] 3.898777e-05 . - 이제 $a$는 아래와 같이 구할 수 있다. . TFarray &lt;- abs(f(a)+2) == min(abs(f(a)+2)) a[TFarray] . [1] -0.7925 . $a=-0.7925$ . - 따라서 $4^{a}+4^{-a}$는 . 4^(0.7925) + 4^(-0.7925) . [1] 3.333403 . (보기) (1) $ frac{5}{2}$ (2) $ frac{10}{3}$ (3) $ frac{17}{4}$ (4) $ frac{26}{5}$ (5) $ frac{37}{6}$ . 보기와 비교해보면 . c(5/2,10/3,17/4,26/5,37/6) . [1] 2.500000 3.333333 4.250000 5.200000 6.166667 . 따라서 답은 2번이다. . 2021(&#44032;) 9&#50900;/&#54217;&#44032;&#50896; 10(&#44256;3) . (문제) 수열 $ {a_n }$은 $a_1=12$이고, 모든 자연수 $n$에 대하여 $a_{n+1}+a_n=(-1)^{n+1} times n$을 만족시킨다. $a_k&gt; a_1$인 자연수 $k$의 최소값은? . (보기) (1) $2$ (2) $4$ (3) $6$ (4) $8$ (5) $10$ . (풀이1) . a1=12 n=1 a2= -a1 +(-1)^(n+1)*n n=2 a3= -a2 +(-1)^(n+1)*n . a3 . [1] 9 . 보기를 보니까 10이 최대값이므로 $a_{10}$까지만 구해보자. . a1=12 n=1 a2= -a1 +(-1)^(n+1)*n n=2 a3= -a2 +(-1)^(n+1)*n n=3 a4= -a3 +(-1)^(n+1)*n n=4 a5= -a4 +(-1)^(n+1)*n n=5 a6= -a5 +(-1)^(n+1)*n n=6 a7= -a6 +(-1)^(n+1)*n n=7 a8= -a7 +(-1)^(n+1)*n n=8 a9= -a8 +(-1)^(n+1)*n n=9 a10= -a9 +(-1)^(n+1)*n . a&lt;-c(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) print(a) . [1] 12 -11 9 -6 2 3 -9 16 -24 33 . (1:10)[a&gt;12] . [1] 8 10 . 답은 (4) $8$ 이다. . (풀이2) . - 풀이2를 소개하기 전에 아래와 같이 벡터를 넣는 법을 생각하자. . * 예비학습 . a_ &lt;-c() . a_ . NULL . a_[1] &lt;- 12 . a_ . [1] 12 . a_[2] &lt;- -12 . a_ . [1] 12 -12 . a_[4] &lt;- 3 . a_ . [1] 12 -12 NA 3 . - 풀이시작 (for문) . a&lt;-c() . a[1] &lt;- 12 . ## 아래와 같은 코드를 구현하고 싶다. n=1~9 a_{n+1}= -a_n +(-1)^(n+1)*n . for(n in 1:19){ a[n+1]&lt;- -a[n]+(-1)^(n+1)*n } . print(a) . [1] 12 -11 9 -6 2 3 -9 16 -24 33 -43 54 -66 79 -93 [16] 108 -124 141 -159 178 . print((1:20)[a&gt;12]) . [1] 8 10 12 14 16 18 20 . 답은 (4) 8이다. . &#49689;&#51228; . - 2021(가) 9월/평가원 10(고3) 에 해당하는 수열을 40번째 항까지 구하라. .",
            "url": "https://guebin.github.io/2021IR/2021/09/16/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9416%EC%9D%BC.html",
            "relUrl": "/2021/09/16/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9416%EC%9D%BC.html",
            "date": " • Sep 16, 2021"
        }
        
    
  
    
        ,"post29": {
            "title": "(2주차) 9월14일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/1) 벡터의 원소를 뽑는법, 메인플랏과 서브플랏, 주석이용법 . &#48289;&#53552;&#51032; &#50896;&#49548;&#47484; &#48977;&#45716; &#48169;&#48277; . x&lt;-c(1,2,-2,4,5,-5,6) x . [1] 1 2 -2 4 5 -5 6 . &#50896;&#49548;&#46308;&#51032; &#48264;&#54840;&#47484; &#48520;&#47084;&#49436; &#48977;&#50500;&#45240;&#45796;. . - 첫 원소를 뽑고싶다. . x[1] . [1] 1 . - 세번째 원소를 뽑고싶다. . x[3] . [1] -2 . - 첫번째부터 세번째까지의 원소를 뽑고싶다. . x[1:3] . [1] 1 2 -2 . x[c(1,2,3)] . [1] 1 2 -2 . - 2,5,6 번째의 원소를 뽑고싶다면? . x[c(2,5,6)] . [1] 2 5 -5 . - 3번째 원소를 제외하고 호출 . x[-3] . [1] 1 2 4 5 -5 6 . - 3,4번째의 원소를 제외하고 호출 . x[c(-3,-4)] . [1] 1 2 5 -5 6 . x[-(3:4)] . [1] 1 2 5 -5 6 . &#50612;&#46496;&#54620; &#51312;&#44148;&#51012; &#51452;&#44256;, &#44536; &#51312;&#44148;&#50640; &#47564;&#51313;&#54616;&#45716; &#50896;&#49548; (&#54841;&#51008; &#47564;&#51313;&#54616;&#51648; &#50506;&#45716; &#50896;&#49548;)&#47484; &#48977;&#45716;&#48277; . x&lt;-c(1,2,-2,4,5,-5,6) x . [1] 1 2 -2 4 5 -5 6 . - 양수인 원소를 뽑는법 . (1) 양수인지 스스로 판단 . (2) 양수라면 나간다. . x&gt;0 . [1] TRUE TRUE FALSE TRUE TRUE FALSE TRUE . - x&gt;0이 결과는 TRUE, FALSE가 포함된 벡터 . x[x&gt;0] . [1] 1 2 4 5 6 . - 3보다 큰 원소를 뽑는 방법 . x[x&gt;3] . [1] 4 5 6 . - 3번째 원소를 뽑아라. . array_ = c(FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE) array_ . [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE . x[array_] . [1] -2 . - 값이 -2인 원소를 뽑아라. . x[x == -2] . [1] -2 . - 응용예제 . x&lt;- c(1,2,3,4,5) y&lt;- x^2 . x . [1] 1 2 3 4 5 . y . [1] 1 4 9 16 25 . $y=x^2=9$가 되도록 만드는 $x$를 알려줘! . x[y==9] . [1] 3 . &#44536;&#47548;&#51012; &#44536;&#47540; &#46412; &#44592;&#50613;&#54624; &#44163; . - 그림자체를 생성해주는 plot과 같은 명령이 있고, 생성된 그림에 덧붙여서만 그릴 수 있는 lines, points, abline 과 같은 함수가 있다. . - 생성된 그림에 덧붙여서 그릴 수 있는 함수들은 단독으로 쓸 수 없다. . x&lt;-1:60/10 x . [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 [20] 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 [39] 3.9 4.0 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 5.5 5.6 5.7 [58] 5.8 5.9 6.0 . y&lt;-sin(x) y . [1] 0.09983342 0.19866933 0.29552021 0.38941834 0.47942554 0.56464247 [7] 0.64421769 0.71735609 0.78332691 0.84147098 0.89120736 0.93203909 [13] 0.96355819 0.98544973 0.99749499 0.99957360 0.99166481 0.97384763 [19] 0.94630009 0.90929743 0.86320937 0.80849640 0.74570521 0.67546318 [25] 0.59847214 0.51550137 0.42737988 0.33498815 0.23924933 0.14112001 [31] 0.04158066 -0.05837414 -0.15774569 -0.25554110 -0.35078323 -0.44252044 [37] -0.52983614 -0.61185789 -0.68776616 -0.75680250 -0.81827711 -0.87157577 [43] -0.91616594 -0.95160207 -0.97753012 -0.99369100 -0.99992326 -0.99616461 [49] -0.98245261 -0.95892427 -0.92581468 -0.88345466 -0.83226744 -0.77276449 [55] -0.70554033 -0.63126664 -0.55068554 -0.46460218 -0.37387666 -0.27941550 . - plot은 단독으로 그림을 만드는 함수, lines는 만들어진 그림에 덧붙이는 함수 . plot(x,y,type=&#39;l&#39;,col=&#39;red&#39;) lines(x,y^2,col=&#39;blue&#39;) . - lines를 먼저 사용하면 이미 만들어진 그림이 없는 상태이므로 error가 발생 . lines(x,y^2,type=&#39;l&#39;,col=&#39;red&#39;) plot(x,y,type=&#39;l&#39;,col=&#39;blue&#39;) . Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet Traceback: 1. lines(x, y^2, type = &#34;l&#34;, col = &#34;red&#34;) 2. lines.default(x, y^2, type = &#34;l&#34;, col = &#34;red&#34;) 3. plot.xy(xy.coords(x, y), type = type, ...) . - 다양한 명령어들 비교 . plot(x,y)와 plot(x,y,type=&#39;l&#39;)을 비교해보기 | plot(x,y)와 plot(x,y,col=&#39;red&#39;)를 비교해보기 | plot(x,y)와 lines(x,y**2)를 같이 그려보기 | plot(x,y)와 points(x,y**2)를 같이 그려보기 | . &#51452;&#49437;&#51060;&#50857;&#48169;&#48277; . - 사용법 . a&lt;- 1 a&lt;- a+1 a&lt;- a+1 print(a) . [1] 3 . a&lt;- 1 #a&lt;- a+1 a&lt;- a+1 print(a) . [1] 2 . - 왜 쓰는지? (1) 코드 test (2) 설명을 쓰고싶을때 . a&lt;- 1 # a에 1을 대입하라. #a&lt;- a+1 a&lt;- a+1 # a의 값을 1증가하라. print(a) . [1] 2 . &#49689;&#51228; . 아래의 4개중 하나를 골라 비교해보고 결과를 캡쳐하여 LMS에 제출 . plot(x,y)와 plot(x,y,type=&#39;l&#39;)을 비교해보기 | plot(x,y)와 plot(x,y,col=&#39;red&#39;)를 비교해보기 | plot(x,y)와 lines(x,y**2)를 같이 그려보기 | plot(x,y)와 points(x,y**2)를 같이 그려보기 | .",
            "url": "https://guebin.github.io/2021IR/2021/09/14/(2%EC%A3%BC%EC%B0%A8)-9%EC%9B%9414%EC%9D%BC.html",
            "relUrl": "/2021/09/14/(2%EC%A3%BC%EC%B0%A8)-9%EC%9B%9414%EC%9D%BC.html",
            "date": " • Sep 14, 2021"
        }
        
    
  
    
        ,"post30": {
            "title": "(2주차) 9월9일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8): 과제제출 연장안내 . - (2/8): 아나콘다 설치 1 . - (3/8): 아나콘다 설치 2, 주피터랩을 사용하여 R실습해보기 . - (4/8): 변수이름 선언하기 . - (5/8): 변수이름 선언하는 팁 . - (6/8): 벡터선언하기 1 . - (7/8): 벡터선언하기 2, 함수선언 . - (8/8): 과제설명 . &#48320;&#49688;&#51060;&#47492;&#50640; &#50612;&#46496;&#54620; &#44050;&#51012; &#45347;&#45716; &#48169;&#48277; . - 방법1 . d=1 . - 방법2 . e &lt;- 3 . &#51452;&#51032;&#54624;&#51216;: &#50424; &#49688; &#50630;&#45716; &#48320;&#49688;&#47749;&#51060; &#51080;&#45796;. . (1) 특수문자 불가능 . a! &lt;- 3 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:2: unexpected &#39;!&#39; 1: a! ^ Traceback: . (2) 숫자로 시작하는 변수이름 불가능 . 2a &lt;- 3 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:2: unexpected symbol 1: 2a ^ Traceback: . a2 &lt;- 3 . 이것은 가능 (숫자로 시작되면 안되는 것이지 숫자를 포함하지 말라는 의미는 아님) | . (3) 띄어쓰기 불가능 . Guebin Choi &lt;- 33 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:8: unexpected symbol 1: Guebin Choi ^ Traceback: . this_is_333 &lt;- 333 . 띄어쓰기 대신 언더바(_)를 활용한다. | . this.is.777 &lt;- 777 . 언더바 말고 닷(.)을 선호하는 사람도 있다. | . (4) 언더바를 포함하는 것은 가능하지만, 언더바로 시작하는 변수명은 사용할 수 없다. ` . _x &lt;- 33 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:1: unexpected input 1: _ ^ Traceback: . (5) 사용할 수는 있지만 권장하지 않는 변수이름 . pi . [1] 3.141593 . pi&lt;-333 . pi . [1] 333 . (6) 팁.. . - 변수를 축약할때 모음을 제외하면 좋다. . result -&gt; rslt | residual -&gt; rsdl | . - 임시로 변수명을 사용해야 할 경우: 변수이름 끝에 언더바를 붙인다. . x , y, rslt_, ... | . &#48289;&#53552;&#47484; &#49440;&#50616;&#54616;&#45716; &#48169;&#48277; . - 방법1: 직접 입력 . c(1,2,3,3,4,5,2) . [1] 1 2 3 3 4 5 2 . - 방법2: seq 를 이용 . seq(from=0,to=10,by=0.1) # 0~10 까지 0.1의 간격으로 수열만들기 . [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 [16] 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 [31] 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 4.0 4.1 4.2 4.3 4.4 [46] 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 5.5 5.6 5.7 5.8 5.9 [61] 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 6.8 6.9 7.0 7.1 7.2 7.3 7.4 [76] 7.5 7.6 7.7 7.8 7.9 8.0 8.1 8.2 8.3 8.4 8.5 8.6 8.7 8.8 8.9 [91] 9.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0 . seq(from=0, to=1, length.out = 27) # 0~1 까지 등간격으로 총 27개의 수열만들기 . [1] 0.00000000 0.03846154 0.07692308 0.11538462 0.15384615 0.19230769 [7] 0.23076923 0.26923077 0.30769231 0.34615385 0.38461538 0.42307692 [13] 0.46153846 0.50000000 0.53846154 0.57692308 0.61538462 0.65384615 [19] 0.69230769 0.73076923 0.76923077 0.80769231 0.84615385 0.88461538 [25] 0.92307692 0.96153846 1.00000000 . - 방법3: : 를 이용 . 1:22 . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 . 이 방법을 살짝 응용하면 0~1까지 57개의 변수를 넣는 방법을 아래와 같이 할 수 있다. . print(0:56 / 56) . [1] 0.00000000 0.01785714 0.03571429 0.05357143 0.07142857 0.08928571 [7] 0.10714286 0.12500000 0.14285714 0.16071429 0.17857143 0.19642857 [13] 0.21428571 0.23214286 0.25000000 0.26785714 0.28571429 0.30357143 [19] 0.32142857 0.33928571 0.35714286 0.37500000 0.39285714 0.41071429 [25] 0.42857143 0.44642857 0.46428571 0.48214286 0.50000000 0.51785714 [31] 0.53571429 0.55357143 0.57142857 0.58928571 0.60714286 0.62500000 [37] 0.64285714 0.66071429 0.67857143 0.69642857 0.71428571 0.73214286 [43] 0.75000000 0.76785714 0.78571429 0.80357143 0.82142857 0.83928571 [49] 0.85714286 0.87500000 0.89285714 0.91071429 0.92857143 0.94642857 [55] 0.96428571 0.98214286 1.00000000 . 물론 아래와 같이하는것이 더 가독성이 좋다. . print(seq(from=0,to=1,length.out =57)) . [1] 0.00000000 0.01785714 0.03571429 0.05357143 0.07142857 0.08928571 [7] 0.10714286 0.12500000 0.14285714 0.16071429 0.17857143 0.19642857 [13] 0.21428571 0.23214286 0.25000000 0.26785714 0.28571429 0.30357143 [19] 0.32142857 0.33928571 0.35714286 0.37500000 0.39285714 0.41071429 [25] 0.42857143 0.44642857 0.46428571 0.48214286 0.50000000 0.51785714 [31] 0.53571429 0.55357143 0.57142857 0.58928571 0.60714286 0.62500000 [37] 0.64285714 0.66071429 0.67857143 0.69642857 0.71428571 0.73214286 [43] 0.75000000 0.76785714 0.78571429 0.80357143 0.82142857 0.83928571 [49] 0.85714286 0.87500000 0.89285714 0.91071429 0.92857143 0.94642857 [55] 0.96428571 0.98214286 1.00000000 . - 방법4: rep를 이용 . rep(0,100) . [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 . &#54632;&#49688;&#49324;&#50857;&#54616;&#45716; &#48169;&#48277; . - 기본 구조 . 함수이름 &lt;- function(입력){ 함수의 기능 return(출력) } . f&lt;-function(d){ I0=1 Id=I0*0.25 y=I0*2^(-0.25*d)/Id return(y) } . f(8) . [1] 1 . - 아래의 2개의 코드는 거의 같다. . ### 1 f&lt;-function(d){ I0=1 Id=I0*0.25 y=I0*2^(-0.25*d)/Id return(y) } f(8) ### 2 d=8 I0=1 Id=I0*0.25 y=I0*2^(-0.25*d)/Id . [1] 1 . - return을 생략해도 괜찮다. . f&lt;-function(d){ I0=1 Id=I0*0.25 y=I0*2^(-0.25*d)/Id y } f(8) . [1] 1 . &#49689;&#51228; . - 주피터랩으로 R실습할 수 있는 환경을 설정 .",
            "url": "https://guebin.github.io/2021IR/2021/09/09/(2%EC%A3%BC%EC%B0%A8)-9%EC%9B%949%EC%9D%BC.html",
            "relUrl": "/2021/09/09/(2%EC%A3%BC%EC%B0%A8)-9%EC%9B%949%EC%9D%BC.html",
            "date": " • Sep 9, 2021"
        }
        
    
  
    
        ,"post31": {
            "title": "(1주차) 9월7일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/2): 2005년 예비평가(나) 12월/평가원26(고3) 첫번째 풀이 . - (2/2): 2005년 예비평가(나) 12월/평가원26(고3) 다양한 풀이 + 과제설명 . R&#51008; &#51339;&#51008; &#44228;&#49328;&#44592; &#51060;&#45796;. . 2005&#45380; &#50696;&#48708;&#54217;&#44032;(&#45208;) 12&#50900;/&#54217;&#44032;&#50896;26(&#44256;3) . 어떤 호수에서 수면에서의 빛의 세기가 $I_0$일 때, 수면이 $d$m인 곳에서의 빛의 세기 $I_d$는 다음과 같이 나타내어진다고 한다. . $$I_d=I_0 2^{-0.25d}$$ . 이 호수에서 빛의 세기가 수면에서의 빛의 세기의 25%인 곳의 수심은? (3점) . (1) 16m . (2) 12m . (3) 10m . (4) 8m . (5) 4m . (풀이1) . I0=1 d=8 Id=I0*0.25 . I0*2^(-0.25*d) ## 0.25 랑 비슷하면 된다. 현재는 Id=0.25니까.. . [1] 0.25 . (풀이2) . d=8 y=I0*2^(-0.25*d)/Id y . [1] 1 . - $y=1$이 나오는 $d$를 찾아보면된다. $ to$ 찾아보니까 $d=8$ . (풀이3) . - 함수라는걸 만들어보자. . - $d$를 입력하면, 알아서 $y$가 계산되면 좋겠다. . $$y=f(d)$$ . f&lt;-function(d){ y=I0*2^(-0.25*d)/Id y } . - $y=f(d)= frac{I_0 2^{-0.25 d}}{I_d}$ 를 함수를 만들자. . - $y=1$이 되는 $d$를 찾아보자. 그러면 답이다. . f(8) . [1] 1 . - $d=8$이 답이다. . (풀이4) . - $(d,f(d))$ 혹은 $(d,y)$를 그래프로 그려보자. . d&lt;-c(1,2,3) . d&lt;-seq(from=0,to=10,by=0.01) . y=I0*2^(-0.25*d)/Id . plot(d,y) . plot(d,y) abline(h=1,col=2,lwd=5,lty=3) . (풀이5) . x_&lt;-c(1,2,3,2,5) . x_ == 3 . [1] FALSE FALSE TRUE FALSE FALSE . d[y==1] . [1] 8 . &#49689;&#51228; . - 아래그림에서 수평선의 위치를 $y=2$로 조정하여 그려볼것 . plot(d,y) abline(h=1.1,col=2,lwd=5,lty=3) .",
            "url": "https://guebin.github.io/2021IR/2021/09/07/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%947%EC%9D%BC.html",
            "relUrl": "/2021/09/07/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%947%EC%9D%BC.html",
            "date": " • Sep 7, 2021"
        }
        
    
  
    
        ,"post32": {
            "title": "(1주차) 9월2일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/3): R소개 , R을 활용한 간단한 계산 . - (2/3): 통계학과 진로, 통계학과의 장점, 강의계획안내 . - (3/3): R설치방법, 과제안내 . &#47112;&#54252;&#53944; . - 카카오톡 스샷제출 .",
            "url": "https://guebin.github.io/2021IR/2021/09/02/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%942%EC%9D%BC.html",
            "relUrl": "/2021/09/02/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%942%EC%9D%BC.html",
            "date": " • Sep 2, 2021"
        }
        
    
  
    
        ,"post33": {
            "title": "(A1) 깃허브와 fastpages를 이용하여 블로그 개설하기",
            "content": "About this doc . - 본 포스트는 2021년 1학기 Python 입문 강의내용중 일부를 업로드 하였음. . - Github, fastpages를 사용하여 블로그를 개설하고 관리하는 방법에 대한 설명임. . .",
            "url": "https://guebin.github.io/2021IR/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0-Copy1.html",
            "relUrl": "/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0-Copy1.html",
            "date": " • Aug 17, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "최규빈 . guebin@jbnu.ac.kr | 자연과학대학교 본관 205호 | 카카오톡 오픈채널 1 | . 2021년 2학기 종료후 폐쇄예정 &#8617; . |",
          "url": "https://guebin.github.io/2021IR/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  

  
  

  
      ,"page12": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://guebin.github.io/2021IR/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}