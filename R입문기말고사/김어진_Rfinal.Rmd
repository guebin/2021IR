---
title: "Rfinal"
author: "김어진(201917959)"
institute: "it응용시스템공학과"
date: '2021 12 21'
fontsize: 12pt
output:
  pdf_document:
    includes:
      in_header: rfinalhead.tex
      
---

\newpage


## 1번 문제 < 회귀분석 >


(1) 벡터생성


```{r}
e=rnorm(1000)
head(e)
```



(2) 벡터생성


```{r}

t=c()
X_1=c()
X_2=c()
for(i in 1:1000){
    t[i]=2*pi*i/1000
    X_1[i]=sin(t[i])
    X_2[i]=cos(4*t[i])
}

head(X_1)
head(X_2)

```




(3) $y_i$를 계산하고 $(t_i, y_i)$를 시각화

- $y_i$  계산

```{r}
t=c()
X_1=c()
X_2=c()
y=c()
for(i in 1:1000){
    t[i]=2*pi*i/1000
    X_1[i]=sin(t[i])
    X_2[i]=cos(4*t[i])
    y[i]=1.5 + 5*X_1[i] + 3*X_2[i] + e[i]
}

head(y)

```

- $(t_i, y_i)$ 시각화

```{r}

plot(t,y,col='gray60')

```



(4) 매트릭스 생성

```{r}
X=cbind(1, X_1, X_2)
head(X)
```


(5) 매트릭스를 만들고 ${\mathbf X}{\boldsymbol \beta}$를 계산, 벡터화하고 시각화

- $\beta = \begin{bmatrix} 1.5\\5 \\ 3\end{bmatrix}$

```{r}

beta=rbind(1.5,5,3)
beta

```

- ${\mathbf X}{\boldsymbol \beta}$

```{r}
X %*% beta ->Xbeta
head(Xbeta)
```
```{r}

plot(t,y,col='gray60')
lines(t,Xbeta, col='red',lwd=3)
```

\newpage

(6) $\hat{\beta}$를 계산하고 ${\beta}$와 비교

```{r}
library(tidyverse)
dim(y)= c(1000,1)

X_T=t(X)
X_T %*% X %>% solve() %*% X_T %*% y ->betahat
betahat
```

$\hat{\beta} = \begin{bmatrix} 1.495225\\ 5.039034 \\ 2.925439\end{bmatrix}$


${\beta} = \begin{bmatrix} 1.5\\ 5 \\ 3\end{bmatrix}$

 약간은 차이가 나지만 비슷하다.


(7) ${\mathbf X}\hat{\beta}$를 계산

```{r}
X %*% betahat ->Xbetahat
Xbetahat=as.vector(Xbetahat)

plot(t,y,col='gray60')
lines(t,Xbeta, col='red',lwd=3)
lines(t,Xbetahat,lty=3, col='blue', lwd=4)

```
\newpage

## 2번 문제 < 몬테카를로 적분>

(1) `runif`를 이용해 몬테카를로 적분 계산

```{r}

x=seq(from=-1.96, to=1.96, by=0.01)
y=1/sqrt(2*pi) *exp(-1/2 *x^2)

plot(x,y,type='l')

xx=runif(10000, min=-1.96, max=1.96)
yy=runif(10000, min=0, max=0.40)

plot(xx,yy)
lines(x,y, col='red', lwd=3)

test = function(xx,yy){
    yy < 1/sqrt(2*pi) *exp(-1/2 *xx^2)
}

tst=c()
for(i in 1:10000) tst[i]= test(xx[i],yy[i])
head(tst)

sum(tst)
```
전체 10000개 중에서 6055개가 그래프 아래에 위치하므로
$\frac{s}{4*0.4} \approx \frac{sum(tst)}{10000}$
구하는 넓이는 대략적으로
```{r}
s=sum(tst)/10000*4*0.4
s
```

\newpage
(2) `rnorm()`을 이용해 확률변수를 count

```{r}
a=rnorm(1000)
a= as_tibble(a)
a %>% filter(-1.96 <value, value<1.96) %>% count()
```
 
 
 확률변수 1000개 중 945개가 구간(-1.96, 1.96) 사이에 위치한다.

\newpage
## 3번 문제 < 징검다리 >

 
- TYPE A: 10,9,8,$\dots$,3,2,1 순
```{r}

### 변수들의 모음
ARR = c('N1','N2','N3','N4','N5','N6','N7','N8','A','N10')#10,A,8,순
SURV = 10 
PLAYER = ARR[SURV] 
STAGE = 0 
PROB = 0.95
TOSSRSLT = NA

### 함수들의 모음
toss = function(p) rbinom(n=1,size=1,prob=p) %>% as.logical
reset = function(){
    TOSSRSLT <<- NA
    SURV <<- 10
    STAGE <<- 0 
    PLAYER <<- ARR[SURV]
}
record = function(){
    list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) 
}
go = function(){
    PROB <<- 0.5+ (PLAYER=='A')*0.45
    TOSSRSLT <<- toss(PROB) 
    if (TOSSRSLT==FALSE) SURV <<- SURV - 1 
    STAGE <<- STAGE + 1 
    PLAYER <<- ARR[SURV]
    if(SURV==0) reset()
}
gogo = function() for(i in 1:20) go()

gogo_history = function(){
    rslt_ = as_tibble(record()) 
    for(i in 1:20){
        go()
        rslt_ = rbind(rslt_, as_tibble(record())) 
    }
    print(rslt_)
}

simulate_once = function(){
    reset()
    gogo()
    return(record()$SURV )
}


### body
simrslt = c() 
for (i in 1:100000) simrslt[i] = simulate_once() 
mean(simrslt) 


```
`-` TYPE A에서 8번 참가자는 생존자가 8명이상일 때 생존가능하다.


- TYPE B: 1,2,3,$\dots$,8,9,10순
```{r}
ARR = c('N10','A','N8','N7','N6','N5','N4','N3','N2','N1')#1,2,3순
SURV = 10 
PLAYER = ARR[SURV] 
STAGE = 0 
PROB = 0.95
TOSSRSLT = NA

### 함수들의 모음
toss = function(p) rbinom(n=1,size=1,prob=p) %>% as.logical
reset = function(){
    TOSSRSLT <<- NA
    SURV <<- 10
    STAGE <<- 0 
    PLAYER <<- ARR[SURV]
}
record = function(){
    list(PRE_TOSSRSLT=TOSSRSLT, SURV=SURV, STAGE=STAGE, PLAYER=PLAYER) 
}
go = function(){
    PROB <<- 0.5+ (PLAYER=='A')*0.45
    TOSSRSLT <<- toss(PROB) 
    if (TOSSRSLT==FALSE) SURV <<- SURV - 1 
    STAGE <<- STAGE + 1 
    PLAYER <<- ARR[SURV]
    if(SURV==0) reset()
}
gogo = function() for(i in 1:20) go()

gogo_history = function(){
    rslt_ = as_tibble(record()) 
    for(i in 1:20){
        go()
        rslt_ = rbind(rslt_, as_tibble(record())) 
    }
    print(rslt_)
}

simulate_once = function(){
    reset()
    gogo()
    return(record()$SURV )
}


### body
simrslt = c() 
for (i in 1:100000) simrslt[i] = simulate_once() 
mean(simrslt) 

```
`-` TYPE B에서는 8번 참가자는 생존자가 3명 이상일 때 생존가능하다.

`-` 따라서 8번 참가자는 TYPE B에서 살아남을 확률이 높다. 

\newpage
## 4번 문제 < COVID19 >

```{r}
df=read_csv('https://raw.githubusercontent.com/guebin/2021IR/master/_notebooks/covid19.csv')
head(df)

```

  
    
    

(1) 2020년 확진자 총합과 2021년 확진자 총합은?

```{r}
df %>% group_by(year) %>% summarise(ttl_case=sum(cases))
```

2020년에는 60726명, 2021년에는 396886명

  
    
    

(2) 20년 2월 1일~15일까지의 기간동안 지역별 확진자의 총합과 가장 많은 확진자가 발견된 지역은?


```{r}
province=c('서울','부산','대구','인천','광주','대전','울산','세종','경기',
           '강원','충북','충남','전북','전남', '경북','경남','제주','검역')

tb=tibble(province=province, ttlcases=c(rep(0,length(province))))
a=c()
df %>% filter(year==2020 & month==2 & (day %in% c(1:15))) -> day1to15
for(i in 1:length(province)){
    day1to15 %>% filter(prov==province[i]) %>% summarise(ttl=sum(cases))-> a[i]
    tb[i,2]= a[i]
}
tb
```
```{r}
max(tb$ttlcases)
```


 2020년 2월 1일~15일동안 가장 많은 확진자가 발견된 지역은 경기(9)이다.
 
   
     
     
 
 (3) 2020년 2월 16일~29일까지의 기간동안 지역별 확진자의 총합과 가장 많은 확진자가 발견된 지역은?
 
```{r}

df %>% filter(year==2020 & month==2 & (day %in% c(16:29))) -> day16to29
for(i in 1:length(province)){
    day16to29 %>% filter(prov==province[i]) %>% summarise(ttl=sum(cases))-> a[i]
    tb[i,2]= a[i]
}
tb
```
```{r}
max(tb$ttlcases)
```



 2020년 2월 16일~29일동안 가장 많은 확진자가 발견된 지역은 대구(2055)이다.