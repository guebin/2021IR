---
title: "R입문 기말고사"
author: "김성호(201619243)"
date: '12/21/2021 '
fontsize: 12pt
output: 
  pdf_document:
    includes:
        in_header: head.tex
      
---

```{r,echo=FALSE}
library(tidyverse)
```


## 1번 회귀분석

아래와 같은 수식을 고려하자.

$y_i= 1.5+ 5\sin(t_i)+ 3 \cos(4 t_i)+\epsilon_i, \quad i=1,2,\dots, 1000$

 $t_i =\frac{2\pi i}{1000}$ 이다. 그리고 $\epsilon_i \sim i.i.d~ N(0,1)$ 즉 서로 독립인 표준정규분포에서 추출된 샘플이다. 

 
#### `(1)` `rnorm()`을 이용하여 $\{\epsilon_i \}_{i=1}^{1000}$ 을 만들고 이를 벡터로 만들어라. 즉 아래와 같은 벡터를 생성하라. 

- $\boldsymbol{\epsilon}=(\epsilon_1,\dots,\epsilon_{1000})$

```{r}

i = c(1:1000)
t=c(2*pi*i/1000)
e_i=(rnorm(1000))

head(e_i)
```

#### `(2)` $\big\{\sin(t_i) \big\}_{i=1}^{1000}$와 $\big\{\cos(4t_i) \big\}_{i=1}^{1000}$를 각각 생성하고 이를 ${\bf x}_1$와 ${\bf x}_2$에 저장하라. 즉 아래와 같은 2개의 벡터를 생성하라. 
- ${\bf x}_1=\big(\sin(\frac{2\pi}{1000}),\sin(\frac{4\pi}{1000}),\dots,\sin(2\pi)\big)$
- ${\bf x}_2=\big(\cos(\frac{8\pi}{1000}),\cos(\frac{16\pi}{1000}),\dots,\cos(8\pi)\big)$
```{r}
x1=sin(t[i])
x2=cos(4*t[i])

head(x1)
head(x2)
```


#### `(3)` (1),(2)로 부터 $y_i$를 계산하고, $(t_i,y_i)$를 scatter plot으로 시각화 하라. 

색은 'gray60'을 사용하라.


```{r, fig.width=5,fig.height=4}
y_i=c(1.5+5*x1+3*x2+e_i[i])

plot(t,y_i,col='gray60',main = 'scatter plot')
```


---


#### `(4)` 두 벡터 ${\bf x}_1$, ${\bf x}_2$와 `cbind()`를 이용하여 아래와 같은 $1000 \times 3$ 매트릭스 ${\bf X}$를 만들어라. 



${\bf X}=\begin{bmatrix}
1 & \sin(\frac{2\pi}{1000}) & \cos(\frac{8\pi}{1000})\\ 
1 & \sin(\frac{4\pi}{1000}) & \cos(\frac{16\pi}{1000})\\ 
\dots & \dots  & \dots \\ 
1 & \sin(2\pi) & \cos(8\pi)\\ 
\end{bmatrix}$ 


```{r}
X=cbind(1,x1,x2)
X[1:5,]
```

---

#### `(5)` $3 \times 1$ 매트릭스 $\boldsymbol{\beta}=\begin{bmatrix} 1.5 \\ 5 \\ 3 \end{bmatrix}$를 만들고 매트릭스 곱을 이용하여 ${\bf X} {\boldsymbol \beta}$를 계산하라. 계산결과를 벡터화하고 (3)의 $y$축에 붉은선으로 시각화 하라.


- 코드     
```{r,fig.width=5,fig.height=4}
b=c(1.5,5,3)
dim(b) = c(3,1)
b

BX= X%*%b 
plot(t,y_i,col='gray60',main = 'scatter plot')

lines(t,BX,col='red',lwd=4)
```

---

#### `(6)` 아래의 수식을 이용하여 $\boldsymbol{\hat\beta}$를 계산하고 계산결과를 $\boldsymbol{\beta}$와 비교하라. 

$$ \boldsymbol{\hat\beta} = ({\bf X}^\top {\bf X})^{-1}{\bf X}^\top {\bf y}$$


```{r}
y_=cbind(y_i)
Xt=t(X)         
Xs=solve(Xt%*%X) # X^T*X의 역행렬
Bh = Xs%*%(Xt%*%y_)
```

> $\boldsymbol{\hat\beta}$
```{r}
print(Bh)
```

> $\boldsymbol{\beta}$
```{r}
print(b)  
```



#### `(7)` ${\bf X}\boldsymbol{\hat\beta}$를 계산하라. 계산결과를 벡터화 하고 (5)의 시각화 결과에 푸른점선으로 시각화 하라.


===

```{r,fig.width=5,fig.height=4}
XBh = X%*%Bh
plot(t,y_i,col='gray60',main = 'scatter plot')

lines(t,BX,col='red',lwd=4)

lines(t, XBh, col='blue',lwd=4,lty=3)

```



\newpage


## 2번  몬테카를로 적분

#### `(1)` $\int_{-1.96}^{1.96}\frac{1}{\sqrt{2\pi}}e^{-\frac{1}{2}x^2}dx$의 값을 `runif()`를 이용한 몬테카를로 적분으로 계산하라. 

- 코드

```{r, fig.width=4,fig.height=5}
x=seq(from=-1.96,to=1.96,by=0.01)
y=(1/sqrt(2*pi))*exp((-1/2)*(x^2))
plot(x,y,type='l')
```

- 위 그래프에 무작위로 10000개의 점을 찍는다.

```{r, fig.width=4,fig.height=5}
xx=runif(10000,-1.96,1.96)
yy=runif(10000,0.05,0.40)
plot(xx,yy)
lines(x,y,col='red',lwd=3)
```

- 빨간 그래프 아래의 점 개수를 알아야 함.

```{r}
test= function(xx,yy){
        yy< abs((1/sqrt(2*pi))*exp((-1/2)*(xx^2)))
}

c(xx[1],yy[1])
abs((1/sqrt(2*pi))*exp((-1/2)*(xx[1]^2)))
test(xx[1],yy[1]) # 테스트 결과 TRUE면 그래프 아래쪽, FALSE면 그래프 위쪽에 점이 존재해야 함.

```

- test

```{r, fig.width=4,fig.height=5}
plot(xx,yy,col='gray')
lines(x,y,col='red',lwd=3)
points(xx[1],yy[1],col='blue')
points(xx[1],abs((1/sqrt(2*pi))*exp((-1/2)*(xx[1]^2))),col='red')
# 빨간 점은 그래프와 겹치게 존재함.
```

- 조건에 맞는 점들

```{r, fig.width=4,fig.height=5}
tst= c()
for(i in 1:10000) tst[i] = test(xx[i],yy[i])

plot(xx,yy,col='gray')
lines(x,y,col='red',lwd=4)
points(xx[tst],yy[tst],col='green')
```

- 결과

```{r}
sum(tst)

#답

sum(tst)/10000
```


#### `(2)` `rnorm()`을 이용하여 표준정규분포에서 1000개의 확률변수를 생성하고 생성된 확률변수들 중 구간 $(-1.96 , 1.96)$사이에 있는 확률변수를 count하라. 


- 코드 


```{r, fig.width=5,fig.height=5}
set.seed(1)
x_=rnorm(1000)

plot(x_)
abline(h=-1.96,col='red',lwd=2 )
abline(h=1.96,col='red',lwd=2 )
points((1:1000)[abs(x_)<1.96], x_[(abs(x_)<1.96)],col='green')
#답

sum(abs(x_)<1.96)


```

\newpage


## 3번 징검다리 


10명의 참가자가 (유리,강화유리)의 쌍으로 이루어진 징검다리를 건너는 게임을 시작한다. (유리,강화유리)의 쌍은 총 20개 있다. 따라서 유리는 총 40장이 있다. 참가자는 강화유리로 된 징검다리를 밟으면 살아남지만 유리로 된 징검다리를 밟으면 죽는다. 10명의 참가자의 특징은 아래와 같다. 

- 1번~8번 참가자, 10번 참가자: 50퍼센트의 확률로 강화유리를 고를 수 있다. 
- 9번 참가자: 95퍼센트의 확률로 강화유리를 고를 수 있다. 

다리를 건너는 순서는 아래와 같이 번호의 오름차순으로 건너는 방법과 번호의 내림차순으로 건너는 2가지 방법이 있다고 하자. 

- Type A: 10번 참가자부터 다리를 건너고 그 뒤로 9번, 8번, ... 1번 순으로 다리를 건넌다. 
- Type B: 1번 참가자부터 다리를 건너고 그 뒤로 2번, 3번, ... 10번 순으로 다리를 건넌다. 

8번 참가자는 Type A 와 Type B 중 어떠한 경우에 살아남을 확률이 높은가? 


`-` Type A 10번 참가자부터 고를 때.

- 코드

```{r}
ARR = c('1','2','3','4','5','6','7','8','A','10')
SURV = 10 
PLAYER = ARR[SURV] 
STAGE = 0 
PROB = 0.5 
TOSSRSLT = NA

```

```{r}
toss = function(p) rbinom(n=1, size=1, prob=p)
reset = function(){
        TOSSRSLT <<- NA
        SURV <<- 10
        STAGE <<- 0
        PLAYER <<- ARR[SURV]
}
record = function(){
        list(PRE_TOSSRSLT=TOSSRSLT,SURV=SURV, STAGE=STAGE, PLAYER=PLAYER)
}

```

```{r}


go = function(){
    PROB <<- 0.5
    if(PLAYER=='A') PROB = 0.95
    TOSSRSLT <<- toss(PROB) 
    if (TOSSRSLT==FALSE) SURV <<- SURV - 1 
    STAGE <<- STAGE + 1 
    PLAYER <<- ARR[SURV]    
}

go20 = function() for (i in 1:20){ 
    go()
    if(SURV==0){
        break
    }

}

```

```{r}

simulate_once = function(){
        reset()
        go20()
        return(record()$SURV)
        
}
```

- 결과

```{r}
simrslt = c() 
for (i in 1:100000) simrslt[i] = simulate_once() 
sum(simrslt>=8) # 10만번 반복 중 8번 참가자가 살아남는 횟수

```



`-` Type B 1번 참가자부터 고를 때

- 코드

```{r}
ARR_B = c('10','A','8','7','6','5','4','3','2','1')
SURV_B = 10 
PLAYER_B = ARR_B[SURV_B] 
STAGE_B = 0 
PROB_B = 0.5 
TOSSRSLT_B = NA
```

```{r}
toss_B = function(p) rbinom(n=1, size=1, prob=p)
reset_B = function(){
        TOSSRSLT_B <<- NA
        SURV_B <<- 10
        STAGE_B <<- 0
        PLAYER_B <<- ARR_B[SURV_B]
}
record_B = function(){
        list(PRE_TOSSRSLT_B=TOSSRSLT_B,SURV_B=SURV_B, STAGE_B=STAGE_B, PLAYER_B=PLAYER_B)
}

```

```{r}
go_B = function(){
    PROB_B <<- 0.5
    if(PLAYER_B=='A') PROB_B = 0.95
    TOSSRSLT_B <<- toss(PROB_B) 
    if (TOSSRSLT_B==FALSE) SURV_B <<- SURV_B - 1 
    STAGE_B <<- STAGE_B + 1 
    PLAYER_B <<- ARR_B[SURV_B]    
}

go20_B = function() for (i in 1:20){
    go_B()
    if(SURV_B==0){
        break
    }

}

```

```{r}
simulate_once_B = function(){
        reset_B()
        go20_B()
        return(record_B()$SURV_B)
        
}
```

- 결과

```{r}
simrslt_B = c() 
for (i in 1:100000) simrslt_B[i] = simulate_once_B() 
sum(simrslt_B>=8) # 10만회중 8번이 살아남는 횟수
```

`-` 살아남을 확률

$$Type A   >  Type B$$ 

\newpage


## `4`. COVID19

- 아래는 한국의 코로나확진자 발생수를 tibble로 불러오는 코드와 그 결과이다.  

```{r}
df=read_csv('https://raw.githubusercontent.com/guebin/2021IR/master/_notebooks/covid19.csv')
head(df)
```


#### `(1)` 2020년의 확진자(cases)총합과 2021년의 확진자(cases)총합을 구하라. 

- 코드와 결과

```{r}
df %>% group_by(year) %>% summarise(sum(cases))
# 2020년: 60726명, 2021년:396886명 
```


#### `(2)` 2020년 2월1일 ~ 2020년 2월15일까지의 기간동안 확진자의 합을 지역별로 나누어 구하라 (아래예시 참고). 가장 많은 확진자가 발견된 지역은 어디인가? 


- 코드

```{r}
df %>% filter(month==2) %>% filter( day<16) %>% group_by(prov) %>% summarise(sum(cases)) -> Febup
colnames(Febup)=c('prov','sum')
Febup=Febup[order(Febup$sum),]
Febup #서울이 가장 많다.
```


#### `(3)` 2020년 2월16일 ~ 2020년 2월29일까지의 기간동안 확진자의 총합을 지역별로 나누어 구하라 (아래예시 참고). 가장 많은 확진자가 발견된 지역은 어디인가?


- 코드 

```{r}
df %>% filter(month==2) %>% filter( day>15) %>% group_by(prov) %>% summarise(sum(cases)) -> Febdown
colnames(Febdown)=c('prov','sum')
Febdown=Febdown[order(Febdown$sum),]
Febdown #대구가 가장 많다.
```





